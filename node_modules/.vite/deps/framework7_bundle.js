import {
  ConstructorMethods,
  ModalMethods,
  app_class_default,
  auroraPreloaderContent,
  bindMethods,
  class_default,
  clicks_default,
  colorHexToRgb,
  colorHsbToHsl,
  colorHslToHsb,
  colorHslToRgb,
  colorRgbToHex,
  colorRgbToHsl,
  component_class_default,
  component_default,
  component_loader_default,
  create_store_default,
  deleteProps,
  device_default,
  dom7_default,
  extend,
  getDevice,
  getSupport,
  getTranslate,
  history_default,
  id,
  iosPreloaderContent,
  jsx_default,
  mdPreloaderContent,
  modal_class_default,
  modal_default,
  navbar_default,
  nextFrame,
  nextTick,
  now,
  request_default,
  request_default2,
  resize_default,
  router_class_default,
  router_default,
  serializeObject,
  service_worker_default,
  statusbar_default,
  store_default,
  subnavbar_default,
  support_default,
  toolbar_default,
  touch_default,
  touch_ripple_default,
  utils_default,
  utils_exports,
  view_default
} from "./chunk-DCMF62D6.js";
import {
  $,
  addClass,
  append,
  attr,
  children,
  closest,
  css,
  each,
  eq,
  filter,
  find,
  getDocument,
  getWindow,
  hasClass,
  html,
  index,
  is,
  next,
  nextAll,
  off,
  offset,
  on,
  outerHeight,
  outerWidth,
  parent,
  parents,
  prepend,
  prev,
  prevAll,
  remove,
  removeAttr,
  removeClass,
  styles,
  text,
  toggleClass,
  transform,
  transition,
  transitionEnd,
  trigger
} from "./chunk-IBGLJG3F.js";

// node_modules/framework7/components/appbar/appbar.js
var appbar_default = {
  name: "appbar"
};

// node_modules/framework7/shared/$jsx.js
var $jsx = function(tag, props) {
  const attrs = props || {};
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  const children2 = args || [];
  const attrsString = Object.keys(attrs).map((attr2) => {
    if (attr2[0] === "_") {
      if (attrs[attr2])
        return attr2.replace("_", "");
      return "";
    }
    return `${attr2}="${attrs[attr2]}"`;
  }).filter((attr2) => !!attr2).join(" ");
  if (["path", "img", "circle", "polygon", "line", "input"].indexOf(tag) >= 0) {
    return `<${tag} ${attrsString} />`.trim();
  }
  const childrenContent = children2.filter((c) => !!c).map((c) => Array.isArray(c) ? c.join("") : c).join("");
  return `<${tag} ${attrsString}>${childrenContent}</${tag}>`.trim();
};
var jsx_default2 = $jsx;

// node_modules/framework7/components/dialog/dialog-class.js
var Dialog = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      title: app.params.dialog.title,
      text: void 0,
      content: "",
      buttons: [],
      verticalButtons: false,
      onClick: void 0,
      cssClass: void 0,
      destroyOnClose: false,
      on: {}
    }, params);
    if (typeof extendedParams.closeByBackdropClick === "undefined") {
      extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
    }
    if (typeof extendedParams.backdrop === "undefined") {
      extendedParams.backdrop = app.params.dialog.backdrop;
    }
    super(app, extendedParams);
    const dialog = this;
    const device = getDevice();
    const document = getDocument();
    const {
      title,
      text: text2,
      content,
      buttons,
      verticalButtons,
      cssClass,
      backdrop
    } = extendedParams;
    dialog.params = extendedParams;
    let $el;
    if (!dialog.params.el) {
      const dialogClasses = ["dialog"];
      if (buttons.length === 0)
        dialogClasses.push("dialog-no-buttons");
      if (buttons.length > 0)
        dialogClasses.push(`dialog-buttons-${buttons.length}`);
      if (verticalButtons)
        dialogClasses.push("dialog-buttons-vertical");
      if (cssClass)
        dialogClasses.push(cssClass);
      let buttonsHTML = "";
      if (buttons.length > 0) {
        buttonsHTML = jsx_default2("div", {
          class: "dialog-buttons"
        }, buttons.map((button) => jsx_default2("span", {
          class: `dialog-button${button.bold ? " dialog-button-bold" : ""}${button.color ? ` color-${button.color}` : ""}${button.cssClass ? ` ${button.cssClass}` : ""}`
        }, button.text)));
      }
      const dialogHtml = jsx_default2("div", {
        class: dialogClasses.join(" ")
      }, jsx_default2("div", {
        class: "dialog-inner"
      }, title && jsx_default2("div", {
        class: "dialog-title"
      }, title), text2 && jsx_default2("div", {
        class: "dialog-text"
      }, text2), content), buttonsHTML);
      $el = dom7_default(dialogHtml);
    } else {
      $el = dom7_default(dialog.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return dialog.destroy();
    }
    let $backdropEl;
    if (backdrop) {
      $backdropEl = app.$el.children(".dialog-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="dialog-backdrop"></div>');
        app.$el.append($backdropEl);
      }
    }
    function buttonOnClick(e) {
      const buttonEl = this;
      const index2 = dom7_default(buttonEl).index();
      const button = buttons[index2];
      if (button.onClick)
        button.onClick(dialog, e);
      if (dialog.params.onClick)
        dialog.params.onClick(dialog, index2);
      if (button.close !== false)
        dialog.close();
    }
    let addKeyboardHander;
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      buttons.forEach((button, index2) => {
        if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
          if (document.activeElement)
            document.activeElement.blur();
          if (button.onClick)
            button.onClick(dialog, e);
          if (dialog.params.onClick)
            dialog.params.onClick(dialog, index2);
          if (button.close !== false)
            dialog.close();
        }
      });
    }
    if (buttons && buttons.length > 0) {
      dialog.on("open", () => {
        $el.find(".dialog-button").each((buttonEl, index2) => {
          const button = buttons[index2];
          if (button.keyCodes)
            addKeyboardHander = true;
          dom7_default(buttonEl).on("click", buttonOnClick);
        });
        if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
          dom7_default(document).on("keydown", onKeyDown);
        }
      });
      dialog.on("close", () => {
        $el.find(".dialog-button").each((buttonEl) => {
          dom7_default(buttonEl).off("click", buttonOnClick);
        });
        if (addKeyboardHander && !device.ios && !device.android && !device.cordova && !device.capacitor) {
          dom7_default(document).off("keydown", onKeyDown);
        }
        addKeyboardHander = false;
      });
    }
    extend(dialog, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "dialog",
      setProgress(progress, duration) {
        app.progressbar.set($el.find(".progressbar"), progress, duration);
        return dialog;
      },
      setText(newText) {
        let $textEl = $el.find(".dialog-text");
        if ($textEl.length === 0) {
          $textEl = dom7_default('<div class="dialog-text"></div>');
          if (typeof title !== "undefined") {
            $textEl.insertAfter($el.find(".dialog-title"));
          } else {
            $el.find(".dialog-inner").prepend($textEl);
          }
        }
        $textEl.html(newText);
        dialog.params.text = newText;
        return dialog;
      },
      setTitle(newTitle) {
        let $titleEl = $el.find(".dialog-title");
        if ($titleEl.length === 0) {
          $titleEl = dom7_default('<div class="dialog-title"></div>');
          $el.find(".dialog-inner").prepend($titleEl);
        }
        $titleEl.html(newTitle);
        dialog.params.title = newTitle;
        return dialog;
      }
    });
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      if ($target.closest(dialog.el).length === 0) {
        if (dialog.params.closeByBackdropClick && dialog.backdropEl && dialog.backdropEl === target) {
          dialog.close();
        }
      }
    }
    dialog.on("opened", () => {
      if (dialog.params.closeByBackdropClick) {
        app.on("click", handleClick);
      }
    });
    dialog.on("close", () => {
      if (dialog.params.closeByBackdropClick) {
        app.off("click", handleClick);
      }
    });
    $el[0].f7Modal = dialog;
    if (dialog.params.destroyOnClose) {
      dialog.once("closed", () => {
        setTimeout(() => {
          dialog.destroy();
        }, 0);
      });
    }
    return dialog;
  }
};
var dialog_class_default = Dialog;

// node_modules/framework7/components/dialog/dialog.js
var dialog_default = {
  name: "dialog",
  params: {
    dialog: {
      title: void 0,
      buttonOk: "OK",
      buttonCancel: "Cancel",
      usernamePlaceholder: "Username",
      passwordPlaceholder: "Password",
      preloaderTitle: "Loading... ",
      progressTitle: "Loading... ",
      backdrop: true,
      closeByBackdropClick: false,
      destroyPredefinedDialogs: true,
      keyboardActions: true,
      autoFocus: true
    }
  },
  static: {
    Dialog: dialog_class_default
  },
  create() {
    const app = this;
    function defaultDialogTitle() {
      return app.params.dialog.title || app.name;
    }
    const destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
    const keyboardActions = app.params.dialog.keyboardActions;
    const autoFocus = app.params.dialog.autoFocus;
    const autoFocusHandler = autoFocus ? {
      on: {
        opened(dialog) {
          dialog.$el.find("input").eq(0).focus();
        }
      }
    } : {};
    app.dialog = extend(ModalMethods({
      app,
      constructor: dialog_class_default,
      defaultSelector: ".dialog.modal-in"
    }), {
      alert() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        let [text2, title, callbackOk] = args;
        if (args.length === 2 && typeof args[1] === "function") {
          [text2, callbackOk, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text: text2,
          buttons: [{
            text: app.params.dialog.buttonOk,
            bold: true,
            onClick: callbackOk,
            keyCodes: keyboardActions ? [13, 27] : null
          }],
          destroyOnClose
        }).open();
      },
      prompt() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        let [text2, title, callbackOk, callbackCancel, defaultValue] = args;
        if (typeof args[1] === "function") {
          [text2, callbackOk, callbackCancel, defaultValue, title] = args;
        }
        defaultValue = typeof defaultValue === "undefined" || defaultValue === null ? "" : defaultValue;
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text: text2,
          content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${defaultValue}"></div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],
          onClick(dialog, index2) {
            const inputValue = dialog.$el.find(".dialog-input").val();
            if (index2 === 0 && callbackCancel)
              callbackCancel(inputValue);
            if (index2 === 1 && callbackOk)
              callbackOk(inputValue);
          },
          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },
      confirm() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        let [text2, title, callbackOk, callbackCancel] = args;
        if (typeof args[1] === "function") {
          [text2, callbackOk, callbackCancel, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text: text2,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            onClick: callbackCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            onClick: callbackOk,
            keyCodes: keyboardActions ? [13] : null
          }],
          destroyOnClose
        }).open();
      },
      login() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        let [text2, title, callbackOk, callbackCancel] = args;
        if (typeof args[1] === "function") {
          [text2, callbackOk, callbackCancel, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text: text2,
          content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${app.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],
          onClick(dialog, index2) {
            const username = dialog.$el.find('[name="dialog-username"]').val();
            const password = dialog.$el.find('[name="dialog-password"]').val();
            if (index2 === 0 && callbackCancel)
              callbackCancel(username, password);
            if (index2 === 1 && callbackOk)
              callbackOk(username, password);
          },
          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },
      password() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        let [text2, title, callbackOk, callbackCancel] = args;
        if (typeof args[1] === "function") {
          [text2, callbackOk, callbackCancel, title] = args;
        }
        return new dialog_class_default(app, {
          title: typeof title === "undefined" ? defaultDialogTitle() : title,
          text: text2,
          content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
          buttons: [{
            text: app.params.dialog.buttonCancel,
            keyCodes: keyboardActions ? [27] : null,
            color: app.theme === "aurora" ? "gray" : null
          }, {
            text: app.params.dialog.buttonOk,
            bold: true,
            keyCodes: keyboardActions ? [13] : null
          }],
          onClick(dialog, index2) {
            const password = dialog.$el.find('[name="dialog-password"]').val();
            if (index2 === 0 && callbackCancel)
              callbackCancel(password);
            if (index2 === 1 && callbackOk)
              callbackOk(password);
          },
          destroyOnClose,
          ...autoFocusHandler
        }).open();
      },
      preloader(title, color) {
        const preloaders = {
          iosPreloaderContent,
          mdPreloaderContent,
          auroraPreloaderContent
        };
        const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || "";
        return new dialog_class_default(app, {
          title: typeof title === "undefined" || title === null ? app.params.dialog.preloaderTitle : title,
          content: `<div class="preloader${color ? ` color-${color}` : ""}">${preloaderInner}</div>`,
          cssClass: "dialog-preloader",
          destroyOnClose
        }).open();
      },
      progress() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        let [title, progress, color] = args;
        if (args.length === 2) {
          if (typeof args[0] === "number") {
            [progress, color, title] = args;
          } else if (typeof args[0] === "string" && typeof args[1] === "string") {
            [title, color, progress] = args;
          }
        } else if (args.length === 1) {
          if (typeof args[0] === "number") {
            [progress, title, color] = args;
          }
        }
        const infinite = typeof progress === "undefined";
        const dialog = new dialog_class_default(app, {
          title: typeof title === "undefined" ? app.params.dialog.progressTitle : title,
          cssClass: "dialog-progress",
          content: `
              <div class="progressbar${infinite ? "-infinite" : ""}${color ? ` color-${color}` : ""}">
                ${!infinite ? "<span></span>" : ""}
              </div>
            `,
          destroyOnClose
        });
        if (!infinite)
          dialog.setProgress(progress);
        return dialog.open();
      }
    });
  }
};

// node_modules/framework7/components/popup/popup-class.js
var Popup = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.popup, params);
    super(app, extendedParams);
    const popup = this;
    const window2 = getWindow();
    const document = getDocument();
    const support2 = getSupport();
    const device = getDevice();
    popup.params = extendedParams;
    let $el;
    if (!popup.params.el) {
      $el = dom7_default(popup.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(popup.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return popup.destroy();
    }
    let $backdropEl;
    if (popup.params.backdrop && popup.params.backdropEl) {
      $backdropEl = dom7_default(popup.params.backdropEl);
    } else if (popup.params.backdrop) {
      if (popup.params.backdropUnique) {
        $backdropEl = dom7_default('<div class="popup-backdrop popup-backdrop-unique"></div>');
        popup.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popup.$containerEl.children(".popup-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="popup-backdrop"></div>');
        popup.$containerEl.append($backdropEl);
      }
    }
    extend(popup, {
      app,
      push: $el.hasClass("popup-push") || popup.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "popup",
      $htmlEl: dom7_default("html")
    });
    if (popup.params.push) {
      $el.addClass("popup-push");
    }
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window2.Keyboard && window2.Keyboard.isVisible || window2.cordova.plugins && window2.cordova.plugins.Keyboard && window2.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(popup.el).length === 0) {
        if (popup.params && popup.params.closeByBackdropClick && popup.params.backdrop && popup.backdropEl && popup.backdropEl === target) {
          let needToClose = true;
          popup.$el.nextAll(".popup.modal-in").each((popupEl) => {
            const popupInstance = popupEl.f7Modal;
            if (!popupInstance)
              return;
            if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === popup.backdropEl) {
              needToClose = false;
            }
          });
          if (needToClose) {
            popup.close();
          }
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popup.params.closeOnEscape) {
        popup.close();
      }
    }
    let pushOffset;
    let isPush;
    function pushViewScale(offset2) {
      return (app.height - offset2 * 2) / app.height;
    }
    let allowSwipeToClose = true;
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let pageContentEl;
    let pageContentScrollTop;
    let pageContentOffsetHeight;
    let pageContentScrollHeight;
    let popupHeight;
    let $pushEl;
    function handleTouchStart(e) {
      if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose)
        return;
      if (popup.params.swipeHandler && dom7_default(e.target).closest(popup.params.swipeHandler).length === 0) {
        return;
      }
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = now();
      isScrolling = void 0;
      if (!popup.params.swipeHandler && e.type === "touchstart") {
        pageContentEl = dom7_default(e.target).closest(".page-content")[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      currentTouch = {
        x: e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY
      };
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      touchesDiff = startTouch.y - currentTouch.y;
      if (isPush && pushOffset && touchesDiff > 0) {
        touchesDiff = 0;
      }
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      $el.transition(0);
      if (typeof popup.params.swipeToClose === "string" && direction !== popup.params.swipeToClose) {
        $el.transform("");
        $el.transition("");
        return;
      }
      if (!isMoved) {
        if (isPush && pushOffset) {
          popupHeight = $el[0].offsetHeight;
          $pushEl = $el.prevAll(".popup.modal-in").eq(0);
          if ($pushEl.length === 0) {
            $pushEl = app.$el.children(".view, .views");
          }
        }
        if (pageContentEl) {
          pageContentScrollTop = pageContentEl.scrollTop;
          pageContentScrollHeight = pageContentEl.scrollHeight;
          pageContentOffsetHeight = pageContentEl.offsetHeight;
          if (!(pageContentScrollHeight === pageContentOffsetHeight) && !(direction === "to-bottom" && pageContentScrollTop === 0) && !(direction === "to-top" && pageContentScrollTop === pageContentScrollHeight - pageContentOffsetHeight)) {
            $el.transform("");
            $el.transition("");
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        isMoved = true;
        popup.emit("local::swipeStart popupSwipeStart", popup);
        popup.$el.trigger("popup:swipestart");
      } else {
        popup.emit("local::swipeMove popupSwipeMove", popup);
        popup.$el.trigger("popup:swipemove");
      }
      e.preventDefault();
      if (isPush && pushOffset) {
        const pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        if ($pushEl.hasClass("popup")) {
          if ($pushEl.hasClass("popup-push")) {
            $pushEl.transition(0).forEach((el) => {
              el.style.setProperty("transform", `translate3d(0, calc(-1 * ${pushProgress} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${scale})`, "important");
            });
          } else {
            $pushEl.transition(0).forEach((el) => {
              el.style.setProperty("transform", `translate3d(0, 0px , 0px) scale(${scale})`, "important");
            });
          }
        } else {
          $pushEl.transition(0).forEach((el) => {
            el.style.setProperty("transform", `translate3d(0,0,0) scale(${scale})`, "important");
          });
        }
      }
      $el.transition(0).transform(`translate3d(0,${-touchesDiff}px,0)`);
    }
    function handleTouchEnd() {
      isTouched = false;
      if (!isMoved) {
        return;
      }
      popup.emit("local::swipeEnd popupSwipeEnd", popup);
      popup.$el.trigger("popup:swipeend");
      isMoved = false;
      allowSwipeToClose = false;
      $el.transition("");
      if (isPush && pushOffset) {
        $pushEl.transition("").transform("");
      }
      const direction = touchesDiff <= 0 ? "to-bottom" : "to-top";
      if (typeof popup.params.swipeToClose === "string" && direction !== popup.params.swipeToClose) {
        $el.transform("");
        allowSwipeToClose = true;
        return;
      }
      const diff = Math.abs(touchesDiff);
      const timeDiff = new Date().getTime() - touchStartTime;
      if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
        nextTick(() => {
          if (direction === "to-bottom") {
            $el.addClass("swipe-close-to-bottom");
          } else {
            $el.addClass("swipe-close-to-top");
          }
          $el.transform("");
          popup.emit("local::swipeclose popupSwipeClose", popup);
          popup.$el.trigger("popup:swipeclose");
          popup.close();
          allowSwipeToClose = true;
        });
        return;
      }
      allowSwipeToClose = true;
      $el.transform("");
    }
    const passive = support2.passiveListener ? {
      passive: true
    } : false;
    if (popup.params.swipeToClose) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      popup.once("popupDestroy", () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off("touchmove", handleTouchMove);
        app.off("touchend:passive", handleTouchEnd);
      });
    }
    let hasPreviousPushPopup;
    const updatePushOffset = () => {
      const wasPush = isPush;
      if (popup.push) {
        isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass("popup-tablet-fullscreen"));
      }
      if (isPush && !wasPush) {
        setPushOffset();
      } else if (isPush && wasPush) {
        popup.$htmlEl[0].style.setProperty("--f7-popup-push-scale", pushViewScale(pushOffset));
      } else if (!isPush && wasPush) {
        popup.$htmlEl.removeClass("with-modal-popup-push");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-scale");
      }
    };
    const setPushOffset = () => {
      app.off("resize", updatePushOffset);
      if (popup.push) {
        isPush = popup.push && (app.width < 630 || app.height < 630 || $el.hasClass("popup-tablet-fullscreen"));
      }
      if (isPush) {
        pushOffset = parseInt($el.css("--f7-popup-push-offset"), 10);
        if (Number.isNaN(pushOffset))
          pushOffset = 0;
        if (pushOffset) {
          $el.addClass("popup-push");
          popup.$htmlEl.addClass("with-modal-popup-push");
          popup.$htmlEl[0].style.setProperty("--f7-popup-push-scale", pushViewScale(pushOffset));
        }
      }
      app.on("resize", updatePushOffset);
    };
    popup.on("open", () => {
      hasPreviousPushPopup = false;
      if (popup.params.closeOnEscape) {
        dom7_default(document).on("keydown", onKeyDown);
      }
      $el.prevAll(".popup.modal-in").addClass("popup-behind");
      setPushOffset();
    });
    popup.on("opened", () => {
      $el.removeClass("swipe-close-to-bottom swipe-close-to-top");
      if (popup.params.closeByBackdropClick) {
        app.on("click", handleClick);
      }
    });
    popup.on("close", () => {
      hasPreviousPushPopup = popup.$el.prevAll(".popup-push.modal-in").length > 0;
      if (popup.params.closeOnEscape) {
        dom7_default(document).off("keydown", onKeyDown);
      }
      if (popup.params.closeByBackdropClick) {
        app.off("click", handleClick);
      }
      $el.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind");
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass("with-modal-popup-push");
        popup.$htmlEl.addClass("with-modal-popup-push-closing");
      }
      app.off("resize", updatePushOffset);
    });
    popup.on("closed", () => {
      $el.removeClass("popup-behind");
      if (isPush && pushOffset && !hasPreviousPushPopup) {
        popup.$htmlEl.removeClass("with-modal-popup-push-closing");
        popup.$htmlEl[0].style.removeProperty("--f7-popup-push-scale");
      }
    });
    $el[0].f7Modal = popup;
    return popup;
  }
};
var popup_class_default = Popup;

// node_modules/framework7/components/popup/popup.js
var popup_default = {
  name: "popup",
  params: {
    popup: {
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeOnEscape: false,
      swipeToClose: false,
      swipeHandler: null,
      push: false,
      containerEl: null
    }
  },
  static: {
    Popup: popup_class_default
  },
  create() {
    const app = this;
    app.popup = ModalMethods({
      app,
      constructor: popup_class_default,
      defaultSelector: ".popup.modal-in",
      parentSelector: ".popup"
    });
  },
  clicks: {
    ".popup-open": function openPopup($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popup.open(data.popup, data.animate, $clickedEl);
    },
    ".popup-close": function closePopup($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popup.close(data.popup, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/login-screen/login-screen-class.js
var LoginScreen = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, params);
    super(app, extendedParams);
    const loginScreen = this;
    loginScreen.params = extendedParams;
    let $el;
    if (!loginScreen.params.el) {
      $el = dom7_default(loginScreen.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(loginScreen.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return loginScreen.destroy();
    }
    extend(loginScreen, {
      app,
      $el,
      el: $el[0],
      type: "loginScreen"
    });
    $el[0].f7Modal = loginScreen;
    return loginScreen;
  }
};
var login_screen_class_default = LoginScreen;

// node_modules/framework7/components/login-screen/login-screen.js
var login_screen_default = {
  name: "loginScreen",
  static: {
    LoginScreen: login_screen_class_default
  },
  create() {
    const app = this;
    app.loginScreen = ModalMethods({
      app,
      constructor: login_screen_class_default,
      defaultSelector: ".login-screen.modal-in"
    });
  },
  clicks: {
    ".login-screen-open": function openLoginScreen($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.loginScreen.open(data.loginScreen, data.animate, $clickedEl);
    },
    ".login-screen-close": function closeLoginScreen($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.loginScreen.close(data.loginScreen, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/popover/popover-class.js
var Popover = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.popover, params);
    super(app, extendedParams);
    const popover = this;
    const device = getDevice();
    const window2 = getWindow();
    const document = getDocument();
    popover.params = extendedParams;
    let $el;
    if (!popover.params.el) {
      $el = dom7_default(popover.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(popover.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    const $targetEl = dom7_default(popover.params.targetEl).eq(0);
    if ($el.length === 0) {
      return popover.destroy();
    }
    let $backdropEl;
    const forceBackdropUnique = popover.params.backdrop && app.$el.find(".popover.modal-in").filter((anotherPopoverEl) => anotherPopoverEl !== $el[0]).length > 0;
    if (popover.params.backdrop && popover.params.backdropEl) {
      $backdropEl = dom7_default(popover.params.backdropEl);
    } else if (popover.params.backdrop) {
      if (popover.params.backdropUnique || forceBackdropUnique) {
        $backdropEl = dom7_default('<div class="popover-backdrop popover-backdrop-unique"></div>');
        $backdropEl[0].f7PopoverRef = popover;
        popover.$containerEl.append($backdropEl);
      } else {
        $backdropEl = popover.$containerEl.children(".popover-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="popover-backdrop"></div>');
        popover.$containerEl.append($backdropEl);
      }
    }
    let $angleEl;
    if ($el.find(".popover-angle").length === 0) {
      $angleEl = dom7_default('<div class="popover-angle"></div>');
      $el.prepend($angleEl);
    } else {
      $angleEl = $el.find(".popover-angle");
    }
    const originalOpen = popover.open;
    extend(popover, {
      app,
      $el,
      el: $el[0],
      $targetEl,
      targetEl: $targetEl[0],
      $angleEl,
      angleEl: $angleEl[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "popover",
      forceBackdropUnique,
      open() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        let [targetEl, animate] = args;
        if (typeof args[0] === "boolean")
          [animate, targetEl] = args;
        if (targetEl) {
          popover.$targetEl = dom7_default(targetEl);
          popover.targetEl = popover.$targetEl[0];
        }
        return originalOpen.call(popover, animate);
      }
    });
    function handleResize() {
      popover.resize();
    }
    popover.on("popoverOpen", () => {
      popover.resize();
      app.on("resize", handleResize);
      dom7_default(window2).on("keyboardDidShow keyboardDidHide", handleResize);
      popover.on("popoverClose popoverBeforeDestroy", () => {
        app.off("resize", handleResize);
        dom7_default(window2).off("keyboardDidShow keyboardDidHide", handleResize);
      });
    });
    let touchStartTarget = null;
    function handleTouchStart(e) {
      touchStartTarget = e.target;
    }
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window2.Keyboard && window2.Keyboard.isVisible || window2.cordova.plugins && window2.cordova.plugins.Keyboard && window2.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(popover.el).length === 0) {
        if (popover.params.closeByBackdropClick && popover.params.backdrop && popover.backdropEl && popover.backdropEl === target && touchStartTarget === target) {
          popover.close();
        } else if (popover.params.closeByOutsideClick && touchStartTarget === target) {
          const isAnotherPopoverBackdrop = $target.hasClass("popover-backdrop-unique") && target.f7PopoverRef !== popover || $target.hasClass("popover-backdrop") && target !== popover.backdropEl;
          const isAnotherPopoverTarget = target.closest(".popover") && target.closest(".popover") !== popover.$el[0];
          if (!isAnotherPopoverBackdrop && !isAnotherPopoverTarget) {
            popover.close();
          }
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && popover.params.closeOnEscape) {
        popover.close();
      }
    }
    if (popover.params.closeOnEscape) {
      popover.on("popoverOpen", () => {
        dom7_default(document).on("keydown", onKeyDown);
      });
      popover.on("popoverClose", () => {
        dom7_default(document).off("keydown", onKeyDown);
      });
    }
    popover.on("popoverOpened", () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.on("touchstart", handleTouchStart);
        app.on("click", handleClick);
      }
    });
    popover.on("popoverClose", () => {
      if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
        app.off("touchstart", handleTouchStart);
        app.off("click", handleClick);
      }
    });
    $el[0].f7Modal = popover;
    return popover;
  }
  resize() {
    const popover = this;
    const {
      app,
      $el,
      $targetEl,
      $angleEl
    } = popover;
    const {
      targetX,
      targetY,
      verticalPosition
    } = popover.params;
    $el.css({
      left: "",
      top: ""
    });
    const [width, height] = [$el.width(), $el.height()];
    let angleSize = 0;
    let angleLeft;
    let angleTop;
    if (app.theme === "ios" || app.theme === "aurora") {
      $angleEl.removeClass("on-left on-right on-top on-bottom").css({
        left: "",
        top: ""
      });
      angleSize = $angleEl.width() / 2;
    } else {
      $el.removeClass("popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle").css({
        left: "",
        top: ""
      });
    }
    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    let safeAreaTop = parseInt(dom7_default("html").css("--f7-safe-area-top"), 10);
    let safeAreaLeft = parseInt(dom7_default("html").css("--f7-safe-area-left"), 10);
    let safeAreaRight = parseInt(dom7_default("html").css("--f7-safe-area-right"), 10);
    if (Number.isNaN(safeAreaTop))
      safeAreaTop = 0;
    if (Number.isNaN(safeAreaLeft))
      safeAreaLeft = 0;
    if (Number.isNaN(safeAreaRight))
      safeAreaRight = 0;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - app.left;
      targetOffsetTop = targetOffset.top - app.top;
      const targetParentPage = $targetEl.parents(".page");
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    } else if (typeof targetX !== "undefined" && targetY !== "undefined") {
      targetOffsetLeft = targetX;
      targetOffsetTop = targetY;
      targetWidth = popover.params.targetWidth || 0;
      targetHeight = popover.params.targetHeight || 0;
    }
    let [left, top, diff] = [0, 0, 0];
    const forcedPosition = verticalPosition === "auto" ? false : verticalPosition;
    let position = forcedPosition || (app.theme === "md" ? "bottom" : "top");
    if (app.theme === "md") {
      if (forcedPosition === "bottom" || !forcedPosition && height < app.height - targetOffsetTop - targetHeight) {
        position = "bottom";
        top = targetOffsetTop + targetHeight;
      } else if (forcedPosition === "top" || !forcedPosition && height < targetOffsetTop - safeAreaTop) {
        top = targetOffsetTop - height;
        position = "top";
      } else {
        position = "middle";
        top = targetHeight / 2 + targetOffsetTop - height / 2;
      }
      top = Math.max(8, Math.min(top, app.height - height - 8));
      let hPosition;
      if (targetOffsetLeft < app.width / 2) {
        hPosition = "right";
        left = position === "middle" ? targetOffsetLeft + targetWidth : targetOffsetLeft;
      } else {
        hPosition = "left";
        left = position === "middle" ? targetOffsetLeft - width : targetOffsetLeft + targetWidth - width;
      }
      left = Math.max(8, Math.min(left, app.width - width - 8 - safeAreaRight), safeAreaLeft);
      $el.addClass(`popover-on-${position} popover-on-${hPosition}`);
    } else {
      if (forcedPosition === "top" || !forcedPosition && height + angleSize < targetOffsetTop - safeAreaTop) {
        top = targetOffsetTop - height - angleSize;
      } else if (forcedPosition === "bottom" || !forcedPosition && height + angleSize < app.height - targetOffsetTop - targetHeight) {
        position = "bottom";
        top = targetOffsetTop + targetHeight + angleSize;
      } else {
        position = "middle";
        top = targetHeight / 2 + targetOffsetTop - height / 2;
        diff = top;
        top = Math.max(5, Math.min(top, app.height - height - 5));
        diff -= top;
      }
      if (position === "top" || position === "bottom") {
        left = targetWidth / 2 + targetOffsetLeft - width / 2;
        diff = left;
        left = Math.max(5, Math.min(left, app.width - width - 5));
        if (safeAreaLeft) {
          left = Math.max(left, safeAreaLeft);
        }
        if (safeAreaRight && left + width > app.width - 5 - safeAreaRight) {
          left = app.width - 5 - safeAreaRight - width;
        }
        if (position === "top") {
          $angleEl.addClass("on-bottom");
        }
        if (position === "bottom") {
          $angleEl.addClass("on-top");
        }
        diff -= left;
        angleLeft = width / 2 - angleSize + diff;
        angleLeft = Math.max(Math.min(angleLeft, width - angleSize * 2 - 13), 13);
        $angleEl.css({
          left: `${angleLeft}px`
        });
      } else if (position === "middle") {
        left = targetOffsetLeft - width - angleSize;
        $angleEl.addClass("on-right");
        if (left < 5 || left + width + safeAreaRight > app.width || left < safeAreaLeft) {
          if (left < 5)
            left = targetOffsetLeft + targetWidth + angleSize;
          if (left + width + safeAreaRight > app.width)
            left = app.width - width - 5 - safeAreaRight;
          if (left < safeAreaLeft)
            left = safeAreaLeft;
          $angleEl.removeClass("on-right").addClass("on-left");
        }
        angleTop = height / 2 - angleSize + diff;
        angleTop = Math.max(Math.min(angleTop, height - angleSize * 2 - 13), 13);
        $angleEl.css({
          top: `${angleTop}px`
        });
      }
    }
    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }
};
var popover_class_default = Popover;

// node_modules/framework7/components/popover/popover.js
var popover_default = {
  name: "popover",
  params: {
    popover: {
      verticalPosition: "auto",
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: true,
      closeOnEscape: false,
      containerEl: null
    }
  },
  static: {
    Popover: popover_class_default
  },
  create() {
    const app = this;
    app.popover = extend(ModalMethods({
      app,
      constructor: popover_class_default,
      defaultSelector: ".popover.modal-in"
    }), {
      open(popoverEl, targetEl, animate) {
        let $popoverEl = dom7_default(popoverEl);
        if ($popoverEl.length > 1) {
          const $targetPage = dom7_default(targetEl).parents(".page");
          if ($targetPage.length) {
            $popoverEl.each((el) => {
              const $el = dom7_default(el);
              if ($el.parents($targetPage)[0] === $targetPage[0]) {
                $popoverEl = $el;
              }
            });
          }
        }
        if ($popoverEl.length > 1) {
          $popoverEl = $popoverEl.eq($popoverEl.length - 1);
        }
        let popover = $popoverEl[0].f7Modal;
        const data = $popoverEl.dataset();
        if (!popover) {
          popover = new popover_class_default(app, Object.assign({
            el: $popoverEl,
            targetEl
          }, data));
        }
        return popover.open(targetEl, animate);
      }
    });
  },
  clicks: {
    ".popover-open": function openPopover($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popover.open(data.popover, $clickedEl, data.animate);
    },
    ".popover-close": function closePopover($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.popover.close(data.popover, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/actions/actions-class.js
var Actions = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.actions, params);
    super(app, extendedParams);
    const actions = this;
    const device = getDevice();
    const window2 = getWindow();
    const document = getDocument();
    actions.params = extendedParams;
    let groups;
    if (actions.params.buttons) {
      groups = actions.params.buttons;
      if (!Array.isArray(groups[0]))
        groups = [groups];
    }
    actions.groups = groups;
    let $el;
    if (actions.params.el) {
      $el = dom7_default(actions.params.el).eq(0);
    } else if (actions.params.content) {
      $el = dom7_default(actions.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else if (actions.params.buttons) {
      if (actions.params.convertToPopover) {
        actions.popoverHtml = actions.renderPopover();
      }
      actions.actionsHtml = actions.render();
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
      return actions.destroy();
    }
    let $backdropEl;
    if (actions.params.backdrop && actions.params.backdropEl) {
      $backdropEl = dom7_default(actions.params.backdropEl);
    } else if (actions.params.backdrop) {
      if (actions.params.backdropUnique) {
        $backdropEl = dom7_default('<div class="popup-backdrop popup-backdrop-unique"></div>');
        actions.$containerEl.append($backdropEl);
      } else {
        $backdropEl = actions.$containerEl.children(".actions-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="actions-backdrop"></div>');
        actions.$containerEl.append($backdropEl);
      }
    }
    const originalOpen = actions.open;
    const originalClose = actions.close;
    let popover;
    function buttonOnClick(e) {
      const $buttonEl = dom7_default(this);
      let buttonIndex;
      let groupIndex;
      if ($buttonEl.hasClass("list-button") || $buttonEl.hasClass("item-link")) {
        buttonIndex = $buttonEl.parents("li").index();
        groupIndex = $buttonEl.parents(".list").index();
      } else {
        buttonIndex = $buttonEl.index();
        groupIndex = $buttonEl.parents(".actions-group").index();
      }
      if (typeof groups !== "undefined") {
        const button = groups[groupIndex][buttonIndex];
        if (button.onClick)
          button.onClick(actions, e);
        if (actions.params.onClick)
          actions.params.onClick(actions, e);
        if (button.close !== false)
          actions.close();
      }
    }
    actions.open = function open6(animate) {
      let convertToPopover = false;
      const {
        targetEl,
        targetX,
        targetY,
        targetWidth,
        targetHeight
      } = actions.params;
      if (actions.params.convertToPopover && (targetEl || targetX !== void 0 && targetY !== void 0)) {
        if (actions.params.forceToPopover || device.ios && device.ipad || app.width >= 768 || device.desktop && app.theme === "aurora") {
          convertToPopover = true;
        }
      }
      if (convertToPopover && actions.popoverHtml) {
        popover = app.popover.create({
          containerEl: actions.params.containerEl,
          content: actions.popoverHtml,
          backdrop: actions.params.backdrop,
          targetEl,
          targetX,
          targetY,
          targetWidth,
          targetHeight,
          on: {
            open() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:open ${actions.type.toLowerCase()}:open`);
              actions.emit(`local::open modalOpen ${actions.type}Open`, actions);
            },
            opened() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:opened ${actions.type.toLowerCase()}:opened`);
              actions.emit(`local::opened modalOpened ${actions.type}Opened`, actions);
            },
            close() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:close ${actions.type.toLowerCase()}:close`);
              actions.emit(`local::close modalClose ${actions.type}Close`, actions);
            },
            closed() {
              if (!actions.$el) {
                actions.$el = popover.$el;
              }
              actions.$el.trigger(`modal:closed ${actions.type.toLowerCase()}:closed`);
              actions.emit(`local::closed modalClosed ${actions.type}Closed`, actions);
            }
          }
        });
        popover.open(animate);
        popover.once("popoverOpened", () => {
          popover.$el.find(".list-button, .item-link").each((buttonEl) => {
            dom7_default(buttonEl).on("click", buttonOnClick);
          });
        });
        popover.once("popoverClosed", () => {
          popover.$el.find(".list-button, .item-link").each((buttonEl) => {
            dom7_default(buttonEl).off("click", buttonOnClick);
          });
          nextTick(() => {
            popover.destroy();
            popover = void 0;
          });
        });
      } else {
        actions.$el = actions.actionsHtml ? dom7_default(actions.actionsHtml) : actions.$el;
        actions.$el[0].f7Modal = actions;
        if (actions.groups) {
          actions.$el.find(".actions-button").each((buttonEl) => {
            dom7_default(buttonEl).on("click", buttonOnClick);
          });
          actions.once("actionsClosed", () => {
            actions.$el.find(".actions-button").each((buttonEl) => {
              dom7_default(buttonEl).off("click", buttonOnClick);
            });
          });
        }
        actions.el = actions.$el[0];
        originalOpen.call(actions, animate);
      }
      return actions;
    };
    actions.close = function close6(animate) {
      if (popover) {
        popover.close(animate);
      } else {
        originalClose.call(actions, animate);
      }
      return actions;
    };
    extend(actions, {
      app,
      $el,
      el: $el ? $el[0] : void 0,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "actions"
    });
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window2.Keyboard && window2.Keyboard.isVisible || window2.cordova.plugins && window2.cordova.plugins.Keyboard && window2.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(actions.el).length === 0) {
        if (actions.params.closeByBackdropClick && actions.params.backdrop && actions.backdropEl && actions.backdropEl === target) {
          actions.close();
        } else if (actions.params.closeByOutsideClick) {
          actions.close();
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && actions.params.closeOnEscape) {
        actions.close();
      }
    }
    if (actions.params.closeOnEscape) {
      actions.on("open", () => {
        dom7_default(document).on("keydown", onKeyDown);
      });
      actions.on("close", () => {
        dom7_default(document).off("keydown", onKeyDown);
      });
    }
    actions.on("opened", () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.on("click", handleClick);
      }
    });
    actions.on("close", () => {
      if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
        app.off("click", handleClick);
      }
    });
    if ($el) {
      $el[0].f7Modal = actions;
    }
    return actions;
  }
  render() {
    const actions = this;
    if (actions.params.render)
      return actions.params.render.call(actions, actions);
    const {
      groups
    } = actions;
    const cssClass = actions.params.cssClass;
    return jsx_default2("div", {
      class: `actions-modal${actions.params.grid ? " actions-grid" : ""} ${cssClass || ""}`
    }, groups.map((group) => jsx_default2("div", {
      class: "actions-group"
    }, group.map((button) => {
      const buttonClasses = [`actions-${button.label ? "label" : "button"}`];
      const {
        color,
        bg,
        bold,
        disabled,
        label,
        text: text2,
        icon
      } = button;
      if (color)
        buttonClasses.push(`color-${color}`);
      if (bg)
        buttonClasses.push(`bg-color-${bg}`);
      if (bold)
        buttonClasses.push("actions-button-bold");
      if (disabled)
        buttonClasses.push("disabled");
      if (label) {
        return jsx_default2("div", {
          class: buttonClasses.join(" ")
        }, text2);
      }
      return jsx_default2("div", {
        class: buttonClasses.join(" ")
      }, icon && jsx_default2("div", {
        class: "actions-button-media"
      }, icon), jsx_default2("div", {
        class: "actions-button-text"
      }, text2));
    }))));
  }
  renderPopover() {
    const actions = this;
    if (actions.params.renderPopover)
      return actions.params.renderPopover.call(actions, actions);
    const {
      groups
    } = actions;
    const cssClass = actions.params.cssClass;
    return jsx_default2("div", {
      class: `popover popover-from-actions ${cssClass || ""}`
    }, jsx_default2("div", {
      class: "popover-inner"
    }, groups.map((group) => jsx_default2("div", {
      class: "list"
    }, jsx_default2("ul", null, group.map((button) => {
      const itemClasses = [];
      const {
        color,
        bg,
        bold,
        disabled,
        label,
        text: text2,
        icon
      } = button;
      if (color)
        itemClasses.push(`color-${color}`);
      if (bg)
        itemClasses.push(`bg-color-${bg}`);
      if (bold)
        itemClasses.push("popover-from-actions-bold");
      if (disabled)
        itemClasses.push("disabled");
      if (label) {
        itemClasses.push("popover-from-actions-label");
        return `<li class="${itemClasses.join(" ")}">${text2}</li>`;
      }
      if (icon) {
        itemClasses.push("item-link item-content");
        return jsx_default2("li", null, jsx_default2("a", {
          class: itemClasses.join(" ")
        }, jsx_default2("div", {
          class: "item-media"
        }, icon), jsx_default2("div", {
          class: "item-inner"
        }, jsx_default2("div", {
          class: "item-title"
        }, text2))));
      }
      itemClasses.push("list-button");
      return jsx_default2("li", null, jsx_default2("a", {
        class: itemClasses.join(" ")
      }, text2));
    }))))));
  }
};
var actions_class_default = Actions;

// node_modules/framework7/components/actions/actions.js
var actions_default = {
  name: "actions",
  params: {
    actions: {
      convertToPopover: true,
      forceToPopover: false,
      backdrop: true,
      backdropEl: void 0,
      backdropUnique: false,
      cssClass: null,
      closeByBackdropClick: true,
      closeOnEscape: false,
      render: null,
      renderPopover: null,
      containerEl: null
    }
  },
  static: {
    Actions: actions_class_default
  },
  create() {
    const app = this;
    app.actions = ModalMethods({
      app,
      constructor: actions_class_default,
      defaultSelector: ".actions-modal.modal-in"
    });
  },
  clicks: {
    ".actions-open": function openActions($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.actions.open(data.actions, data.animate, $clickedEl);
    },
    ".actions-close": function closeActions($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.actions.close(data.actions, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/sheet/sheet-class.js
var Sheet = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.sheet, params);
    super(app, extendedParams);
    const sheet = this;
    const window2 = getWindow();
    const document = getDocument();
    const support2 = getSupport();
    const device = getDevice();
    sheet.params = extendedParams;
    if (typeof sheet.params.backdrop === "undefined") {
      sheet.params.backdrop = app.theme !== "ios";
    }
    let $el;
    if (!sheet.params.el) {
      $el = dom7_default(sheet.params.content).filter((node) => node.nodeType === 1).eq(0);
    } else {
      $el = dom7_default(sheet.params.el).eq(0);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return sheet.destroy();
    }
    let $backdropEl;
    if (sheet.params.backdrop && sheet.params.backdropEl) {
      $backdropEl = dom7_default(sheet.params.backdropEl);
    } else if (sheet.params.backdrop) {
      if (sheet.params.backdropUnique) {
        $backdropEl = dom7_default('<div class="sheet-backdrop sheet-backdrop-unique"></div>');
        sheet.$containerEl.append($backdropEl);
      } else {
        $backdropEl = sheet.$containerEl.children(".sheet-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="sheet-backdrop"></div>');
        sheet.$containerEl.append($backdropEl);
      }
    }
    extend(sheet, {
      app,
      push: $el.hasClass("sheet-modal-push") || sheet.params.push,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "sheet",
      $htmlEl: dom7_default("html")
    });
    if (sheet.params.push) {
      $el.addClass("sheet-modal-push");
    }
    let $pageContentEl;
    function scrollToElementOnOpen() {
      const $scrollEl = dom7_default(sheet.params.scrollToEl).eq(0);
      if ($scrollEl.length === 0)
        return;
      $pageContentEl = $scrollEl.parents(".page-content");
      if ($pageContentEl.length === 0)
        return;
      const paddingTop = parseInt($pageContentEl.css("padding-top"), 10);
      const paddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
      const pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
      const pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
      const pageScroll = $pageContentEl.scrollTop();
      let newPaddingBottom;
      const scrollElTop = $scrollEl.offset().top - paddingTop + $scrollEl[0].offsetHeight;
      if (scrollElTop > pageHeight) {
        const scrollTop = pageScroll + scrollElTop - pageHeight;
        if (scrollTop + pageHeight > pageScrollHeight) {
          newPaddingBottom = scrollTop + pageHeight - pageScrollHeight + paddingBottom;
          if (pageHeight === pageScrollHeight) {
            newPaddingBottom = $el.height();
          }
          $pageContentEl.css({
            "padding-bottom": `${newPaddingBottom}px`
          });
        }
        $pageContentEl.scrollTop(scrollTop, 300);
      }
    }
    function scrollToElementOnClose() {
      if ($pageContentEl && $pageContentEl.length > 0) {
        $pageContentEl.css({
          "padding-bottom": ""
        });
      }
    }
    function handleClick(e) {
      const target = e.target;
      const $target = dom7_default(target);
      const keyboardOpened = !device.desktop && device.cordova && (window2.Keyboard && window2.Keyboard.isVisible || window2.cordova.plugins && window2.cordova.plugins.Keyboard && window2.cordova.plugins.Keyboard.isVisible);
      if (keyboardOpened)
        return;
      if ($target.closest(sheet.el).length === 0) {
        if (sheet.params.closeByBackdropClick && sheet.params.backdrop && sheet.backdropEl && sheet.backdropEl === target) {
          sheet.close();
        } else if (sheet.params.closeByOutsideClick) {
          sheet.close();
        }
      }
    }
    function onKeyDown(e) {
      const keyCode = e.keyCode;
      if (keyCode === 27 && sheet.params.closeOnEscape) {
        sheet.close();
      }
    }
    let pushOffset;
    function pushViewScale(offset2) {
      return (app.height - offset2 * 2) / app.height;
    }
    let isTouched = false;
    let startTouch;
    let currentTouch;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let isMoved = false;
    let isTopSheetModal;
    let swipeStepTranslate;
    let startTranslate;
    let currentTranslate;
    let sheetElOffsetHeight;
    let minTranslate2;
    let maxTranslate2;
    let $pushViewEl;
    let pushBorderRadius;
    let sheetPageContentEl;
    let sheetPageContentScrollTop;
    let sheetPageContentScrollHeight;
    let sheetPageContentOffsetHeight;
    function handleTouchStart(e) {
      if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep))
        return;
      if (sheet.params.swipeHandler && dom7_default(e.target).closest(sheet.params.swipeHandler).length === 0) {
        return;
      }
      isTouched = true;
      isMoved = false;
      startTouch = {
        x: e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY
      };
      touchStartTime = now();
      isScrolling = void 0;
      isTopSheetModal = $el.hasClass("sheet-modal-top");
      if (!sheet.params.swipeHandler && e.type === "touchstart") {
        sheetPageContentEl = dom7_default(e.target).closest(".page-content")[0];
      }
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      currentTouch = {
        x: e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX,
        y: e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY
      };
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      touchesDiff = startTouch.y - currentTouch.y;
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      if (!isMoved) {
        if (sheetPageContentEl && !$el.hasClass("modal-in-swipe-step")) {
          sheetPageContentScrollTop = sheetPageContentEl.scrollTop;
          sheetPageContentScrollHeight = sheetPageContentEl.scrollHeight;
          sheetPageContentOffsetHeight = sheetPageContentEl.offsetHeight;
          if (!(sheetPageContentScrollHeight === sheetPageContentOffsetHeight) && !(direction === "to-bottom" && sheetPageContentScrollTop === 0) && !(direction === "to-top" && sheetPageContentScrollTop === sheetPageContentScrollHeight - sheetPageContentOffsetHeight)) {
            $el.transform("");
            isTouched = false;
            isMoved = false;
            return;
          }
        }
        if (sheet.push && pushOffset) {
          $pushViewEl = app.$el.children(".view, .views");
        }
        sheetElOffsetHeight = $el[0].offsetHeight;
        startTranslate = getTranslate($el[0], "y");
        if (isTopSheetModal) {
          minTranslate2 = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
          maxTranslate2 = 0;
        } else {
          minTranslate2 = 0;
          maxTranslate2 = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
        }
        isMoved = true;
      }
      currentTranslate = startTranslate - touchesDiff;
      currentTranslate = Math.min(Math.max(currentTranslate, minTranslate2), maxTranslate2);
      e.preventDefault();
      if (sheet.push && pushOffset) {
        let progress = (currentTranslate - startTranslate) / sheetElOffsetHeight;
        if (sheet.params.swipeToStep) {
          if (isTopSheetModal) {
            progress = currentTranslate / swipeStepTranslate;
          } else {
            progress = 1 - (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
          }
        }
        progress = Math.abs(progress);
        progress = Math.min(Math.max(progress, 0), 1);
        const pushProgress = 1 - progress;
        const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
        $pushViewEl.transition(0).forEach((el) => {
          el.style.setProperty("transform", `translate3d(0,0,0) scale(${scale})`, "important");
        });
        if (sheet.params.swipeToStep) {
          $pushViewEl.css("border-radius", `${pushBorderRadius * pushProgress}px`);
        }
      }
      $el.transition(0).transform(`translate3d(0,${currentTranslate}px,0)`);
      if (sheet.params.swipeToStep) {
        let progress;
        if (isTopSheetModal) {
          progress = 1 - currentTranslate / swipeStepTranslate;
        } else {
          progress = (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
        }
        progress = Math.min(Math.max(progress, 0), 1);
        $el.trigger("sheet:stepprogress", progress);
        sheet.emit("local::stepProgress sheetStepProgress", sheet, progress);
      }
    }
    function handleTouchEnd() {
      isTouched = false;
      if (!isMoved) {
        return;
      }
      isMoved = false;
      $el.transform("").transition("");
      if (sheet.push && pushOffset) {
        $pushViewEl.transition("").transform("");
        $pushViewEl.css("border-radius", "");
      }
      const direction = touchesDiff < 0 ? "to-bottom" : "to-top";
      const diff = Math.abs(touchesDiff);
      if (diff === 0 || currentTranslate === startTranslate)
        return;
      const timeDiff = new Date().getTime() - touchStartTime;
      if (!sheet.params.swipeToStep) {
        if (direction !== (isTopSheetModal ? "to-top" : "to-bottom")) {
          return;
        }
        if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > sheetElOffsetHeight / 2) {
          sheet.close();
        }
        return;
      }
      const openDirection = isTopSheetModal ? "to-bottom" : "to-top";
      const closeDirection = isTopSheetModal ? "to-top" : "to-bottom";
      const absCurrentTranslate = Math.abs(currentTranslate);
      const absSwipeStepTranslate = Math.abs(swipeStepTranslate);
      if (timeDiff < 300 && diff > 10) {
        if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
          $el.removeClass("modal-in-swipe-step");
          $el.trigger("sheet:stepprogress", 1);
          sheet.emit("local::stepProgress sheetStepProgress", sheet, 1);
          sheet.emit("local::_swipeStep", false);
          $el.trigger("sheet:stepopen");
          sheet.emit("local::stepOpen sheetStepOpen", sheet);
          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
            $pushViewEl.css("border-radius", "");
          }
        }
        if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
          if (sheet.params.swipeToClose) {
            sheet.close();
          } else {
            $el.addClass("modal-in-swipe-step");
            $el.trigger("sheet:stepprogress", 0);
            sheet.emit("local::stepProgress sheetStepProgress", sheet, 0);
            sheet.emit("local::_swipeStep", true);
            $el.trigger("sheet:stepclose");
            sheet.emit("local::stepClose sheetStepClose", sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
              $pushViewEl.css("border-radius", "0px");
            }
          }
        }
        if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
          $el.addClass("modal-in-swipe-step");
          $el.trigger("sheet:stepprogress", 0);
          sheet.emit("local::stepProgress sheetStepProgress", sheet, 0);
          sheet.emit("local::_swipeStep", true);
          $el.trigger("sheet:stepclose");
          sheet.emit("local::stepClose sheetStepClose", sheet);
          if (sheet.push && pushOffset) {
            sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
            $pushViewEl.css("border-radius", "0px");
          }
        }
        return;
      }
      if (timeDiff >= 300) {
        const stepOpened = !$el.hasClass("modal-in-swipe-step");
        if (!stepOpened) {
          if (absCurrentTranslate < absSwipeStepTranslate / 2) {
            $el.removeClass("modal-in-swipe-step");
            $el.trigger("sheet:stepprogress", 1);
            sheet.emit("local::stepProgress sheetStepProgress", sheet, 1);
            sheet.emit("local::_swipeStep", false);
            $el.trigger("sheet:stepopen");
            sheet.emit("local::stepOpen sheetStepOpen", sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
              $pushViewEl.css("border-radius", "");
            }
          } else if (absCurrentTranslate - absSwipeStepTranslate > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            if (sheet.params.swipeToClose)
              sheet.close();
          }
        } else if (stepOpened) {
          if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
            if (sheet.params.swipeToClose)
              sheet.close();
          } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
            $el.addClass("modal-in-swipe-step");
            $el.trigger("sheet:stepprogress", 0);
            sheet.emit("local::stepProgress sheetStepProgress", sheet, 0);
            sheet.emit("local::_swipeStep", true);
            $el.trigger("sheet:stepclose");
            sheet.emit("local::stepClose sheetStepClose", sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
              $pushViewEl.css("border-radius", "0px");
            }
          }
        }
      }
    }
    sheet.setSwipeStep = function setSwipeStep(byResize) {
      if (byResize === void 0) {
        byResize = true;
      }
      const $swipeStepEl = $el.find(".sheet-modal-swipe-step").eq(0);
      if (!$swipeStepEl.length)
        return;
      if ($el.hasClass("sheet-modal-top")) {
        swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      } else {
        swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
      }
      $el[0].style.setProperty("--f7-sheet-swipe-step", `${swipeStepTranslate}px`);
      if (!byResize) {
        $el.addClass("modal-in-swipe-step");
        sheet.emit("local::_swipeStep", true);
      }
    };
    function onResize2() {
      sheet.setSwipeStep(true);
    }
    const passive = support2.passiveListener ? {
      passive: true
    } : false;
    if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      sheet.once("sheetDestroy", () => {
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off("touchmove", handleTouchMove);
        app.off("touchend:passive", handleTouchEnd);
      });
    }
    sheet.on("open", () => {
      if (sheet.params.closeOnEscape) {
        dom7_default(document).on("keydown", onKeyDown);
      }
      $el.prevAll(".popup.modal-in").addClass("popup-behind");
      if (sheet.params.swipeToStep) {
        sheet.setSwipeStep(false);
        app.on("resize", onResize2);
      }
      if (sheet.params.scrollToEl) {
        scrollToElementOnOpen();
      }
      if (sheet.push) {
        pushOffset = parseInt($el.css("--f7-sheet-push-offset"), 10);
        if (Number.isNaN(pushOffset))
          pushOffset = 0;
        if (pushOffset) {
          $el.addClass("sheet-modal-push");
          sheet.$htmlEl.addClass("with-modal-sheet-push");
          if (!sheet.params.swipeToStep) {
            sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
          } else {
            $pushViewEl = app.$el.children(".view, .views");
            pushBorderRadius = parseFloat($el.css(`border-${isTopSheetModal ? "bottom" : "top"}-left-radius`));
            $pushViewEl.css("border-radius", "0px");
          }
        }
      }
    });
    sheet.on("opened", () => {
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.on("click", handleClick);
      }
    });
    sheet.on("close", () => {
      if (sheet.params.swipeToStep) {
        $el.removeClass("modal-in-swipe-step");
        sheet.emit("local::_swipeStep", false);
        app.off("resize", onResize2);
      }
      if (sheet.params.closeOnEscape) {
        dom7_default(document).off("keydown", onKeyDown);
      }
      if (sheet.params.scrollToEl) {
        scrollToElementOnClose();
      }
      if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
        app.off("click", handleClick);
      }
      $el.prevAll(".popup.modal-in").eq(0).removeClass("popup-behind");
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass("with-modal-sheet-push");
        sheet.$htmlEl.addClass("with-modal-sheet-push-closing");
      }
    });
    sheet.on("closed", () => {
      if (sheet.push && pushOffset) {
        sheet.$htmlEl.removeClass("with-modal-sheet-push-closing");
        sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
      }
    });
    sheet.stepOpen = function stepOpen() {
      $el.removeClass("modal-in-swipe-step");
      sheet.emit("local::_swipeStep", false);
      if (sheet.push) {
        if (!pushOffset) {
          pushOffset = parseInt($el.css("--f7-sheet-push-offset"), 10);
          if (Number.isNaN(pushOffset))
            pushOffset = 0;
        }
        if (pushOffset) {
          sheet.$htmlEl[0].style.setProperty("--f7-sheet-push-scale", pushViewScale(pushOffset));
        }
      }
    };
    sheet.stepClose = function stepClose() {
      $el.addClass("modal-in-swipe-step");
      sheet.emit("local::_swipeStep", true);
      if (sheet.push) {
        sheet.$htmlEl[0].style.removeProperty("--f7-sheet-push-scale");
      }
    };
    sheet.stepToggle = function stepToggle() {
      $el.toggleClass("modal-in-swipe-step");
      sheet.emit("local::_swipeStep", $el.hasClass("modal-in-swipe-step"));
    };
    $el[0].f7Modal = sheet;
    return sheet;
  }
};
var sheet_class_default = Sheet;

// node_modules/framework7/components/sheet/sheet.js
var sheet_default = {
  name: "sheet",
  params: {
    sheet: {
      push: false,
      backdrop: void 0,
      backdropEl: void 0,
      backdropUnique: false,
      closeByBackdropClick: true,
      closeByOutsideClick: false,
      closeOnEscape: false,
      swipeToClose: false,
      swipeToStep: false,
      swipeHandler: null,
      containerEl: null
    }
  },
  static: {
    Sheet: sheet_class_default
  },
  create() {
    const app = this;
    app.sheet = extend({}, ModalMethods({
      app,
      constructor: sheet_class_default,
      defaultSelector: ".sheet-modal.modal-in"
    }), {
      stepOpen(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepOpen)
          return sheetInstance.stepOpen();
        return void 0;
      },
      stepClose(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepClose)
          return sheetInstance.stepClose();
        return void 0;
      },
      stepToggle(sheet) {
        const sheetInstance = app.sheet.get(sheet);
        if (sheetInstance && sheetInstance.stepToggle)
          return sheetInstance.stepToggle();
        return void 0;
      }
    });
  },
  clicks: {
    ".sheet-open": function openSheet($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      if (dom7_default(".sheet-modal.modal-in").length > 0 && data.sheet && dom7_default(data.sheet)[0] !== dom7_default(".sheet-modal.modal-in")[0]) {
        app.sheet.close(".sheet-modal.modal-in");
      }
      app.sheet.open(data.sheet, data.animate, $clickedEl);
    },
    ".sheet-close": function closeSheet($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sheet.close(data.sheet, data.animate, $clickedEl);
    }
  }
};

// node_modules/framework7/components/toast/toast-class.js
var Toast = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.toast, params);
    super(app, extendedParams);
    const toast = this;
    const window2 = getWindow();
    toast.app = app;
    toast.params = extendedParams;
    const {
      closeButton,
      closeTimeout
    } = toast.params;
    let $el;
    if (!toast.params.el) {
      const toastHtml = toast.render();
      $el = dom7_default(toastHtml);
    } else {
      $el = dom7_default(toast.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return toast.destroy();
    }
    extend(toast, {
      $el,
      el: $el[0],
      type: "toast"
    });
    $el[0].f7Modal = toast;
    if (closeButton) {
      $el.find(".toast-button").on("click", () => {
        toast.emit("local::closeButtonClick toastCloseButtonClick", toast);
        toast.close();
      });
      toast.on("beforeDestroy", () => {
        $el.find(".toast-button").off("click");
      });
    }
    let timeoutId;
    toast.on("open", () => {
      dom7_default(".toast.modal-in").each((openedEl) => {
        const toastInstance = app.toast.get(openedEl);
        if (openedEl !== toast.el && toastInstance) {
          toastInstance.close();
        }
      });
      if (closeTimeout) {
        timeoutId = nextTick(() => {
          toast.close();
        }, closeTimeout);
      }
    });
    toast.on("close", () => {
      window2.clearTimeout(timeoutId);
    });
    if (toast.params.destroyOnClose) {
      toast.once("closed", () => {
        setTimeout(() => {
          toast.destroy();
        }, 0);
      });
    }
    return toast;
  }
  render() {
    const toast = this;
    if (toast.params.render)
      return toast.params.render.call(toast, toast);
    const {
      position,
      horizontalPosition,
      cssClass,
      icon,
      text: text2,
      closeButton,
      closeButtonColor,
      closeButtonText
    } = toast.params;
    const horizontalClass = position === "top" || position === "bottom" ? `toast-horizontal-${horizontalPosition}` : "";
    return jsx_default2("div", {
      class: `toast toast-${position} ${horizontalClass} ${cssClass || ""} ${icon ? "toast-with-icon" : ""}`
    }, jsx_default2("div", {
      class: "toast-content"
    }, icon && jsx_default2("div", {
      class: "toast-icon"
    }, icon), jsx_default2("div", {
      class: "toast-text"
    }, text2), closeButton && !icon && jsx_default2("a", {
      class: `toast-button button ${closeButtonColor ? `color-${closeButtonColor}` : ""}`
    }, closeButtonText)));
  }
};
var toast_class_default = Toast;

// node_modules/framework7/components/toast/toast.js
var toast_default = {
  name: "toast",
  static: {
    Toast: toast_class_default
  },
  create() {
    const app = this;
    app.toast = extend({}, ModalMethods({
      app,
      constructor: toast_class_default,
      defaultSelector: ".toast.modal-in"
    }), {
      show(params) {
        extend(params, {
          destroyOnClose: true
        });
        return new toast_class_default(app, params).open();
      }
    });
  },
  params: {
    toast: {
      icon: null,
      text: null,
      position: "bottom",
      horizontalPosition: "left",
      closeButton: false,
      closeButtonColor: null,
      closeButtonText: "Ok",
      closeTimeout: null,
      cssClass: null,
      render: null,
      containerEl: null
    }
  }
};

// node_modules/framework7/components/preloader/preloader.js
var Preloader = {
  init(el) {
    const app = this;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    const $el = dom7_default(el);
    if ($el.length === 0 || $el.children(".preloader-inner").length > 0 || $el.children(".preloader-inner-line").length > 0)
      return;
    $el.append(preloaders[`${app.theme}PreloaderContent`]);
  },
  visible: false,
  show(color) {
    if (color === void 0) {
      color = "white";
    }
    const app = this;
    if (Preloader.visible)
      return;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || "";
    dom7_default("html").addClass("with-modal-preloader");
    app.$el.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
    Preloader.visible = true;
  },
  showIn(el, color) {
    if (color === void 0) {
      color = "white";
    }
    const app = this;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    const preloaderInner = preloaders[`${app.theme}PreloaderContent`] || "";
    dom7_default(el || "html").addClass("with-modal-preloader");
    dom7_default(el || app.$el).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
  },
  hide() {
    const app = this;
    if (!Preloader.visible)
      return;
    dom7_default("html").removeClass("with-modal-preloader");
    app.$el.find(".preloader-backdrop, .preloader-modal").remove();
    Preloader.visible = false;
  },
  hideIn(el) {
    const app = this;
    dom7_default(el || "html").removeClass("with-modal-preloader");
    dom7_default(el || app.$el).find(".preloader-backdrop, .preloader-modal").remove();
  }
};
var preloader_default = {
  name: "preloader",
  create() {
    const app = this;
    bindMethods(app, {
      preloader: Preloader
    });
  },
  on: {
    photoBrowserOpen(pb) {
      const app = this;
      pb.$el.find(".preloader").each((preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".preloader").each((preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".preloader").each((preloaderEl) => {
        app.preloader.init(preloaderEl);
      });
    }
  },
  vnode: {
    preloader: {
      insert(vnode) {
        const app = this;
        const preloaderEl = vnode.elm;
        app.preloader.init(preloaderEl);
      }
    }
  }
};

// node_modules/framework7/components/progressbar/progressbar.js
var Progressbar = {
  set() {
    const app = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    let [el, progress, duration] = args;
    if (typeof args[0] === "number") {
      [progress, duration] = args;
      el = app.$el;
    }
    if (typeof progress === "undefined" || progress === null)
      return el;
    if (!progress)
      progress = 0;
    const $el = dom7_default(el || app.$el);
    if ($el.length === 0) {
      return el;
    }
    const progressNormalized = Math.min(Math.max(progress, 0), 100);
    let $progressbarEl;
    if ($el.hasClass("progressbar"))
      $progressbarEl = $el.eq(0);
    else {
      $progressbarEl = $el.children(".progressbar");
    }
    if ($progressbarEl.length === 0 || $progressbarEl.hasClass("progressbar-infinite")) {
      return $progressbarEl;
    }
    let $progressbarLine = $progressbarEl.children("span");
    if ($progressbarLine.length === 0) {
      $progressbarLine = dom7_default("<span></span>");
      $progressbarEl.append($progressbarLine);
    }
    $progressbarLine.transition(typeof duration !== "undefined" ? duration : "").transform(`translate3d(${(-100 + progressNormalized) * (app.rtl ? -1 : 1)}%,0,0)`);
    return $progressbarEl[0];
  },
  show() {
    const app = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    let [el, progress, color] = args;
    let type = "determined";
    if (args.length === 2) {
      if ((typeof args[0] === "string" || typeof args[0] === "object") && typeof args[1] === "string") {
        [el, color, progress] = args;
        type = "infinite";
      } else if (typeof args[0] === "number" && typeof args[1] === "string") {
        [progress, color] = args;
        el = app.$el;
      }
    } else if (args.length === 1) {
      if (typeof args[0] === "number") {
        el = app.$el;
        progress = args[0];
      } else if (typeof args[0] === "string") {
        type = "infinite";
        el = app.$el;
        color = args[0];
      }
    } else if (args.length === 0) {
      type = "infinite";
      el = app.$el;
    }
    const $el = dom7_default(el);
    if ($el.length === 0)
      return void 0;
    let $progressbarEl;
    if ($el.hasClass("progressbar") || $el.hasClass("progressbar-infinite")) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children(".progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)");
      if ($progressbarEl.length === 0) {
        $progressbarEl = dom7_default(`
          <span class="progressbar${type === "infinite" ? "-infinite" : ""}${color ? ` color-${color}` : ""} progressbar-in">
            ${type === "infinite" ? "" : "<span></span>"}
          </span>`);
        $el.append($progressbarEl);
      }
    }
    if (typeof progress !== "undefined") {
      app.progressbar.set($progressbarEl, progress);
    }
    return $progressbarEl[0];
  },
  hide(el, removeAfterHide) {
    if (removeAfterHide === void 0) {
      removeAfterHide = true;
    }
    const app = this;
    const $el = dom7_default(el || app.$el);
    if ($el.length === 0)
      return void 0;
    let $progressbarEl;
    if ($el.hasClass("progressbar") || $el.hasClass("progressbar-infinite")) {
      $progressbarEl = $el;
    } else {
      $progressbarEl = $el.children(".progressbar, .progressbar-infinite");
    }
    if ($progressbarEl.length === 0 || !$progressbarEl.hasClass("progressbar-in") || $progressbarEl.hasClass("progressbar-out")) {
      return $progressbarEl;
    }
    $progressbarEl.removeClass("progressbar-in").addClass("progressbar-out").animationEnd(() => {
      if (removeAfterHide) {
        $progressbarEl.remove();
      }
    });
    return $progressbarEl;
  }
};
var progressbar_default = {
  name: "progressbar",
  create() {
    const app = this;
    bindMethods(app, {
      progressbar: Progressbar
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".progressbar").each((progressbarEl) => {
        const $progressbarEl = dom7_default(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr("data-progress"));
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".progressbar").each((progressbarEl) => {
        const $progressbarEl = dom7_default(progressbarEl);
        app.progressbar.set($progressbarEl, $progressbarEl.attr("data-progress"));
      });
    }
  },
  vnode: {
    progressbar: {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute("data-progress"));
      },
      update(vnode) {
        const app = this;
        const el = vnode.elm;
        app.progressbar.set(el, el.getAttribute("data-progress"));
      }
    }
  }
};

// node_modules/framework7/components/sortable/sortable.js
var Sortable = {
  init() {
    const app = this;
    const document = getDocument();
    let isTouched;
    let isMoved;
    let touchStartY;
    let touchesDiff;
    let $sortingEl;
    let $sortingItems;
    let $sortableContainer;
    let sortingElHeight;
    let minTop;
    let maxTop;
    let $insertAfterEl;
    let $insertBeforeEl;
    let indexFrom;
    let $pageEl;
    let $pageContentEl;
    let pageHeight;
    let pageOffset;
    let sortingElOffsetLocal;
    let sortingElOffsetTop;
    let initialScrollTop;
    let wasTapHold;
    function handleTouchStart(e, isTapHold) {
      isMoved = false;
      isTouched = true;
      wasTapHold = false;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      $sortingEl = dom7_default(e.target).closest("li").eq(0);
      indexFrom = $sortingEl.index();
      $sortableContainer = $sortingEl.parents(".sortable");
      const $listGroup = $sortingEl.parents(".list-group");
      if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
        $sortableContainer = $listGroup;
      }
      $sortingItems = $sortableContainer.children("ul").children("li:not(.disallow-sorting):not(.no-sorting)");
      if (app.panel)
        app.panel.allowOpen = false;
      if (app.swipeout)
        app.swipeout.allow = false;
      if (isTapHold) {
        $sortingEl.addClass("sorting");
        $sortableContainer.addClass("sortable-sorting");
        wasTapHold = true;
      }
    }
    function handleTouchMove(e) {
      if (!isTouched || !$sortingEl)
        return;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (!isMoved) {
        $pageEl = $sortingEl.parents(".page");
        $pageContentEl = $sortingEl.parents(".page-content");
        const paddingTop = parseInt($pageContentEl.css("padding-top"), 10);
        const paddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
        initialScrollTop = $pageContentEl[0].scrollTop;
        pageOffset = $pageEl.offset().top + paddingTop;
        pageHeight = $pageEl.height() - paddingTop - paddingBottom;
        $sortingEl.addClass("sorting");
        $sortableContainer.addClass("sortable-sorting");
        sortingElOffsetLocal = $sortingEl[0].offsetTop;
        minTop = $sortingEl[0].offsetTop;
        maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
        sortingElHeight = $sortingEl[0].offsetHeight;
        sortingElOffsetTop = $sortingEl.offset().top;
      }
      isMoved = true;
      e.preventDefault();
      e.f7PreventSwipePanel = true;
      touchesDiff = pageY - touchStartY;
      const translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
      const translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
      $sortingEl.transform(`translate3d(0,${translate}px,0)`);
      const scrollAddition = 44;
      let allowScroll = true;
      if (touchesDiff + translateScrollOffset + scrollAddition < -minTop) {
        allowScroll = false;
      }
      if (touchesDiff + translateScrollOffset - scrollAddition > maxTop) {
        allowScroll = false;
      }
      $insertBeforeEl = void 0;
      $insertAfterEl = void 0;
      let scrollDiff;
      if (allowScroll) {
        if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
          scrollDiff = sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition - (pageOffset + pageHeight);
        }
        if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
          scrollDiff = sortingElOffsetTop + touchesDiff - pageOffset - scrollAddition;
        }
        if (scrollDiff) {
          $pageContentEl[0].scrollTop += scrollDiff;
        }
      }
      $sortingItems.each((el) => {
        const $currentEl = dom7_default(el);
        if ($currentEl[0] === $sortingEl[0])
          return;
        const currentElOffset = $currentEl[0].offsetTop;
        const currentElHeight = $currentEl.height();
        const sortingElOffset = sortingElOffsetLocal + translate;
        let currentTranslate;
        const prevTranslate = $currentEl[0].f7Translate;
        if (sortingElOffset >= currentElOffset - currentElHeight / 2 && $sortingEl.index() < $currentEl.index()) {
          currentTranslate = -sortingElHeight;
          $currentEl.transform(`translate3d(0, ${currentTranslate}px,0)`);
          $insertAfterEl = $currentEl;
          $insertBeforeEl = void 0;
        } else if (sortingElOffset <= currentElOffset + currentElHeight / 2 && $sortingEl.index() > $currentEl.index()) {
          currentTranslate = sortingElHeight;
          $currentEl[0].f7Translate = currentTranslate;
          $currentEl.transform(`translate3d(0, ${currentTranslate}px,0)`);
          $insertAfterEl = void 0;
          if (!$insertBeforeEl)
            $insertBeforeEl = $currentEl;
        } else {
          currentTranslate = void 0;
          $currentEl.transform("translate3d(0, 0%,0)");
        }
        if (prevTranslate !== currentTranslate) {
          $currentEl.trigger("sortable:move");
          app.emit("sortableMove", $currentEl[0], $sortableContainer[0]);
        }
        $currentEl[0].f7Translate = currentTranslate;
      });
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        if (isTouched && !isMoved) {
          if (app.panel)
            app.panel.allowOpen = true;
          if (app.swipeout)
            app.swipeout.allow = true;
          if (wasTapHold) {
            $sortingEl.removeClass("sorting");
            $sortableContainer.removeClass("sortable-sorting");
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      if (app.panel)
        app.panel.allowOpen = true;
      if (app.swipeout)
        app.swipeout.allow = true;
      $sortingItems.transform("");
      $sortingEl.removeClass("sorting");
      $sortableContainer.removeClass("sortable-sorting");
      let indexTo;
      if ($insertAfterEl)
        indexTo = $insertAfterEl.index();
      else if ($insertBeforeEl)
        indexTo = $insertBeforeEl.index();
      let moveElements = $sortableContainer.dataset().sortableMoveElements;
      if (typeof moveElements === "undefined") {
        moveElements = app.params.sortable.moveElements;
      }
      if (moveElements) {
        if ($insertAfterEl) {
          $sortingEl.insertAfter($insertAfterEl);
        }
        if ($insertBeforeEl) {
          $sortingEl.insertBefore($insertBeforeEl);
        }
      }
      if (($insertAfterEl || $insertBeforeEl) && $sortableContainer.hasClass("virtual-list")) {
        indexFrom = $sortingEl[0].f7VirtualListIndex;
        if (typeof indexFrom === "undefined")
          indexFrom = $sortingEl.attr("data-virtual-list-index");
        if ($insertBeforeEl) {
          indexTo = $insertBeforeEl[0].f7VirtualListIndex;
          if (typeof indexTo === "undefined")
            indexTo = $insertBeforeEl.attr("data-virtual-list-index");
        } else {
          indexTo = $insertAfterEl[0].f7VirtualListIndex;
          if (typeof indexTo === "undefined")
            indexTo = $insertAfterEl.attr("data-virtual-list-index");
        }
        if (indexTo !== null)
          indexTo = parseInt(indexTo, 10);
        else
          indexTo = void 0;
        const virtualList = $sortableContainer[0].f7VirtualList;
        if (indexFrom)
          indexFrom = parseInt(indexFrom, 10);
        if (indexTo)
          indexTo = parseInt(indexTo, 10);
        if (virtualList)
          virtualList.moveItem(indexFrom, indexTo);
      }
      if (typeof indexTo !== "undefined" && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
        $sortingEl.trigger("sortable:sort", {
          from: indexFrom,
          to: indexTo
        });
        app.emit("sortableSort", $sortingEl[0], {
          from: indexFrom,
          to: indexTo,
          el: $sortingEl[0]
        }, $sortableContainer[0]);
      }
      $insertBeforeEl = void 0;
      $insertAfterEl = void 0;
      isTouched = false;
      isMoved = false;
    }
    const activeListener = getSupport().passiveListener ? {
      passive: false,
      capture: false
    } : false;
    dom7_default(document).on(app.touchEvents.start, ".list.sortable .sortable-handler", handleTouchStart, activeListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    dom7_default(document).on("taphold", ".sortable-tap-hold", (e, pointerEvent) => {
      handleTouchStart(pointerEvent, true);
    });
  },
  enable(el) {
    if (el === void 0) {
      el = ".list.sortable";
    }
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    $el.addClass("sortable-enabled");
    $el.trigger("sortable:enable");
    app.emit("sortableEnable", $el[0]);
  },
  disable(el) {
    if (el === void 0) {
      el = ".list.sortable";
    }
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    $el.removeClass("sortable-enabled");
    $el.trigger("sortable:disable");
    app.emit("sortableDisable", $el[0]);
  },
  toggle(el) {
    if (el === void 0) {
      el = ".list.sortable";
    }
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    if ($el.hasClass("sortable-enabled")) {
      app.sortable.disable($el);
    } else {
      app.sortable.enable($el);
    }
  }
};
var sortable_default = {
  name: "sortable",
  params: {
    sortable: {
      moveElements: true
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      sortable: Sortable
    });
  },
  on: {
    init() {
      const app = this;
      if (!app.params.sortable)
        return;
      app.sortable.init();
    }
  },
  clicks: {
    ".sortable-enable": function enable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sortable.enable(data.sortable);
    },
    ".sortable-disable": function disable($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sortable.disable(data.sortable);
    },
    ".sortable-toggle": function toggle($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.sortable.toggle(data.sortable);
    }
  }
};

// node_modules/framework7/components/swipeout/swipeout.js
var Swipeout = {
  init() {
    const app = this;
    const document = getDocument();
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchStartTime;
    let touchesDiff;
    let $swipeoutEl;
    let $swipeoutContent;
    let $actionsRight;
    let $actionsLeft;
    let actionsLeftWidth;
    let actionsRightWidth;
    let translate;
    let opened;
    let openedActionsSide;
    let $leftButtons;
    let $rightButtons;
    let direction;
    let $overswipeLeftButton;
    let $overswipeRightButton;
    let overswipeLeft;
    let overswipeRight;
    function handleTouchStart(e) {
      if (!app.swipeout.allow)
        return;
      isMoved = false;
      isTouched = true;
      isScrolling = void 0;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchStartTime = new Date().getTime();
      $swipeoutEl = dom7_default(this);
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      if (!isMoved) {
        if (dom7_default(".list.sortable-opened").length > 0)
          return;
        $swipeoutContent = $swipeoutEl.find(".swipeout-content");
        $actionsRight = $swipeoutEl.find(".swipeout-actions-right");
        $actionsLeft = $swipeoutEl.find(".swipeout-actions-left");
        actionsLeftWidth = null;
        actionsRightWidth = null;
        $leftButtons = null;
        $rightButtons = null;
        $overswipeRightButton = null;
        $overswipeLeftButton = null;
        if ($actionsLeft.length > 0) {
          actionsLeftWidth = $actionsLeft.outerWidth();
          $leftButtons = $actionsLeft.children("a");
          $overswipeLeftButton = $actionsLeft.find(".swipeout-overswipe");
        }
        if ($actionsRight.length > 0) {
          actionsRightWidth = $actionsRight.outerWidth();
          $rightButtons = $actionsRight.children("a");
          $overswipeRightButton = $actionsRight.find(".swipeout-overswipe");
        }
        opened = $swipeoutEl.hasClass("swipeout-opened");
        if (opened) {
          openedActionsSide = $swipeoutEl.find(".swipeout-actions-left.swipeout-actions-opened").length > 0 ? "left" : "right";
        }
        $swipeoutEl.removeClass("swipeout-transitioning");
        if (!app.params.swipeout.noFollow) {
          $swipeoutEl.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened");
          $swipeoutEl.removeClass("swipeout-opened");
        }
      }
      isMoved = true;
      if (e.cancelable) {
        e.preventDefault();
      }
      touchesDiff = pageX - touchesStart.x;
      translate = touchesDiff;
      if (opened) {
        if (openedActionsSide === "right")
          translate -= actionsRightWidth;
        else
          translate += actionsLeftWidth;
      }
      if (translate > 0 && $actionsLeft.length === 0 || translate < 0 && $actionsRight.length === 0) {
        if (!opened) {
          isTouched = false;
          isMoved = false;
          $swipeoutContent.transform("");
          if ($rightButtons && $rightButtons.length > 0) {
            $rightButtons.transform("");
          }
          if ($leftButtons && $leftButtons.length > 0) {
            $leftButtons.transform("");
          }
          return;
        }
        translate = 0;
      }
      if (translate < 0)
        direction = "to-left";
      else if (translate > 0)
        direction = "to-right";
      else if (!direction)
        direction = "to-left";
      let buttonOffset;
      let progress;
      e.f7PreventSwipePanel = true;
      if (app.params.swipeout.noFollow) {
        if (opened) {
          if (openedActionsSide === "right" && touchesDiff > 0) {
            app.swipeout.close($swipeoutEl);
          }
          if (openedActionsSide === "left" && touchesDiff < 0) {
            app.swipeout.close($swipeoutEl);
          }
        } else {
          if (touchesDiff < 0 && $actionsRight.length > 0) {
            app.swipeout.open($swipeoutEl, "right");
          }
          if (touchesDiff > 0 && $actionsLeft.length > 0) {
            app.swipeout.open($swipeoutEl, "left");
          }
        }
        isTouched = false;
        isMoved = false;
        return;
      }
      overswipeLeft = false;
      overswipeRight = false;
      if ($actionsRight.length > 0) {
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsRightWidth;
        if (buttonTranslate < -actionsRightWidth) {
          const ratio = buttonTranslate / -actionsRightWidth;
          buttonTranslate = -actionsRightWidth - (-buttonTranslate - actionsRightWidth) ** 0.8;
          translate = buttonTranslate;
          if ($overswipeRightButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
            overswipeRight = true;
          }
        }
        if (direction !== "to-left") {
          progress = 0;
          buttonTranslate = 0;
        }
        $rightButtons.each((buttonEl) => {
          const $buttonEl = dom7_default(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeRightButton.length > 0 && $buttonEl.hasClass("swipeout-overswipe") && direction === "to-left") {
            $buttonEl.css({
              left: `${overswipeRight ? -buttonOffset : 0}px`
            });
            if (overswipeRight) {
              if (!$buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeenter");
                app.emit("swipeoutOverswipeEnter", $swipeoutEl[0]);
              }
              $buttonEl.addClass("swipeout-overswipe-active");
            } else {
              if ($buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeexit");
                app.emit("swipeoutOverswipeExit", $swipeoutEl[0]);
              }
              $buttonEl.removeClass("swipeout-overswipe-active");
            }
          }
          $buttonEl.transform(`translate3d(${buttonTranslate - buttonOffset * (1 + Math.max(progress, -1))}px,0,0)`);
        });
      }
      if ($actionsLeft.length > 0) {
        let buttonTranslate = translate;
        progress = buttonTranslate / actionsLeftWidth;
        if (buttonTranslate > actionsLeftWidth) {
          const ratio = buttonTranslate / actionsRightWidth;
          buttonTranslate = actionsLeftWidth + (buttonTranslate - actionsLeftWidth) ** 0.8;
          translate = buttonTranslate;
          if ($overswipeLeftButton.length > 0 && ratio > app.params.swipeout.overswipeRatio) {
            overswipeLeft = true;
          }
        }
        if (direction !== "to-right") {
          buttonTranslate = 0;
          progress = 0;
        }
        $leftButtons.each((buttonEl, index2) => {
          const $buttonEl = dom7_default(buttonEl);
          if (typeof buttonEl.f7SwipeoutButtonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass("swipeout-overswipe") && direction === "to-right") {
            $buttonEl.css({
              left: `${overswipeLeft ? buttonOffset : 0}px`
            });
            if (overswipeLeft) {
              if (!$buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeenter");
                app.emit("swipeoutOverswipeEnter", $swipeoutEl[0]);
              }
              $buttonEl.addClass("swipeout-overswipe-active");
            } else {
              if ($buttonEl.hasClass("swipeout-overswipe-active")) {
                $swipeoutEl.trigger("swipeout:overswipeexit");
                app.emit("swipeoutOverswipeExit", $swipeoutEl[0]);
              }
              $buttonEl.removeClass("swipeout-overswipe-active");
            }
          }
          if ($leftButtons.length > 1) {
            $buttonEl.css("z-index", $leftButtons.length - index2);
          }
          $buttonEl.transform(`translate3d(${buttonTranslate + buttonOffset * (1 - Math.min(progress, 1))}px,0,0)`);
        });
      }
      $swipeoutEl.trigger("swipeout", progress);
      app.emit("swipeout", $swipeoutEl[0], progress);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      const timeDiff = new Date().getTime() - touchStartTime;
      const $actions = direction === "to-left" ? $actionsRight : $actionsLeft;
      const actionsWidth = direction === "to-left" ? actionsRightWidth : actionsLeftWidth;
      let action;
      let $buttons;
      let i;
      if (timeDiff < 300 && (touchesDiff < -10 && direction === "to-left" || touchesDiff > 10 && direction === "to-right") || timeDiff >= 300 && Math.abs(translate) > actionsWidth / 2) {
        action = "open";
      } else {
        action = "close";
      }
      if (timeDiff < 300) {
        if (Math.abs(translate) === 0)
          action = "close";
        if (Math.abs(translate) === actionsWidth)
          action = "open";
      }
      if (action === "open") {
        Swipeout.el = $swipeoutEl[0];
        $swipeoutEl.trigger("swipeout:open");
        app.emit("swipeoutOpen", $swipeoutEl[0]);
        $swipeoutEl.addClass("swipeout-opened swipeout-transitioning");
        const newTranslate = direction === "to-left" ? -actionsWidth : actionsWidth;
        $swipeoutContent.transform(`translate3d(${newTranslate}px,0,0)`);
        $actions.addClass("swipeout-actions-opened");
        $buttons = direction === "to-left" ? $rightButtons : $leftButtons;
        if ($buttons) {
          for (i = 0; i < $buttons.length; i += 1) {
            dom7_default($buttons[i]).transform(`translate3d(${newTranslate}px,0,0)`);
          }
        }
        if (overswipeRight) {
          $actionsRight.find(".swipeout-overswipe").trigger("click", "f7Overswipe");
        }
        if (overswipeLeft) {
          $actionsLeft.find(".swipeout-overswipe").trigger("click", "f7Overswipe");
        }
      } else {
        $swipeoutEl.trigger("swipeout:close");
        app.emit("swipeoutClose", $swipeoutEl[0]);
        Swipeout.el = void 0;
        $swipeoutEl.addClass("swipeout-transitioning").removeClass("swipeout-opened");
        $swipeoutContent.transform("");
        $actions.removeClass("swipeout-actions-opened");
      }
      let buttonOffset;
      if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
        $leftButtons.each((buttonEl) => {
          const $buttonEl = dom7_default(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
          }
          $buttonEl.transform(`translate3d(${buttonOffset}px,0,0)`);
        });
      }
      if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
        $rightButtons.each((buttonEl) => {
          const $buttonEl = dom7_default(buttonEl);
          buttonOffset = buttonEl.f7SwipeoutButtonOffset;
          if (typeof buttonOffset === "undefined") {
            $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
          }
          $buttonEl.transform(`translate3d(${-buttonOffset}px,0,0)`);
        });
      }
      $swipeoutContent.transitionEnd(() => {
        if (opened && action === "open" || !opened && action === "close")
          return;
        $swipeoutEl.trigger(action === "open" ? "swipeout:opened" : "swipeout:closed");
        app.emit(action === "open" ? "swipeoutOpened" : "swipeoutClosed", $swipeoutEl[0]);
        $swipeoutEl.removeClass("swipeout-transitioning");
        if (opened && action === "close") {
          if ($actionsRight.length > 0) {
            $rightButtons.transform("");
          }
          if ($actionsLeft.length > 0) {
            $leftButtons.transform("");
          }
        }
      });
    }
    const passiveListener = getSupport().passiveListener ? {
      passive: true
    } : false;
    app.on("touchstart", (e) => {
      if (Swipeout.el) {
        const $targetEl = dom7_default(e.target);
        if (!(dom7_default(Swipeout.el).is($targetEl[0]) || $targetEl.parents(".swipeout").is(Swipeout.el) || $targetEl.hasClass("modal-in") || ($targetEl.attr("class") || "").indexOf("-backdrop") > 0 || $targetEl.hasClass("actions-modal") || $targetEl.parents(".actions-modal.modal-in, .dialog.modal-in").length > 0)) {
          app.swipeout.close(Swipeout.el);
        }
      }
    });
    dom7_default(document).on(app.touchEvents.start, "li.swipeout", handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
  },
  allow: true,
  el: void 0,
  open() {
    const app = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    let [el, side, callback] = args;
    if (typeof args[1] === "function") {
      [el, callback, side] = args;
    }
    const $el = dom7_default(el).eq(0);
    if ($el.length === 0)
      return;
    if (!$el.hasClass("swipeout") || $el.hasClass("swipeout-opened"))
      return;
    if (!side) {
      if ($el.find(".swipeout-actions-right").length > 0)
        side = "right";
      else
        side = "left";
    }
    const $swipeoutActions = $el.find(`.swipeout-actions-${side}`);
    const $swipeoutContent = $el.find(".swipeout-content");
    if ($swipeoutActions.length === 0)
      return;
    $el.trigger("swipeout:open").addClass("swipeout-opened").removeClass("swipeout-transitioning");
    app.emit("swipeoutOpen", $el[0]);
    $swipeoutActions.addClass("swipeout-actions-opened");
    const $buttons = $swipeoutActions.children("a");
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    const translate = side === "right" ? -swipeoutActionsWidth : swipeoutActionsWidth;
    if ($buttons.length > 1) {
      $buttons.each((buttonEl, buttonIndex) => {
        const $buttonEl = dom7_default(buttonEl);
        if (side === "right") {
          $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
        } else {
          $buttonEl.css("z-index", $buttons.length - buttonIndex).transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
        }
      });
    }
    $el.addClass("swipeout-transitioning");
    $swipeoutContent.transitionEnd(() => {
      $el.trigger("swipeout:opened");
      app.emit("swipeoutOpened", $el[0]);
      if (callback)
        callback.call($el[0]);
    });
    nextFrame(() => {
      $buttons.transform(`translate3d(${translate}px,0,0)`);
      $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
    });
    Swipeout.el = $el[0];
  },
  close(el, callback) {
    const app = this;
    const $el = dom7_default(el).eq(0);
    if ($el.length === 0)
      return;
    if (!$el.hasClass("swipeout-opened"))
      return;
    const side = $el.find(".swipeout-actions-opened").hasClass("swipeout-actions-right") ? "right" : "left";
    const $swipeoutActions = $el.find(".swipeout-actions-opened").removeClass("swipeout-actions-opened");
    const $buttons = $swipeoutActions.children("a");
    const swipeoutActionsWidth = $swipeoutActions.outerWidth();
    app.swipeout.allow = false;
    $el.trigger("swipeout:close");
    app.emit("swipeoutClose", $el[0]);
    $el.removeClass("swipeout-opened").addClass("swipeout-transitioning");
    let closeTimeout;
    function onSwipeoutClose() {
      app.swipeout.allow = true;
      if ($el.hasClass("swipeout-opened"))
        return;
      $el.removeClass("swipeout-transitioning");
      $buttons.transform("");
      $el.trigger("swipeout:closed");
      app.emit("swipeoutClosed", $el[0]);
      if (callback)
        callback.call($el[0]);
      if (closeTimeout)
        clearTimeout(closeTimeout);
    }
    $el.find(".swipeout-content").transform("").transitionEnd(onSwipeoutClose);
    closeTimeout = setTimeout(onSwipeoutClose, 500);
    $buttons.each((buttonEl) => {
      const $buttonEl = dom7_default(buttonEl);
      if (side === "right") {
        $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
      } else {
        $buttonEl.transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
      }
      $buttonEl.css({
        left: "0px"
      }).removeClass("swipeout-overswipe-active");
    });
    if (Swipeout.el && Swipeout.el === $el[0])
      Swipeout.el = void 0;
  },
  delete(el, callback) {
    const app = this;
    const $el = dom7_default(el).eq(0);
    if ($el.length === 0)
      return;
    Swipeout.el = void 0;
    $el.trigger("swipeout:delete");
    app.emit("swipeoutDelete", $el[0]);
    $el.css({
      height: `${$el.outerHeight()}px`
    });
    $el.transitionEnd(() => {
      $el.trigger("swipeout:deleted");
      app.emit("swipeoutDeleted", $el[0]);
      if (callback)
        callback.call($el[0]);
      if ($el.parents(".virtual-list").length > 0) {
        const virtualList = $el.parents(".virtual-list")[0].f7VirtualList;
        const virtualIndex = $el[0].f7VirtualListIndex;
        if (virtualList && typeof virtualIndex !== "undefined")
          virtualList.deleteItem(virtualIndex);
      } else if (app.params.swipeout.removeElements) {
        if (app.params.swipeout.removeElementsWithTimeout) {
          setTimeout(() => {
            $el.remove();
          }, app.params.swipeout.removeElementsTimeout);
        } else {
          $el.remove();
        }
      } else {
        $el.removeClass("swipeout-deleting swipeout-transitioning");
      }
    });
    nextFrame(() => {
      $el.addClass("swipeout-deleting swipeout-transitioning").css({
        height: "0px"
      }).find(".swipeout-content").transform("translate3d(-100%,0,0)");
    });
  }
};
var swipeout_default = {
  name: "swipeout",
  params: {
    swipeout: {
      actionsNoFold: false,
      noFollow: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      overswipeRatio: 1.2
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      swipeout: Swipeout
    });
  },
  clicks: {
    ".swipeout-open": function openSwipeout($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.swipeout.open(data.swipeout, data.side);
    },
    ".swipeout-close": function closeSwipeout($clickedEl) {
      const app = this;
      const $swipeoutEl = $clickedEl.closest(".swipeout");
      if ($swipeoutEl.length === 0)
        return;
      app.swipeout.close($swipeoutEl);
    },
    ".swipeout-delete": function deleteSwipeout($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const $swipeoutEl = $clickedEl.closest(".swipeout");
      if ($swipeoutEl.length === 0)
        return;
      const {
        confirm,
        confirmTitle
      } = data;
      if (data.confirm) {
        app.dialog.confirm(confirm, confirmTitle, () => {
          app.swipeout.delete($swipeoutEl);
        });
      } else {
        app.swipeout.delete($swipeoutEl);
      }
    }
  },
  on: {
    init() {
      const app = this;
      if (!app.params.swipeout)
        return;
      app.swipeout.init();
    }
  }
};

// node_modules/framework7/components/accordion/accordion.js
var Accordion = {
  toggleClicked($clickedEl) {
    const app = this;
    let $accordionItemEl = $clickedEl.closest(".accordion-item").eq(0);
    if (!$accordionItemEl.length)
      $accordionItemEl = $clickedEl.parents("li").eq(0);
    const $accordionContent = $clickedEl.parents(".accordion-item-content").eq(0);
    if ($accordionContent.length) {
      if ($accordionContent.parents($accordionItemEl).length)
        return;
    }
    if ($clickedEl.parents("li").length > 1 && $clickedEl.parents("li")[0] !== $accordionItemEl[0])
      return;
    app.accordion.toggle($accordionItemEl);
  },
  open(el) {
    const app = this;
    const $el = dom7_default(el);
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    $el.trigger("accordion:beforeopen", {
      prevent
    }, prevent);
    app.emit("accordionBeforeOpen", $el[0], prevent);
    if (prevented)
      return;
    const $list = $el.parents(".accordion-list").eq(0);
    let $contentEl = $el.children(".accordion-item-content");
    $contentEl.removeAttr("aria-hidden");
    if ($contentEl.length === 0)
      $contentEl = $el.find(".accordion-item-content");
    if ($contentEl.length === 0)
      return;
    const $openedItem = $list.length > 0 && $el.parent().children(".accordion-item-opened");
    if ($openedItem.length > 0) {
      app.accordion.close($openedItem);
    }
    $contentEl.transitionEnd(() => {
      if ($el.hasClass("accordion-item-opened")) {
        $contentEl.transition(0);
        $contentEl.css("height", "auto");
        nextFrame(() => {
          $contentEl.transition("");
          $el.trigger("accordion:opened");
          app.emit("accordionOpened", $el[0]);
        });
      } else {
        $contentEl.css("height", "");
        $el.trigger("accordion:closed");
        app.emit("accordionClosed", $el[0]);
      }
    });
    $contentEl.css("height", `${$contentEl[0].scrollHeight}px`);
    $el.trigger("accordion:open");
    $el.addClass("accordion-item-opened");
    app.emit("accordionOpen", $el[0]);
  },
  close(el) {
    const app = this;
    const $el = dom7_default(el);
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    $el.trigger("accordion:beforeclose", {
      prevent
    }, prevent);
    app.emit("accordionBeforeClose", $el[0], prevent);
    if (prevented)
      return;
    let $contentEl = $el.children(".accordion-item-content");
    if ($contentEl.length === 0)
      $contentEl = $el.find(".accordion-item-content");
    $el.removeClass("accordion-item-opened");
    $contentEl.attr("aria-hidden", true);
    $contentEl.transition(0);
    $contentEl.css("height", `${$contentEl[0].scrollHeight}px`);
    $contentEl.transitionEnd(() => {
      if ($el.hasClass("accordion-item-opened")) {
        $contentEl.transition(0);
        $contentEl.css("height", "auto");
        nextFrame(() => {
          $contentEl.transition("");
          $el.trigger("accordion:opened");
          app.emit("accordionOpened", $el[0]);
        });
      } else {
        $contentEl.css("height", "");
        $el.trigger("accordion:closed");
        app.emit("accordionClosed", $el[0]);
      }
    });
    nextFrame(() => {
      $contentEl.transition("");
      $contentEl.css("height", "");
      $el.trigger("accordion:close");
      app.emit("accordionClose", $el[0]);
    });
  },
  toggle(el) {
    const app = this;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return;
    if ($el.hasClass("accordion-item-opened"))
      app.accordion.close(el);
    else
      app.accordion.open(el);
  }
};
var accordion_default = {
  name: "accordion",
  create() {
    const app = this;
    bindMethods(app, {
      accordion: Accordion
    });
  },
  clicks: {
    ".accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a": function open($clickedEl) {
      const app = this;
      Accordion.toggleClicked.call(app, $clickedEl);
    }
  }
};

// node_modules/framework7/components/contacts-list/contacts-list.js
var contacts_list_default = {
  name: "contactsList"
};

// node_modules/framework7/components/virtual-list/virtual-list-class.js
var VirtualList = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const vl = this;
    const device = getDevice();
    const document = getDocument();
    let defaultHeight;
    if (app.theme === "md") {
      defaultHeight = 48;
    } else if (app.theme === "ios") {
      defaultHeight = 44;
    } else if (app.theme === "aurora") {
      defaultHeight = 38;
    }
    const defaults = {
      cols: 1,
      height: defaultHeight,
      cache: true,
      dynamicHeightBufferSize: 1,
      showFilteredItemsOnly: false,
      renderExternal: void 0,
      setListHeight: true,
      searchByItem: void 0,
      searchAll: void 0,
      ul: null,
      createUl: true,
      scrollableParentEl: void 0,
      renderItem(item) {
        return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${item}</div>
              </div>
            </div>
          </li>
        `.trim();
      },
      on: {}
    };
    vl.useModulesParams(defaults);
    vl.params = extend(defaults, params);
    if (vl.params.height === void 0 || !vl.params.height) {
      vl.params.height = defaultHeight;
    }
    vl.$el = dom7_default(params.el);
    vl.el = vl.$el[0];
    if (vl.$el.length === 0)
      return void 0;
    vl.$el[0].f7VirtualList = vl;
    vl.items = vl.params.items;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    }
    if (vl.params.renderItem) {
      vl.renderItem = vl.params.renderItem;
    }
    vl.$pageContentEl = vl.$el.parents(".page-content");
    vl.pageContentEl = vl.$pageContentEl[0];
    vl.$scrollableParentEl = vl.params.scrollableParentEl ? dom7_default(vl.params.scrollableParentEl).eq(0) : vl.$pageContentEl;
    if (!vl.$scrollableParentEl.length && vl.$pageContentEl.length) {
      vl.$scrollableParentEl = vl.$pageContentEl;
    }
    vl.scrollableParentEl = vl.$scrollableParentEl[0];
    if (typeof vl.params.updatableScroll !== "undefined") {
      vl.updatableScroll = vl.params.updatableScroll;
    } else {
      vl.updatableScroll = true;
      if (device.ios && device.osVersion.split(".")[0] < 8) {
        vl.updatableScroll = false;
      }
    }
    const ul = vl.params.ul;
    vl.$ul = ul ? dom7_default(vl.params.ul) : vl.$el.children("ul");
    if (vl.$ul.length === 0 && vl.params.createUl) {
      vl.$el.append("<ul></ul>");
      vl.$ul = vl.$el.children("ul");
    }
    vl.ul = vl.$ul[0];
    let $itemsWrapEl;
    if (!vl.ul && !vl.params.createUl)
      $itemsWrapEl = vl.$el;
    else
      $itemsWrapEl = vl.$ul;
    extend(vl, {
      $itemsWrapEl,
      itemsWrapEl: $itemsWrapEl[0],
      domCache: {},
      displayDomCache: {},
      tempDomElement: document.createElement("ul"),
      lastRepaintY: null,
      fragment: document.createDocumentFragment(),
      pageHeight: void 0,
      rowsPerScreen: void 0,
      rowsBefore: void 0,
      rowsAfter: void 0,
      rowsToRender: void 0,
      maxBufferHeight: 0,
      listHeight: void 0,
      dynamicHeight: typeof vl.params.height === "function",
      autoHeight: vl.params.height === "auto"
    });
    vl.useModules();
    const handleScrollBound = vl.handleScroll.bind(vl);
    const handleResizeBound = vl.handleResize.bind(vl);
    let $pageEl;
    let $tabEl;
    let $panelEl;
    let $popupEl;
    vl.attachEvents = function attachEvents2() {
      $pageEl = vl.$el.parents(".page").eq(0);
      $tabEl = vl.$el.parents(".tab").filter((tabEl) => {
        return dom7_default(tabEl).parent(".tabs").parent(".tabs-animated-wrap, .tabs-swipeable-wrap").length === 0;
      }).eq(0);
      $panelEl = vl.$el.parents(".panel").eq(0);
      $popupEl = vl.$el.parents(".popup").eq(0);
      vl.$scrollableParentEl.on("scroll", handleScrollBound);
      if ($pageEl.length)
        $pageEl.on("page:reinit", handleResizeBound);
      if ($tabEl.length)
        $tabEl.on("tab:show", handleResizeBound);
      if ($panelEl.length)
        $panelEl.on("panel:open", handleResizeBound);
      if ($popupEl.length)
        $popupEl.on("popup:open", handleResizeBound);
      app.on("resize", handleResizeBound);
    };
    vl.detachEvents = function attachEvents2() {
      vl.$scrollableParentEl.off("scroll", handleScrollBound);
      if ($pageEl.length)
        $pageEl.off("page:reinit", handleResizeBound);
      if ($tabEl.length)
        $tabEl.off("tab:show", handleResizeBound);
      if ($panelEl.length)
        $panelEl.off("panel:open", handleResizeBound);
      if ($popupEl.length)
        $popupEl.off("popup:open", handleResizeBound);
      app.off("resize", handleResizeBound);
    };
    vl.init();
    return vl;
  }
  setListSize(autoHeightRerender) {
    const vl = this;
    const items = vl.filteredItems || vl.items;
    if (!autoHeightRerender) {
      vl.pageHeight = vl.$scrollableParentEl[0].offsetHeight;
    }
    if (vl.dynamicHeight) {
      vl.listHeight = 0;
      vl.heights = [];
      for (let i = 0; i < items.length; i += 1) {
        const itemHeight = vl.params.height(items[i]);
        vl.listHeight += itemHeight;
        vl.heights.push(itemHeight);
      }
    } else if (vl.autoHeight) {
      vl.listHeight = 0;
      if (!vl.heights)
        vl.heights = [];
      if (!vl.heightsCalculated)
        vl.heightsCalculated = [];
      const renderedItems = {};
      vl.$itemsWrapEl.find(`[data-virtual-list-index]`).forEach((el) => {
        renderedItems[parseInt(el.getAttribute("data-virtual-list-index"), 10)] = el;
      });
      for (let i = 0; i < items.length; i += 1) {
        const renderedItem = renderedItems[i];
        if (renderedItem) {
          if (!vl.heightsCalculated.includes(i)) {
            vl.heights[i] = renderedItem.offsetHeight;
            vl.heightsCalculated.push(i);
          }
        }
        if (typeof vl.heights[i] === "undefined") {
          vl.heights[i] = 40;
        }
        vl.listHeight += vl.heights[i];
      }
    } else {
      vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
      vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
      vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
      vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
      vl.rowsToRender = vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter;
      vl.maxBufferHeight = vl.rowsBefore / 2 * vl.params.height;
    }
    if (vl.updatableScroll || vl.params.setListHeight) {
      vl.$itemsWrapEl.css({
        height: `${vl.listHeight}px`
      });
    }
  }
  render(force, forceScrollTop) {
    const vl = this;
    if (force)
      vl.lastRepaintY = null;
    let scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$scrollableParentEl[0].getBoundingClientRect().top);
    if (typeof forceScrollTop !== "undefined")
      scrollTop = forceScrollTop;
    if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || !vl.updatableScroll && vl.$scrollableParentEl[0].scrollTop + vl.pageHeight >= vl.$scrollableParentEl[0].scrollHeight) {
      vl.lastRepaintY = scrollTop;
    } else {
      return;
    }
    const items = vl.filteredItems || vl.items;
    let fromIndex;
    let toIndex;
    let heightBeforeFirstItem = 0;
    let heightBeforeLastItem = 0;
    if (vl.dynamicHeight || vl.autoHeight) {
      let itemTop = 0;
      let itemHeight;
      vl.maxBufferHeight = vl.pageHeight;
      for (let j = 0; j < vl.heights.length; j += 1) {
        itemHeight = vl.heights[j];
        if (typeof fromIndex === "undefined") {
          if (itemTop + itemHeight >= scrollTop - vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)
            fromIndex = j;
          else
            heightBeforeFirstItem += itemHeight;
        }
        if (typeof toIndex === "undefined") {
          if (itemTop + itemHeight >= scrollTop + vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize || j === vl.heights.length - 1)
            toIndex = j + 1;
          heightBeforeLastItem += itemHeight;
        }
        itemTop += itemHeight;
      }
      toIndex = Math.min(toIndex, items.length);
    } else {
      fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
      if (fromIndex < 0) {
        fromIndex = 0;
      }
      toIndex = Math.min(fromIndex + vl.rowsToRender * vl.params.cols, items.length);
    }
    let topPosition;
    const renderExternalItems = [];
    vl.reachEnd = false;
    let i;
    for (i = fromIndex; i < toIndex; i += 1) {
      let itemEl;
      const index2 = vl.items.indexOf(items[i]);
      if (i === fromIndex)
        vl.currentFromIndex = index2;
      if (i === toIndex - 1)
        vl.currentToIndex = index2;
      if (vl.filteredItems) {
        if (vl.items[index2] === vl.filteredItems[vl.filteredItems.length - 1])
          vl.reachEnd = true;
      } else if (index2 === vl.items.length - 1)
        vl.reachEnd = true;
      if (vl.params.renderExternal) {
        renderExternalItems.push(items[i]);
      } else if (vl.domCache[index2]) {
        itemEl = vl.domCache[index2];
        itemEl.f7VirtualListIndex = index2;
      } else {
        if (vl.renderItem) {
          vl.tempDomElement.innerHTML = vl.renderItem(items[i], index2).trim();
        } else {
          vl.tempDomElement.innerHTML = items[i].toString().trim();
        }
        itemEl = vl.tempDomElement.childNodes[0];
        if (vl.params.cache)
          vl.domCache[index2] = itemEl;
        itemEl.f7VirtualListIndex = index2;
      }
      if (i === fromIndex) {
        if (vl.dynamicHeight || vl.autoHeight) {
          topPosition = heightBeforeFirstItem;
        } else {
          topPosition = i * vl.params.height / vl.params.cols;
        }
      }
      if (!vl.params.renderExternal) {
        itemEl.style.top = `${topPosition}px`;
        vl.emit("local::itemBeforeInsert vlItemBeforeInsert", vl, itemEl, items[i]);
        vl.fragment.appendChild(itemEl);
      }
    }
    if (!vl.updatableScroll) {
      if (vl.dynamicHeight || vl.autoHeight) {
        vl.itemsWrapEl.style.height = `${heightBeforeLastItem}px`;
      } else {
        vl.itemsWrapEl.style.height = `${i * vl.params.height / vl.params.cols}px`;
      }
    }
    if (vl.params.renderExternal) {
      if (items && items.length === 0) {
        vl.reachEnd = true;
      }
    } else {
      vl.emit("local::beforeClear vlBeforeClear", vl, vl.fragment);
      vl.itemsWrapEl.innerHTML = "";
      vl.emit("local::itemsBeforeInsert vlItemsBeforeInsert", vl, vl.fragment);
      if (items && items.length === 0) {
        vl.reachEnd = true;
        if (vl.params.emptyTemplate)
          vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
      } else {
        vl.itemsWrapEl.appendChild(vl.fragment);
      }
      vl.emit("local::itemsAfterInsert vlItemsAfterInsert", vl, vl.fragment);
    }
    if (typeof forceScrollTop !== "undefined" && force) {
      vl.$scrollableParentEl.scrollTop(forceScrollTop, 0);
    }
    if (vl.params.renderExternal) {
      vl.params.renderExternal(vl, {
        fromIndex,
        toIndex,
        listHeight: vl.listHeight,
        topPosition,
        items: renderExternalItems
      });
    }
    if (vl.autoHeight) {
      requestAnimationFrame(() => {
        vl.setListSize(true);
      });
    }
  }
  filterItems(indexes, resetScrollTop) {
    if (resetScrollTop === void 0) {
      resetScrollTop = true;
    }
    const vl = this;
    vl.filteredItems = [];
    for (let i = 0; i < indexes.length; i += 1) {
      vl.filteredItems.push(vl.items[indexes[i]]);
    }
    if (resetScrollTop) {
      vl.$scrollableParentEl[0].scrollTop = 0;
    }
    vl.update();
  }
  resetFilter() {
    const vl = this;
    if (vl.params.showFilteredItemsOnly) {
      vl.filteredItems = [];
    } else {
      vl.filteredItems = null;
      delete vl.filteredItems;
    }
    vl.update();
  }
  scrollToItem(index2) {
    const vl = this;
    if (index2 > vl.items.length)
      return false;
    let itemTop = 0;
    if (vl.dynamicHeight || vl.autoHeight) {
      for (let i = 0; i < index2; i += 1) {
        itemTop += vl.heights[i];
      }
    } else {
      itemTop = index2 * vl.params.height;
    }
    const listTop = vl.$el[0].offsetTop;
    vl.render(true, listTop + itemTop - parseInt(vl.$scrollableParentEl.css("padding-top"), 10));
    return true;
  }
  handleScroll() {
    const vl = this;
    vl.render();
  }
  isVisible() {
    const vl = this;
    return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
  }
  handleResize() {
    const vl = this;
    if (vl.isVisible()) {
      vl.heightsCalculated = [];
      vl.setListSize();
      vl.render(true);
    }
  }
  appendItems(items) {
    const vl = this;
    for (let i = 0; i < items.length; i += 1) {
      vl.items.push(items[i]);
    }
    vl.update();
  }
  appendItem(item) {
    const vl = this;
    vl.appendItems([item]);
  }
  replaceAllItems(items) {
    const vl = this;
    vl.items = items;
    delete vl.filteredItems;
    vl.domCache = {};
    vl.update();
  }
  replaceItem(index2, item) {
    const vl = this;
    vl.items[index2] = item;
    if (vl.params.cache)
      delete vl.domCache[index2];
    vl.update();
  }
  prependItems(items) {
    const vl = this;
    for (let i = items.length - 1; i >= 0; i -= 1) {
      vl.items.unshift(items[i]);
    }
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  prependItem(item) {
    const vl = this;
    vl.prependItems([item]);
  }
  moveItem(from, to) {
    const vl = this;
    const fromIndex = from;
    let toIndex = to;
    if (fromIndex === toIndex)
      return;
    const item = vl.items.splice(fromIndex, 1)[0];
    if (toIndex >= vl.items.length) {
      vl.items.push(item);
      toIndex = vl.items.length - 1;
    } else {
      vl.items.splice(toIndex, 0, item);
    }
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        const leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
        const rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
        const indexShift = fromIndex < toIndex ? -1 : 1;
        if (cachedIndex < leftIndex || cachedIndex > rightIndex)
          newCache[cachedIndex] = vl.domCache[cachedIndex];
        if (cachedIndex === leftIndex)
          newCache[rightIndex] = vl.domCache[cachedIndex];
        if (cachedIndex > leftIndex && cachedIndex <= rightIndex)
          newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  insertItemBefore(index2, item) {
    const vl = this;
    if (index2 === 0) {
      vl.prependItem(item);
      return;
    }
    if (index2 >= vl.items.length) {
      vl.appendItem(item);
      return;
    }
    vl.items.splice(index2, 0, item);
    if (vl.params.cache) {
      const newCache = {};
      Object.keys(vl.domCache).forEach((cached) => {
        const cachedIndex = parseInt(cached, 10);
        if (cachedIndex >= index2) {
          newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
        }
      });
      vl.domCache = newCache;
    }
    vl.update();
  }
  deleteItems(indexes) {
    const vl = this;
    let prevIndex;
    let indexShift = 0;
    for (let i = 0; i < indexes.length; i += 1) {
      let index2 = indexes[i];
      if (typeof prevIndex !== "undefined") {
        if (index2 > prevIndex) {
          indexShift = -i;
        }
      }
      index2 += indexShift;
      prevIndex = indexes[i];
      const deletedItem = vl.items.splice(index2, 1)[0];
      if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
        vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
      }
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          const cachedIndex = parseInt(cached, 10);
          if (cachedIndex === index2) {
            delete vl.domCache[index2];
          } else if (parseInt(cached, 10) > index2) {
            newCache[cachedIndex - 1] = vl.domCache[cached];
          } else {
            newCache[cachedIndex] = vl.domCache[cached];
          }
        });
        vl.domCache = newCache;
      }
    }
    vl.update();
  }
  deleteAllItems() {
    const vl = this;
    vl.items = [];
    delete vl.filteredItems;
    if (vl.params.cache)
      vl.domCache = {};
    vl.update();
  }
  deleteItem(index2) {
    const vl = this;
    vl.deleteItems([index2]);
  }
  clearCache() {
    const vl = this;
    vl.domCache = {};
  }
  update(deleteCache) {
    const vl = this;
    if (deleteCache && vl.params.cache) {
      vl.domCache = {};
    }
    vl.heightsCalculated = [];
    vl.setListSize();
    vl.render(true);
  }
  init() {
    const vl = this;
    vl.attachEvents();
    vl.setListSize();
    vl.render();
  }
  destroy() {
    let vl = this;
    vl.detachEvents();
    vl.$el[0].f7VirtualList = null;
    delete vl.$el[0].f7VirtualList;
    deleteProps(vl);
    vl = null;
  }
};
var virtual_list_class_default = VirtualList;

// node_modules/framework7/components/virtual-list/virtual-list.js
var virtual_list_default = {
  name: "virtualList",
  static: {
    VirtualList: virtual_list_class_default
  },
  create() {
    const app = this;
    app.virtualList = ConstructorMethods({
      defaultSelector: ".virtual-list",
      constructor: virtual_list_class_default,
      app,
      domProp: "f7VirtualList"
    });
  }
};

// node_modules/framework7/components/list-index/list-index-class.js
var ListIndex = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const index2 = this;
    const defaults = {
      el: null,
      listEl: null,
      indexes: "auto",
      iosItemHeight: 14,
      mdItemHeight: 14,
      auroraItemHeight: 14,
      scrollList: true,
      label: false,
      renderItem(itemContent, itemIndex) {
        return `
          <li>${itemContent}</li>
        `.trim();
      },
      renderSkipPlaceholder() {
        return '<li class="list-index-skip-placeholder"></li>';
      },
      on: {}
    };
    index2.useModulesParams(defaults);
    index2.params = extend(defaults, params);
    let $el;
    let $listEl;
    let $pageContentEl;
    let $ul;
    if (index2.params.el) {
      $el = dom7_default(index2.params.el);
    } else {
      return index2;
    }
    if ($el[0].f7ListIndex) {
      return $el[0].f7ListIndex;
    }
    $ul = $el.find("ul");
    if ($ul.length === 0) {
      $ul = dom7_default("<ul></ul>");
      $el.append($ul);
    }
    if (index2.params.listEl) {
      $listEl = dom7_default(index2.params.listEl);
    }
    if (index2.params.indexes === "auto" && !$listEl) {
      return index2;
    }
    if ($listEl) {
      $pageContentEl = $listEl.parents(".page-content").eq(0);
    } else {
      $pageContentEl = $el.siblings(".page-content").eq(0);
      if ($pageContentEl.length === 0) {
        $pageContentEl = $el.parents(".page").eq(0).find(".page-content").eq(0);
      }
    }
    $el[0].f7ListIndex = index2;
    extend(index2, {
      app,
      $el,
      el: $el && $el[0],
      $ul,
      ul: $ul && $ul[0],
      $listEl,
      listEl: $listEl && $listEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl && $pageContentEl[0],
      indexes: params.indexes,
      height: 0,
      skipRate: 0
    });
    index2.useModules();
    function handleResize() {
      const height = {
        index: index2
      };
      index2.calcSize();
      if (height !== index2.height) {
        index2.render();
      }
    }
    function handleClick(e) {
      const $clickedLi = dom7_default(e.target).closest("li");
      if (!$clickedLi.length)
        return;
      let itemIndex = $clickedLi.index();
      if (index2.skipRate > 0) {
        const percentage = itemIndex / ($clickedLi.siblings("li").length - 1);
        itemIndex = Math.round((index2.indexes.length - 1) * percentage);
      }
      const itemContent = index2.indexes[itemIndex];
      index2.$el.trigger("listindex:click", {
        content: itemContent,
        index: itemIndex
      });
      index2.emit("local::click listIndexClick", index2, itemContent, itemIndex);
      index2.$el.trigger("listindex:select", {
        content: itemContent,
        index: itemIndex
      });
      index2.emit("local::select listIndexSelect", index2, itemContent, itemIndex);
      if (index2.$listEl && index2.params.scrollList) {
        index2.scrollListToIndex(itemContent, itemIndex);
      }
    }
    const touchesStart = {};
    let isTouched;
    let isMoved;
    let topPoint;
    let bottomPoint;
    let $labelEl;
    let previousIndex = null;
    function handleTouchStart(e) {
      const $children = $ul.children();
      if (!$children.length)
        return;
      topPoint = $children[0].getBoundingClientRect().top;
      bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isMoved = false;
      previousIndex = null;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      if (!isMoved && index2.params.label) {
        $labelEl = dom7_default('<span class="list-index-label"></span>');
        $el.append($labelEl);
      }
      isMoved = true;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      let percentage = (pageY - topPoint) / (bottomPoint - topPoint);
      percentage = Math.min(Math.max(percentage, 0), 1);
      const itemIndex = Math.round((index2.indexes.length - 1) * percentage);
      const itemContent = index2.indexes[itemIndex];
      const ulHeight = bottomPoint - topPoint;
      const bubbleBottom = (index2.height - ulHeight) / 2 + (1 - percentage) * ulHeight;
      if (itemIndex !== previousIndex) {
        if (index2.params.label) {
          $labelEl.html(itemContent).transform(`translateY(-${bubbleBottom}px)`);
        }
        if (index2.$listEl && index2.params.scrollList) {
          index2.scrollListToIndex(itemContent, itemIndex);
        }
      }
      previousIndex = itemIndex;
      index2.$el.trigger("listindex:select");
      index2.emit("local::select listIndexSelect", index2, itemContent, itemIndex);
    }
    function handleTouchEnd() {
      if (!isTouched)
        return;
      isTouched = false;
      isMoved = false;
      if (index2.params.label) {
        if ($labelEl)
          $labelEl.remove();
        $labelEl = void 0;
      }
    }
    const passiveListener = getSupport().passiveListener ? {
      passive: true
    } : false;
    index2.attachEvents = function attachEvents2() {
      $el.parents(".tab").on("tab:show", handleResize);
      $el.parents(".page").on("page:reinit", handleResize);
      $el.parents(".panel").on("panel:open", handleResize);
      $el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").on("modal:open", handleResize);
      app.on("resize", handleResize);
      $el.on("click", handleClick);
      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on("touchmove:active", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
    };
    index2.detachEvents = function attachEvents2() {
      $el.parents(".tab").off("tab:show", handleResize);
      $el.parents(".page").off("page:reinit", handleResize);
      $el.parents(".panel").off("panel:open", handleResize);
      $el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast").off("modal:open", handleResize);
      app.off("resize", handleResize);
      $el.off("click", handleClick);
      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
    };
    index2.init();
    return index2;
  }
  scrollListToIndex(itemContent, itemIndex) {
    const index2 = this;
    const {
      $listEl,
      $pageContentEl,
      app
    } = index2;
    if (!$listEl || !$pageContentEl || $pageContentEl.length === 0)
      return index2;
    let $scrollToEl;
    $listEl.find(".list-group-title, .item-divider").each((el) => {
      if ($scrollToEl)
        return;
      const $el = dom7_default(el);
      if ($el.text() === itemContent) {
        $scrollToEl = $el;
      }
    });
    if (!$scrollToEl || $scrollToEl.length === 0)
      return index2;
    const parentTop = $scrollToEl.parent().offset().top;
    let paddingTop = parseInt($pageContentEl.css("padding-top"), 10);
    const scrollTop = $pageContentEl[0].scrollTop;
    const scrollToElTop = $scrollToEl.offset().top;
    if ($pageContentEl.parents(".page-with-navbar-large").length) {
      const navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents(".page-with-navbar-large").eq(0));
      const $titleLargeEl = dom7_default(navbarInnerEl).find(".title-large");
      if ($titleLargeEl.length) {
        paddingTop -= $titleLargeEl[0].offsetHeight || 0;
      }
    }
    if (parentTop <= paddingTop) {
      $pageContentEl.scrollTop(parentTop + scrollTop - paddingTop);
    } else {
      $pageContentEl.scrollTop(scrollToElTop + scrollTop - paddingTop);
    }
    return index2;
  }
  renderSkipPlaceholder() {
    const index2 = this;
    return index2.params.renderSkipPlaceholder.call(index2);
  }
  renderItem(itemContent, itemIndex) {
    const index2 = this;
    return index2.params.renderItem.call(index2, itemContent, itemIndex);
  }
  render() {
    const index2 = this;
    const {
      $ul,
      indexes,
      skipRate
    } = index2;
    let wasSkipped;
    const html2 = indexes.map((itemContent, itemIndex) => {
      if (itemIndex % skipRate !== 0 && skipRate > 0) {
        wasSkipped = true;
        return "";
      }
      let itemHtml = index2.renderItem(itemContent, itemIndex);
      if (wasSkipped) {
        itemHtml = index2.renderSkipPlaceholder() + itemHtml;
      }
      wasSkipped = false;
      return itemHtml;
    }).join("");
    $ul.html(html2);
    return index2;
  }
  calcSize() {
    const index2 = this;
    const {
      app,
      params,
      el,
      indexes
    } = index2;
    const height = el.offsetHeight;
    const itemHeight = params[`${app.theme}ItemHeight`];
    const maxItems = Math.floor(height / itemHeight);
    const items = indexes.length;
    let skipRate = 0;
    if (items > maxItems) {
      skipRate = Math.ceil((items * 2 - 1) / maxItems);
    }
    index2.height = height;
    index2.skipRate = skipRate;
    return index2;
  }
  calcIndexes() {
    const index2 = this;
    if (index2.params.indexes === "auto") {
      index2.indexes = [];
      index2.$listEl.find(".list-group-title, .item-divider").each((el) => {
        const elContent = dom7_default(el).text();
        if (index2.indexes.indexOf(elContent) < 0) {
          index2.indexes.push(elContent);
        }
      });
    } else {
      index2.indexes = index2.params.indexes;
    }
    return index2;
  }
  update() {
    const index2 = this;
    index2.calcIndexes();
    index2.calcSize();
    index2.render();
    return index2;
  }
  init() {
    const index2 = this;
    index2.calcIndexes();
    index2.calcSize();
    index2.render();
    index2.attachEvents();
  }
  destroy() {
    let index2 = this;
    index2.$el.trigger("listindex:beforedestroy", index2);
    index2.emit("local::beforeDestroy listIndexBeforeDestroy");
    index2.detachEvents();
    if (index2.$el[0]) {
      index2.$el[0].f7ListIndex = null;
      delete index2.$el[0].f7ListIndex;
    }
    deleteProps(index2);
    index2 = null;
  }
};
var list_index_class_default = ListIndex;

// node_modules/framework7/components/list-index/list-index.js
var list_index_default = {
  name: "listIndex",
  static: {
    ListIndex: list_index_class_default
  },
  create() {
    const app = this;
    app.listIndex = ConstructorMethods({
      defaultSelector: ".list-index",
      constructor: list_index_class_default,
      app,
      domProp: "f7ListIndex"
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".list-index-init").each((listIndexEl) => {
        const params = extend(dom7_default(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".list-index-init").each((listIndexEl) => {
        if (listIndexEl.f7ListIndex)
          listIndexEl.f7ListIndex.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".list-index-init").each((listIndexEl) => {
        const params = extend(dom7_default(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".list-index-init").each((listIndexEl) => {
        if (listIndexEl.f7ListIndex)
          listIndexEl.f7ListIndex.destroy();
      });
    }
  },
  vnode: {
    "list-index-init": {
      insert(vnode) {
        const app = this;
        const listIndexEl = vnode.elm;
        const params = extend(dom7_default(listIndexEl).dataset(), {
          el: listIndexEl
        });
        app.listIndex.create(params);
      },
      destroy(vnode) {
        const listIndexEl = vnode.elm;
        if (listIndexEl.f7ListIndex)
          listIndexEl.f7ListIndex.destroy();
      }
    }
  }
};

// node_modules/framework7/components/timeline/timeline.js
var timeline_default = {
  name: "timeline"
};

// node_modules/framework7/components/tabs/tabs.js
var Tab = {
  show() {
    const app = this;
    let tabEl;
    let tabLinkEl;
    let animate;
    let tabRoute;
    let animatedInit;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0] && args[0].constructor === Object) {
      tabEl = args[0].tabEl;
      tabLinkEl = args[0].tabLinkEl;
      animate = args[0].animate;
      tabRoute = args[0].tabRoute;
      animatedInit = args[0].animatedInit;
    } else {
      [tabEl, tabLinkEl, animate, tabRoute] = args;
      if (typeof args[1] === "boolean") {
        [tabEl, animate, tabLinkEl, tabRoute] = args;
        if (args.length > 2 && tabLinkEl.constructor === Object) {
          [tabEl, animate, tabRoute, tabLinkEl] = args;
        }
      }
    }
    if (typeof animate === "undefined")
      animate = true;
    const $newTabEl = dom7_default(tabEl);
    if (tabRoute && $newTabEl[0]) {
      $newTabEl[0].f7TabRoute = tabRoute;
    }
    if (!animatedInit && ($newTabEl.length === 0 || $newTabEl.hasClass("tab-active"))) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0]
      };
    }
    let $tabLinkEl;
    if (tabLinkEl)
      $tabLinkEl = dom7_default(tabLinkEl);
    const $tabsEl = $newTabEl.parent(".tabs");
    if ($tabsEl.length === 0) {
      return {
        $newTabEl,
        newTabEl: $newTabEl[0]
      };
    }
    if (app.swipeout)
      app.swipeout.allowOpen = true;
    const tabsChangedCallbacks = [];
    function onTabsChanged(callback) {
      tabsChangedCallbacks.push(callback);
    }
    function tabsChanged() {
      tabsChangedCallbacks.forEach((callback) => {
        callback();
      });
    }
    let animated = false;
    if ($tabsEl.parent().hasClass("tabs-animated-wrap")) {
      $tabsEl.parent()[animate ? "removeClass" : "addClass"]("not-animated");
      const transitionDuration = parseFloat($tabsEl.css("transition-duration").replace(",", "."));
      if (animate && transitionDuration) {
        $tabsEl.transitionEnd(tabsChanged);
        animated = true;
      }
      const tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
      $tabsEl.transform(`translate3d(${tabsTranslate}%,0,0)`);
    }
    let swiper;
    if ($tabsEl.parent().hasClass("tabs-swipeable-wrap") && app.swiper) {
      swiper = $tabsEl.parent()[0].swiper;
      if (swiper && swiper.activeIndex !== $newTabEl.index()) {
        animated = true;
        swiper.once("slideChangeTransitionEnd", () => {
          tabsChanged();
        }).slideTo($newTabEl.index(), animate ? void 0 : 0);
      } else if (swiper && swiper.animating) {
        animated = true;
        swiper.once("slideChangeTransitionEnd", () => {
          tabsChanged();
        });
      }
    }
    const $oldTabEl = $tabsEl.children(".tab-active");
    $oldTabEl.removeClass("tab-active");
    if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
      if ($oldTabEl.hasClass("view") && $oldTabEl.children(".page").length) {
        $oldTabEl.children(".page").each((pageEl) => {
          dom7_default(pageEl).trigger("page:tabhide");
          app.emit("pageTabHide", pageEl);
        });
      }
      $oldTabEl.trigger("tab:hide");
      app.emit("tabHide", $oldTabEl[0]);
    }
    $newTabEl.addClass("tab-active");
    if (!animatedInit && (!swiper || swiper && !swiper.animating || swiper && tabRoute)) {
      if ($newTabEl.hasClass("view") && $newTabEl.children(".page").length) {
        $newTabEl.children(".page").each((pageEl) => {
          dom7_default(pageEl).trigger("page:tabshow");
          app.emit("pageTabShow", pageEl);
        });
      }
      $newTabEl.trigger("tab:show");
      app.emit("tabShow", $newTabEl[0]);
    }
    if (!$tabLinkEl) {
      if (typeof tabEl === "string")
        $tabLinkEl = dom7_default(`.tab-link[href="${tabEl}"]`);
      else
        $tabLinkEl = dom7_default(`.tab-link[href="#${$newTabEl.attr("id")}"]`);
      if (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0) {
        dom7_default("[data-tab]").each((el) => {
          if ($newTabEl.is(dom7_default(el).attr("data-tab")))
            $tabLinkEl = dom7_default(el);
        });
      }
      if (tabRoute && (!$tabLinkEl || $tabLinkEl && $tabLinkEl.length === 0)) {
        $tabLinkEl = dom7_default(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
        if ($tabLinkEl.length === 0) {
          $tabLinkEl = dom7_default(`.tab-link[href="${tabRoute.url}"]`);
        }
      }
      if ($tabLinkEl.length > 1 && $newTabEl.parents(".page").length) {
        $tabLinkEl = $tabLinkEl.filter((tabLinkElement) => {
          return dom7_default(tabLinkElement).parents(".page")[0] === $newTabEl.parents(".page")[0];
        });
        if (app.theme === "ios" && $tabLinkEl.length === 0 && tabRoute) {
          const $pageEl = $newTabEl.parents(".page");
          const $navbarEl = dom7_default(app.navbar.getElByPage($pageEl));
          $tabLinkEl = $navbarEl.find(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
          if ($tabLinkEl.length === 0) {
            $tabLinkEl = $navbarEl.find(`.tab-link[href="${tabRoute.url}"]`);
          }
        }
      }
    }
    if ($tabLinkEl.length > 0) {
      let $oldTabLinkEl;
      if ($oldTabEl && $oldTabEl.length > 0) {
        const oldTabId = $oldTabEl.attr("id");
        if (oldTabId) {
          $oldTabLinkEl = dom7_default(`.tab-link[href="#${oldTabId}"]`);
          if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
            $oldTabLinkEl = dom7_default(`.tab-link[data-route-tab-id="${oldTabId}"]`);
          }
        }
        if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
          dom7_default("[data-tab]").each((tabLinkElement) => {
            if ($oldTabEl.is(dom7_default(tabLinkElement).attr("data-tab")))
              $oldTabLinkEl = dom7_default(tabLinkElement);
          });
        }
        if (!$oldTabLinkEl || $oldTabLinkEl && $oldTabLinkEl.length === 0) {
          $oldTabLinkEl = $tabLinkEl.siblings(".tab-link-active");
        }
      } else if (tabRoute) {
        $oldTabLinkEl = $tabLinkEl.siblings(".tab-link-active");
      }
      if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents(".page").length) {
        $oldTabLinkEl = $oldTabLinkEl.filter((tabLinkElement) => {
          return dom7_default(tabLinkElement).parents(".page")[0] === $oldTabEl.parents(".page")[0];
        });
      }
      if ($oldTabLinkEl && $oldTabLinkEl.length > 0)
        $oldTabLinkEl.removeClass("tab-link-active");
      if ($tabLinkEl && $tabLinkEl.length > 0) {
        $tabLinkEl.addClass("tab-link-active");
        const $tabbarEl = $tabLinkEl.parents(".tabbar, .tabbar-labels");
        const hasHighlight = app.toolbar && $tabbarEl.length > 0 && ($tabbarEl.hasClass("tabbar-highlight") || app.theme !== "ios");
        if (hasHighlight) {
          app.toolbar.setHighlight($tabbarEl);
        }
      }
    }
    return {
      $newTabEl,
      newTabEl: $newTabEl[0],
      $oldTabEl,
      oldTabEl: $oldTabEl[0],
      onTabsChanged,
      animated
    };
  }
};
var tabs_default = {
  name: "tabs",
  create() {
    const app = this;
    extend(app, {
      tab: {
        show: Tab.show.bind(app)
      }
    });
  },
  on: {
    "pageInit tabMounted": function onInit(pageOrTabEl) {
      const $el = dom7_default(pageOrTabEl.el || pageOrTabEl);
      const animatedTabEl = $el.find(".tabs-animated-wrap > .tabs > .tab-active")[0];
      if (!animatedTabEl)
        return;
      const app = this;
      app.tab.show({
        tabEl: animatedTabEl,
        animatedInit: true,
        animate: false
      });
    }
  },
  clicks: {
    ".tab-link": function tabLinkClick($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      if ($clickedEl.attr("href") && $clickedEl.attr("href").indexOf("#") === 0 || $clickedEl.attr("data-tab")) {
        const app = this;
        app.tab.show({
          tabEl: data.tab || $clickedEl.attr("href"),
          tabLinkEl: $clickedEl,
          animate: data.animate
        });
      }
    }
  }
};

// node_modules/framework7/components/panel/swipe-panel.js
function swipePanel(panel) {
  const app = panel.app;
  if (panel.swipeInitialized) {
    return;
  }
  extend(panel, {
    swipeable: true,
    swipeInitialized: true
  });
  const params = panel.params;
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  let otherPanel;
  let isTouched;
  let isGestureStarted;
  let isMoved;
  let isScrolling;
  let isInterrupted;
  const touchesStart = {};
  let touchStartTime;
  let touchesDiff;
  let translate;
  let backdropOpacity;
  let panelWidth;
  let direction;
  let $viewEl;
  let touchMoves = 0;
  function handleTouchStart(e) {
    if (!panel.swipeable || isGestureStarted)
      return;
    if (!app.panel.allowOpen || !params.swipe && !params.swipeOnlyClose || isTouched)
      return;
    if (dom7_default(".modal-in:not(.toast):not(.notification), .photo-browser-in").length > 0)
      return;
    otherPanel = app.panel.get(side === "left" ? "right" : "left") || {};
    const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass("panel-in-breakpoint");
    if (!panel.opened && otherPanelOpened) {
      return;
    }
    if (!params.swipeOnlyClose) {
      if (otherPanelOpened)
        return;
    }
    if (e.target && e.target.nodeName.toLowerCase() === "input" && e.target.type === "range")
      return;
    if (dom7_default(e.target).closest(".range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened").length > 0)
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    if (params.swipeOnlyClose && !panel.opened) {
      return;
    }
    if (params.swipeActiveArea && !panel.opened) {
      if (side === "left") {
        if (touchesStart.x > params.swipeActiveArea)
          return;
      }
      if (side === "right") {
        if (touchesStart.x < app.width - params.swipeActiveArea)
          return;
      }
    }
    touchMoves = 0;
    $viewEl = dom7_default(panel.getViewEl());
    isMoved = false;
    isTouched = true;
    isScrolling = void 0;
    isInterrupted = false;
    touchStartTime = now();
    direction = void 0;
  }
  function handleTouchMove(e) {
    if (!isTouched || isGestureStarted || isInterrupted)
      return;
    touchMoves += 1;
    if (touchMoves < 2)
      return;
    if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
      isTouched = false;
      return;
    }
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
    }
    if (isScrolling) {
      isTouched = false;
      return;
    }
    if (!direction) {
      if (pageX > touchesStart.x) {
        direction = "to-right";
      } else {
        direction = "to-left";
      }
      if (params.swipeActiveArea > 0 && !panel.opened) {
        if (side === "left" && touchesStart.x > params.swipeActiveArea) {
          isTouched = false;
          return;
        }
        if (side === "right" && touchesStart.x < app.width - params.swipeActiveArea) {
          isTouched = false;
          return;
        }
      }
      if ($el.hasClass("panel-in-breakpoint")) {
        isTouched = false;
        return;
      }
      if (side === "left" && direction === "to-left" && !$el.hasClass("panel-in") || side === "right" && direction === "to-right" && !$el.hasClass("panel-in")) {
        isTouched = false;
        return;
      }
    }
    let threshold = panel.opened ? 0 : -params.swipeThreshold;
    if (side === "right")
      threshold = -threshold;
    if (!isMoved) {
      if (!panel.opened) {
        panel.insertToRoot();
        $el.addClass("panel-in-swipe");
        $backdropEl.css("visibility", "visible");
        $el.trigger("panel:swipeopen");
        panel.emit("local::swipeOpen panelSwipeOpen", panel);
      }
      panelWidth = $el[0].offsetWidth;
      if (effect === "reveal" && $el.hasClass("panel-in-collapsed")) {
        panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
      }
      $el.transition(0);
    }
    isMoved = true;
    if (e.cancelable) {
      e.preventDefault();
    }
    touchesDiff = pageX - touchesStart.x + threshold;
    if (side === "right") {
      if (effect === "cover" || effect === "push") {
        translate = touchesDiff + (panel.opened ? 0 : panelWidth);
        if (translate < 0)
          translate = 0;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      } else {
        translate = touchesDiff - (panel.opened ? panelWidth : 0);
        if (translate > 0)
          translate = 0;
        if (translate < -panelWidth) {
          translate = -panelWidth;
        }
      }
    } else {
      translate = touchesDiff + (panel.opened ? panelWidth : 0);
      if (translate < 0)
        translate = 0;
      if (translate > panelWidth) {
        translate = panelWidth;
      }
    }
    const noFollowProgress = Math.abs(translate / panelWidth);
    if (effect === "reveal") {
      if (!params.swipeNoFollow) {
        $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    } else {
      if (side === "left")
        translate -= panelWidth;
      if (!params.swipeNoFollow) {
        $backdropEl.transition(0);
        backdropOpacity = 1 - Math.abs(translate / panelWidth);
        $backdropEl.css({
          opacity: backdropOpacity
        });
        $el.transform(`translate3d(${translate}px,0,0)`).transition(0);
        if (effect === "push") {
          const viewTranslate = side === "left" ? translate + panelWidth : translate - panelWidth;
          $viewEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
          $backdropEl.transform(`translate3d(${viewTranslate}px,0,0)`).transition(0);
        }
      }
      $el.trigger("panel:swipe", Math.abs(translate / panelWidth));
      panel.emit("local::swipe panelSwipe", panel, Math.abs(translate / panelWidth));
    }
    if (params.swipeNoFollow) {
      const stateChanged = panel.opened && noFollowProgress === 0 || !panel.opened && noFollowProgress === 1;
      if (stateChanged) {
        isInterrupted = true;
        handleTouchEnd(e);
      }
    }
  }
  function handleTouchEnd(e) {
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    const isGesture = e.type === "gesturestart" || isGestureStarted;
    isTouched = false;
    isMoved = false;
    const timeDiff = new Date().getTime() - touchStartTime;
    let action;
    const edge = (translate === 0 || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;
    const threshold = params.swipeThreshold || 0;
    if (isGesture) {
      action = "reset";
    } else if (!panel.opened) {
      if (Math.abs(touchesDiff) < threshold) {
        action = "reset";
      } else if (effect === "cover" || effect === "push") {
        if (translate === 0) {
          action = "swap";
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = "swap";
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = "swap";
        } else {
          action = "reset";
        }
      } else if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0 || timeDiff >= 300 && Math.abs(translate) >= panelWidth / 2) {
        action = "swap";
      } else {
        action = "reset";
      }
    } else if (effect === "cover" || effect === "push") {
      if (translate === 0) {
        action = "reset";
      } else if (timeDiff < 300 && Math.abs(translate) > 0) {
        action = "swap";
      } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
        action = "reset";
      } else {
        action = "swap";
      }
    } else if (translate === -panelWidth) {
      action = "reset";
    } else if (timeDiff < 300 && Math.abs(translate) >= 0 || timeDiff >= 300 && Math.abs(translate) <= panelWidth / 2) {
      if (side === "left" && translate === panelWidth)
        action = "reset";
      else
        action = "swap";
    } else {
      action = "reset";
    }
    if (action === "swap") {
      if (panel.opened) {
        panel.close(!edge);
      } else {
        panel.open(!edge);
      }
    }
    let removePanelInClass = true;
    if (action === "reset") {
      if (!panel.opened) {
        if (edge) {
          $el.removeClass("panel-in-swipe");
        } else {
          removePanelInClass = false;
          const target = effect === "reveal" ? $viewEl : $el;
          panel.setStateClasses("before-closing");
          target.transitionEnd(() => {
            if ($el.hasClass("panel-in"))
              return;
            $el.removeClass("panel-in-swipe");
            panel.setStateClasses("after-closing");
          });
        }
      }
    }
    if (effect === "reveal" || effect === "push") {
      nextFrame(() => {
        $viewEl.transition("");
        $viewEl.transform("");
      });
    }
    if (removePanelInClass) {
      $el.removeClass("panel-in-swipe");
    }
    $el.transition("").transform("");
    $backdropEl.transform("").transition("").css({
      opacity: "",
      visibility: ""
    });
  }
  function handleGestureStart(e) {
    isGestureStarted = true;
    handleTouchEnd(e);
  }
  function handleGestureEnd() {
    isGestureStarted = false;
  }
  app.on("touchstart:passive", handleTouchStart);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("gesturestart", handleGestureStart);
  app.on("gestureend", handleGestureEnd);
  panel.on("panelDestroy", () => {
    app.off("touchstart:passive", handleTouchStart);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("gesturestart", handleGestureStart);
    app.off("gestureend", handleGestureEnd);
  });
}
var swipe_panel_default = swipePanel;

// node_modules/framework7/components/panel/resizable-panel.js
function resizablePanel(panel) {
  const app = panel.app;
  const support2 = getSupport();
  if (panel.resizableInitialized)
    return;
  extend(panel, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  const $htmlEl = dom7_default("html");
  const {
    $el,
    $backdropEl,
    side,
    effect
  } = panel;
  if (!$el)
    return;
  let isTouched;
  let isMoved;
  const touchesStart = {};
  let touchesDiff;
  let panelWidth;
  let $viewEl;
  let panelMinWidth;
  let panelMaxWidth;
  let visibleByBreakpoint;
  function transformCSSWidth(v) {
    if (!v)
      return null;
    if (v.indexOf("%") >= 0 || v.indexOf("vw") >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }
    const newV = parseInt(v, 10);
    if (Number.isNaN(newV))
      return null;
    return newV;
  }
  function isResizable() {
    return panel.resizable && $el.hasClass("panel-resizable");
  }
  function handleTouchStart(e) {
    if (!isResizable())
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    visibleByBreakpoint = $el.hasClass("panel-in-breakpoint");
  }
  function handleTouchMove(e) {
    if (!isTouched)
      return;
    const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    if (!isMoved) {
      panelWidth = $el[0].offsetWidth;
      $el.transition(0);
      $el.addClass("panel-resizing");
      $htmlEl.css("cursor", "col-resize");
      if (effect !== "cover" || visibleByBreakpoint) {
        $viewEl = dom7_default(panel.getViewEl());
        if (panel.$containerEl && panel.$containerEl.hasClass("page")) {
          $viewEl.add(panel.$containerEl.children(".page-content, .tabs, .fab"));
        }
      }
      if (effect !== "cover" && !visibleByBreakpoint) {
        $backdropEl.transition(0);
        $viewEl.transition(0);
      }
    }
    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    let newPanelWidth = side === "left" ? panelWidth + touchesDiff : panelWidth - touchesDiff;
    if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
      newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
      newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
    }
    newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);
    panel.resizableWidth = newPanelWidth;
    $el[0].style.width = `${newPanelWidth}px`;
    if (effect !== "cover" && !visibleByBreakpoint) {
      if ($viewEl) {
        $viewEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
      if ($backdropEl) {
        $backdropEl.transform(`translate3d(${side === "left" ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
      }
    } else if (visibleByBreakpoint && $viewEl) {
      $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
    }
    $el.trigger("panel:resize", newPanelWidth);
    panel.emit("local::resize panelResize", panel, newPanelWidth);
  }
  function handleTouchEnd() {
    dom7_default("html").css("cursor", "");
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    $el[0].style.width = "";
    if (effect !== "cover" && !visibleByBreakpoint) {
      $viewEl.transform("");
      $backdropEl.transform("");
    }
    $el.removeClass("panel-resizing");
    nextFrame(() => {
      $el.transition("");
      if (effect !== "cover") {
        $backdropEl.transition("");
        if ($viewEl)
          $viewEl.transition("");
      }
    });
  }
  function handleResize() {
    if (!panel.opened || !panel.resizableWidth)
      return;
    panelMinWidth = transformCSSWidth($el.css("min-width"));
    panelMaxWidth = transformCSSWidth($el.css("max-width"));
    if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
      panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
    }
    if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
      panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
    }
    panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);
    $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
  }
  if (panel.$el.find(".panel-resize-handler").length === 0) {
    panel.$el.append('<div class="panel-resize-handler"></div>');
  }
  panel.$resizeHandlerEl = panel.$el.children(".panel-resize-handler");
  $el.addClass("panel-resizable");
  const passive = support2.passiveListener ? {
    passive: true
  } : false;
  panel.$el.on(app.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("resize", handleResize);
  panel.on("beforeOpen", handleResize);
  panel.once("panelDestroy", () => {
    $el.removeClass("panel-resizable");
    panel.$resizeHandlerEl.remove();
    panel.$el.off(app.touchEvents.start, ".panel-resize-handler", handleTouchStart, passive);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("resize", handleResize);
    panel.off("beforeOpen", handleResize);
  });
}
var resizable_panel_default = resizablePanel;

// node_modules/framework7/components/panel/panel-class.js
var Panel = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    const extendedParams = extend({
      on: {}
    }, app.params.panel, params);
    super(extendedParams, [app]);
    const panel = this;
    panel.params = extendedParams;
    panel.$containerEl = panel.params.containerEl ? dom7_default(panel.params.containerEl).eq(0) : app.$el;
    panel.containerEl = panel.$containerEl[0];
    if (!panel.containerEl) {
      panel.$containerEl = app.$el;
      panel.containerEl = app.$el[0];
    }
    let $el;
    if (panel.params.el) {
      $el = dom7_default(panel.params.el).eq(0);
    } else if (panel.params.content) {
      $el = dom7_default(panel.params.content).filter((node) => node.nodeType === 1).eq(0);
    }
    if ($el.length === 0)
      return panel;
    if ($el[0].f7Panel)
      return $el[0].f7Panel;
    $el[0].f7Panel = panel;
    let {
      side,
      effect,
      resizable
    } = panel.params;
    if (typeof side === "undefined")
      side = $el.hasClass("panel-left") ? "left" : "right";
    if (typeof effect === "undefined")
      effect = $el.hasClass("panel-cover") ? "cover" : $el.hasClass("panel-push") ? "push" : "reveal";
    if (typeof resizable === "undefined")
      resizable = $el.hasClass("panel-resizable");
    let $backdropEl;
    if (panel.params.backdrop && panel.params.backdropEl) {
      $backdropEl = dom7_default(panel.params.backdropEl);
    } else if (panel.params.backdrop) {
      $backdropEl = panel.$containerEl.children(".panel-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="panel-backdrop"></div>');
        panel.$containerEl.prepend($backdropEl);
      }
    }
    extend(panel, {
      app,
      side,
      effect,
      resizable,
      $el,
      el: $el[0],
      opened: false,
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0]
    });
    panel.useModules();
    panel.init();
    return panel;
  }
  getViewEl() {
    const panel = this;
    let viewEl;
    if (panel.$containerEl.children(".views").length > 0) {
      viewEl = panel.$containerEl.children(".views")[0];
    } else {
      viewEl = panel.$containerEl.children(".view")[0];
    }
    return viewEl;
  }
  setStateClasses(state) {
    const panel = this;
    const {
      side,
      el
    } = panel;
    const viewEl = panel.getViewEl();
    const panelInView = viewEl && viewEl.contains(el);
    const $targetEl = !viewEl || panelInView ? panel.$containerEl : dom7_default("html");
    if (state === "open") {
      $targetEl.addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "before-closing") {
      $targetEl.addClass("with-panel-closing");
    }
    if (state === "closing") {
      $targetEl.addClass("with-panel-closing");
      $targetEl.removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
    }
    if (state === "after-closing") {
      $targetEl.removeClass("with-panel-closing");
    }
    if (state === "closed") {
      $targetEl.removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel-${side}-push with-panel`);
    }
  }
  enableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = false;
    panel.setVisibleBreakpoint();
    return panel;
  }
  disableVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = true;
    panel.setVisibleBreakpoint();
    return panel;
  }
  toggleVisibleBreakpoint() {
    const panel = this;
    panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
    panel.setVisibleBreakpoint();
    return panel;
  }
  setVisibleBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app = panel.app;
    if (!panel.visibleBreakpointResizeHandler) {
      panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
        panel.setVisibleBreakpoint();
      };
      app.on("resize", panel.visibleBreakpointResizeHandler);
    }
    const {
      side,
      $el,
      $containerEl,
      params,
      visibleBreakpointDisabled
    } = panel;
    const breakpoint = params.visibleBreakpoint;
    const $viewEl = dom7_default(panel.getViewEl());
    const wasVisible = $el.hasClass("panel-in-breakpoint");
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs, .fab"));
    }
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !visibleBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-breakpoint").removeClass("panel-in panel-in-collapsed");
        panel.onOpen(false);
        panel.onOpened();
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::breakpoint panelBreakpoint", panel);
          panel.$el.trigger("panel:breakpoint");
        }
      } else {
        $viewEl.css({
          [`margin-${side}`]: `${$el.width()}px`
        });
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-breakpoint panel-in");
      panel.onClose();
      panel.onClosed();
      $viewEl.css({
        [`margin-${side}`]: ""
      });
      if (emitEvents) {
        panel.emit("local::breakpoint panelBreakpoint", panel);
        panel.$el.trigger("panel:breakpoint");
      }
    }
  }
  enableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = false;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  disableCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = true;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  toggleCollapsedBreakpoint() {
    const panel = this;
    panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
    panel.setCollapsedBreakpoint();
    return panel;
  }
  setCollapsedBreakpoint(emitEvents) {
    if (emitEvents === void 0) {
      emitEvents = true;
    }
    const panel = this;
    const app = panel.app;
    if (!panel.collapsedBreakpointResizeHandler) {
      panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
        panel.setCollapsedBreakpoint();
      };
      app.on("resize", panel.collapsedBreakpointResizeHandler);
    }
    const {
      $el,
      params,
      collapsedBreakpointDisabled
    } = panel;
    if ($el.hasClass("panel-in-breakpoint"))
      return;
    const breakpoint = params.collapsedBreakpoint;
    const wasVisible = $el.hasClass("panel-in-collapsed");
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null && !collapsedBreakpointDisabled) {
      if (!wasVisible) {
        panel.setStateClasses("closed");
        $el.addClass("panel-in-collapsed").removeClass("panel-in");
        panel.collapsed = true;
        app.allowPanelOpen = true;
        if (emitEvents) {
          panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
          panel.$el.trigger("panel:collapsedbreakpoint");
        }
      }
    } else if (wasVisible) {
      $el.removeClass("panel-in-collapsed panel-in");
      panel.collapsed = false;
      if (emitEvents) {
        panel.emit("local::collapsedBreakpoint panelCollapsedBreakpoint", panel);
        panel.$el.trigger("panel:collapsedbreakpoint");
      }
    }
  }
  enableResizable() {
    const panel = this;
    if (panel.resizableInitialized) {
      panel.resizable = true;
      panel.$el.addClass("panel-resizable");
    } else {
      resizable_panel_default(panel);
    }
    return panel;
  }
  disableResizable() {
    const panel = this;
    panel.resizable = false;
    panel.$el.removeClass("panel-resizable");
    return panel;
  }
  enableSwipe() {
    const panel = this;
    if (panel.swipeInitialized) {
      panel.swipeable = true;
    } else {
      swipe_panel_default(panel);
    }
    return panel;
  }
  disableSwipe() {
    const panel = this;
    panel.swipeable = false;
    return panel;
  }
  onOpen(modifyHtmlClasses) {
    if (modifyHtmlClasses === void 0) {
      modifyHtmlClasses = true;
    }
    const panel = this;
    const app = panel.app;
    panel.opened = true;
    app.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeopen");
    panel.emit("local::beforeOpen panelBeforeOpen", panel);
    if (modifyHtmlClasses) {
      panel.setStateClasses("open");
    }
    panel.$el.trigger("panel:open");
    panel.emit("local::open panelOpen", panel);
  }
  onOpened() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.$el.trigger("panel:opened");
    panel.emit("local::opened panelOpened", panel);
  }
  onClose() {
    const panel = this;
    const app = panel.app;
    panel.opened = false;
    app.panel.allowOpen = false;
    panel.$el.trigger("panel:beforeclose");
    panel.emit("local::beforeClose panelBeforeClose", panel);
    panel.setStateClasses("closing");
    panel.$el.trigger("panel:close");
    panel.emit("local::close panelClose", panel);
  }
  onClosed() {
    const panel = this;
    const app = panel.app;
    app.panel.allowOpen = true;
    panel.setStateClasses("after-closing");
    panel.$el.removeClass("panel-out");
    if (panel.$backdropEl) {
      const otherPanel = app.panel.get(".panel-in");
      const shouldHideBackdrop = !otherPanel || otherPanel && !otherPanel.$backdropEl;
      if (shouldHideBackdrop) {
        panel.$backdropEl.removeClass("panel-backdrop-in");
      }
    }
    panel.$el.trigger("panel:closed");
    panel.emit("local::closed panelClosed", panel);
  }
  toggle(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const breakpoint = panel.params.visibleBreakpoint;
    const app = panel.app;
    if (app.width >= breakpoint && typeof breakpoint !== "undefined" && breakpoint !== null) {
      return panel.toggleVisibleBreakpoint();
    }
    if (panel.opened)
      panel.close(animate);
    else
      panel.open(animate);
    return panel;
  }
  insertToRoot() {
    const panel = this;
    const document = getDocument();
    const {
      $el,
      $backdropEl,
      $containerEl
    } = panel;
    const $panelParentEl = $el.parent();
    const wasInDom = $el.parents(document).length > 0;
    if (!$panelParentEl.is($containerEl) || $el.prevAll(".views, .view").length) {
      const $insertBeforeEl = $containerEl.children(".panel, .views, .view").eq(0);
      const $insertAfterEl = $containerEl.children(".panel-backdrop").eq(0);
      if ($insertBeforeEl.length) {
        $el.insertBefore($insertBeforeEl);
      } else if ($insertAfterEl) {
        $el.insertBefore($insertAfterEl);
      } else {
        $containerEl.prepend($el);
      }
      if ($backdropEl && $backdropEl.length && (!$backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0 || $backdropEl.parent().is($containerEl) && $backdropEl.nextAll(".panel").length === 0)) {
        $backdropEl.insertBefore($el);
      }
      panel.once("panelClosed", () => {
        if (wasInDom) {
          $panelParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
  }
  open(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const app = panel.app;
    if (!app.panel.allowOpen)
      return false;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!$el || $el.hasClass("panel-in")) {
      return panel;
    }
    panel.insertToRoot();
    if (opened || $el.hasClass("panel-in-breakpoint") || $el.hasClass("panel-in"))
      return false;
    const otherOpenedPanel = app.panel.get(".panel-in");
    if (otherOpenedPanel && otherOpenedPanel !== panel) {
      otherOpenedPanel.close(animate);
    }
    $el[animate ? "removeClass" : "addClass"]("not-animated");
    $el.addClass("panel-in");
    if ($backdropEl) {
      $backdropEl.addClass("panel-backdrop-in");
      $backdropEl[animate ? "removeClass" : "addClass"]("not-animated");
    }
    if (panel.effect === "cover" || panel.effect === "push") {
      panel._clientLeft = $el[0].clientLeft;
    }
    const $viewEl = dom7_default(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    function panelTransitionEnd() {
      transitionEndTarget.transitionEnd((e) => {
        if (dom7_default(e.target).is(transitionEndTarget)) {
          if ($el.hasClass("panel-out")) {
            panel.onClosed();
          } else {
            panel.onOpened();
          }
        } else
          panelTransitionEnd();
      });
    }
    if (animate) {
      if ($backdropEl) {
        $backdropEl.removeClass("not-animated");
      }
      panelTransitionEnd();
      $el.removeClass("panel-out not-animated").addClass("panel-in");
      panel.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass("not-animated");
      }
      $el.removeClass("panel-out").addClass("panel-in not-animated");
      panel.onOpen();
      panel.onOpened();
    }
    return true;
  }
  close(animate) {
    if (animate === void 0) {
      animate = true;
    }
    const panel = this;
    const {
      effect,
      $el,
      $backdropEl,
      opened,
      $containerEl
    } = panel;
    if (!opened || $el.hasClass("panel-in-breakpoint") || !$el.hasClass("panel-in"))
      return panel;
    $el[animate ? "removeClass" : "addClass"]("not-animated");
    if ($backdropEl) {
      $backdropEl[animate ? "removeClass" : "addClass"]("not-animated");
    }
    const $viewEl = dom7_default(panel.getViewEl());
    if ($containerEl && $containerEl.hasClass("page")) {
      $viewEl.add($containerEl.children(".page-content, .tabs"));
    }
    const transitionEndTarget = effect === "reveal" ? $viewEl : $el;
    function transitionEnd3() {
      if ($el.hasClass("panel-out")) {
        panel.onClosed();
      } else if ($el.hasClass("panel-in")) {
        panel.onOpened();
      }
      panel.setStateClasses("after-closing");
    }
    if (animate) {
      transitionEndTarget.transitionEnd(() => {
        transitionEnd3();
      });
      $el.removeClass("panel-in").addClass("panel-out");
      panel.onClose();
    } else {
      $el.addClass("not-animated").removeClass("panel-in").addClass("panel-out");
      panel.onClose();
      panel.onClosed();
    }
    return panel;
  }
  init() {
    const panel = this;
    if (typeof panel.params.visibleBreakpoint !== "undefined") {
      panel.setVisibleBreakpoint();
    }
    if (typeof panel.params.collapsedBreakpoint !== "undefined") {
      panel.setCollapsedBreakpoint();
    }
    if (panel.params.swipe) {
      panel.enableSwipe();
    }
    if (panel.resizable) {
      panel.enableResizable();
    }
  }
  destroy() {
    let panel = this;
    const app = panel.app;
    const {
      $containerEl
    } = panel;
    if (!panel.$el) {
      return;
    }
    panel.emit("local::beforeDestroy panelBeforeDestroy", panel);
    panel.$el.trigger("panel:beforedestroy");
    if (panel.visibleBreakpointResizeHandler) {
      app.off("resize", panel.visibleBreakpointResizeHandler);
    }
    if (panel.collapsedBreakpointResizeHandler) {
      app.off("resize", panel.collapsedBreakpointResizeHandler);
    }
    if (panel.$el.hasClass("panel-in-breakpoint") || panel.$el.hasClass("panel-in-collapsed")) {
      const $viewEl = dom7_default(panel.getViewEl());
      if ($containerEl && $containerEl.hasClass("page")) {
        $viewEl.add($containerEl.children(".page-content, .tabs"));
      }
      panel.$el.removeClass("panel-in-breakpoint panel-in-collapsed panel-in");
      $viewEl.css({
        [`margin-${panel.side}`]: ""
      });
      panel.emit("local::breakpoint panelBreakpoint", panel);
      panel.$el.trigger("panel:breakpoint");
    }
    panel.$el.trigger("panel:destroy");
    panel.emit("local::destroy panelDestroy", panel);
    if (panel.el) {
      panel.el.f7Panel = null;
      delete panel.el.f7Panel;
    }
    deleteProps(panel);
    panel = null;
  }
};
var panel_class_default = Panel;

// node_modules/framework7/components/panel/panel.js
var panel_default = {
  name: "panel",
  params: {
    panel: {
      opened: void 0,
      side: void 0,
      effect: void 0,
      resizable: void 0,
      backdrop: true,
      backdropEl: void 0,
      visibleBreakpoint: void 0,
      collapsedBreakpoint: void 0,
      swipe: false,
      swipeNoFollow: false,
      swipeOnlyClose: false,
      swipeActiveArea: 0,
      swipeThreshold: 0,
      closeByBackdropClick: true,
      containerEl: void 0
    }
  },
  static: {
    Panel: panel_class_default
  },
  create() {
    const app = this;
    extend(app, {
      panel: {
        allowOpen: true,
        create(params) {
          return new panel_class_default(app, params);
        },
        get(el) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el instanceof panel_class_default)
            return el;
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          const $el = dom7_default(el);
          if ($el.length === 0 || $el.length > 1)
            return void 0;
          return $el[0].f7Panel;
        },
        destroy(el) {
          if (el === void 0) {
            el = ".panel";
          }
          const panel = app.panel.get(el);
          if (panel && panel.destroy)
            return panel.destroy();
          return void 0;
        },
        open(el, animate) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.open)
            return panel.open(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.open(animate);
          }
          return void 0;
        },
        close(el, animate) {
          if (el === void 0) {
            el = ".panel-in";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.open)
            return panel.close(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.close(animate);
          }
          return void 0;
        },
        toggle(el, animate) {
          if (el === void 0) {
            el = ".panel";
          }
          if (el === "left" || el === "right")
            el = `.panel-${el}`;
          let panel = app.panel.get(el);
          if (panel && panel.toggle)
            return panel.toggle(animate);
          if (!panel) {
            panel = app.panel.create({
              el
            });
            return panel.toggle(animate);
          }
          return void 0;
        }
      }
    });
  },
  on: {
    init() {
      const app = this;
      dom7_default(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".panel-init").each((panelEl) => {
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy)
          panel.destroy();
      });
    }
  },
  vnode: {
    "panel-init": {
      insert(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const params = Object.assign({
          el: panelEl
        }, dom7_default(panelEl).dataset() || {});
        app.panel.create(params);
      },
      destroy(vnode) {
        const app = this;
        const panelEl = vnode.elm;
        const panel = app.panel.get(panelEl);
        if (panel && panel.destroy)
          panel.destroy();
      }
    }
  },
  clicks: {
    ".panel-open": function open2(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.open(data.panel, data.animate);
    },
    ".panel-close": function close(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.close(data.panel, data.animate);
    },
    ".panel-toggle": function close2(clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.panel.toggle(data.panel, data.animate);
    },
    ".panel-backdrop": function close3() {
      const app = this;
      const $panelEl = dom7_default(".panel-in:not(.panel-out)");
      if (!$panelEl.length)
        return;
      const instance = $panelEl[0] && $panelEl[0].f7Panel;
      $panelEl.trigger("panel:backdrop-click");
      if (instance) {
        instance.emit("backdropClick", instance);
      }
      app.emit("panelBackdropClick", instance || $panelEl[0]);
      if (instance && instance.params.closeByBackdropClick === false)
        return;
      if (app.params.panel.closeByBackdropClick)
        app.panel.close();
    }
  }
};

// node_modules/framework7/components/card/card.js
var CardExpandable = {
  open(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = ".card-expandable";
    }
    if (animate === void 0) {
      animate = true;
    }
    const app = this;
    const device = getDevice();
    const document = getDocument();
    const support2 = getSupport();
    const $cardEl = dom7_default(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length)
      return;
    if ($cardEl.hasClass("card-opened") || $cardEl.hasClass("card-opening") || $cardEl.hasClass("card-closing"))
      return;
    const $pageEl = $cardEl.parents(".page").eq(0);
    if (!$pageEl.length)
      return;
    if ($pageEl.find(".card-opened").length) {
      return;
    }
    let prevented;
    function prevent() {
      prevented = true;
    }
    $cardEl.trigger("card:beforeopen", {
      prevent
    });
    app.emit("cardBeforeOpen", $cardEl[0], prevent);
    if (prevented)
      return;
    const cardParams = Object.assign({
      animate
    }, app.params.card, $cardEl.dataset());
    const $pageContentEl = $cardEl.parents(".page-content");
    let $backdropEl;
    if ($cardEl.attr("data-backdrop-el")) {
      $backdropEl = dom7_default($cardEl.attr("data-backdrop-el"));
    }
    if (!$backdropEl && cardParams.backdrop) {
      $backdropEl = $pageContentEl.find(".card-backdrop");
      if (!$backdropEl.length) {
        $backdropEl = dom7_default('<div class="card-backdrop"></div>');
        $pageContentEl.append($backdropEl);
      }
    }
    let $navbarEl;
    let $toolbarEl;
    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children(".navbar");
      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page)
          $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
    }
    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children(".toolbar");
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".view").children(".toolbar");
      }
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".views").children(".toolbar");
      }
    }
    const currTransform = $cardEl.css("transform");
    let hasTransform;
    if (currTransform && currTransform.match(/[2-9]/)) {
      hasTransform = true;
    }
    const $cardContentEl = $cardEl.children(".card-content");
    const $cardSizeEl = dom7_default(document.createElement("div")).addClass("card-expandable-size");
    $cardEl.append($cardSizeEl);
    let cardWidth = $cardEl[0].offsetWidth;
    let cardHeight = $cardEl[0].offsetHeight;
    let pageWidth = $pageEl[0].offsetWidth;
    let pageHeight = $pageEl[0].offsetHeight;
    let maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
    let maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
    let statusbarHeight;
    if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
      statusbarHeight = parseInt($navbarEl.css("--f7-safe-area-top"), 10);
      if (Number.isNaN(statusbarHeight))
        statusbarHeight = 0;
    }
    if (statusbarHeight) {
      maxHeight -= statusbarHeight;
    }
    let scaleX = maxWidth / cardWidth;
    let scaleY = maxHeight / cardHeight;
    let offset2 = $cardEl.offset();
    let pageOffset = $pageEl.offset();
    if (statusbarHeight) {
      pageOffset.top += statusbarHeight / 2;
    }
    offset2.left -= pageOffset.left;
    let cardLeftOffset;
    let cardTopOffset;
    if (hasTransform) {
      const transformValues = currTransform.replace(/matrix\(|\)/g, "").split(",").map((el) => el.trim());
      if (transformValues && transformValues.length > 1) {
        const scale = parseFloat(transformValues[0]);
        cardLeftOffset = offset2.left - cardWidth * (1 - scale) / 2;
        cardTopOffset = offset2.top - pageOffset.top - cardHeight * (1 - scale) / 2;
        if (app.rtl)
          cardLeftOffset -= $cardEl[0].scrollLeft;
      } else {
        cardLeftOffset = $cardEl[0].offsetLeft;
        cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
      }
    } else {
      cardLeftOffset = offset2.left;
      cardTopOffset = offset2.top - pageOffset.top;
      if (app.rtl)
        cardLeftOffset -= $cardEl[0].scrollLeft;
    }
    cardLeftOffset -= (pageWidth - maxWidth) / 2;
    cardTopOffset -= (pageHeight - maxHeight) / 2;
    let cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
    if (app.rtl) {
      [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
    }
    let cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
    let translateX = (cardRightOffset - cardLeftOffset) / 2;
    let translateY = (cardBottomOffset - cardTopOffset) / 2;
    if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
      if ($navbarEl.closest(".navbar-hidden").length) {
        $cardEl[0].f7KeepNavbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepNavbarOnClose;
        app.navbar.hide($navbarEl, cardParams.animate, cardParams.hideStatusbarOnOpen, true);
      }
    }
    if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
      if ($toolbarEl.closest(".toolbar-hidden").length) {
        $cardEl[0].f7KeepToolbarOnClose = true;
      } else {
        delete $cardEl[0].f7KeepToolbarOnClose;
        app.toolbar.hide($toolbarEl, cardParams.animate);
      }
    }
    if ($backdropEl) {
      $backdropEl.removeClass("card-backdrop-out").addClass("card-backdrop-in");
    }
    $cardEl.removeClass("card-transitioning");
    if (cardParams.animate) {
      $cardEl.addClass("card-opening");
    }
    $cardEl.trigger("card:open");
    app.emit("cardOpen", $cardEl[0]);
    function transitionEnd3() {
      $pageEl.addClass("page-with-card-opened");
      if (device.ios && $pageContentEl.length) {
        $pageContentEl.css("height", `${$pageContentEl[0].offsetHeight + 1}px`);
        setTimeout(() => {
          $pageContentEl.css("height", "");
        });
      }
      $cardEl.addClass("card-opened");
      $cardEl.removeClass("card-opening");
      $cardEl.trigger("card:opened");
      app.emit("cardOpened", $cardEl[0], $pageEl[0]);
    }
    $cardContentEl.css({
      width: `${maxWidth}px`,
      height: `${maxHeight}px`
    }).transform(`translate3d(${app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
    if (cardParams.animate) {
      $cardEl.transitionEnd(() => {
        transitionEnd3();
      });
    } else {
      transitionEnd3();
    }
    function onResize2() {
      $cardEl.removeClass("card-transitioning");
      cardWidth = $cardEl[0].offsetWidth;
      cardHeight = $cardEl[0].offsetHeight;
      pageWidth = $pageEl[0].offsetWidth;
      pageHeight = $pageEl[0].offsetHeight;
      maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
      maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;
      statusbarHeight = 0;
      if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
        statusbarHeight = parseInt($navbarEl.css("--f7-safe-area-top"), 10);
        if (Number.isNaN(statusbarHeight))
          statusbarHeight = 0;
      }
      if (statusbarHeight) {
        maxHeight -= statusbarHeight;
      }
      scaleX = maxWidth / cardWidth;
      scaleY = maxHeight / cardHeight;
      $cardEl.transform("translate3d(0px, 0px, 0) scale(1)");
      offset2 = $cardEl.offset();
      pageOffset = $pageEl.offset();
      if (statusbarHeight) {
        pageOffset.top += statusbarHeight / 2;
      }
      offset2.left -= pageOffset.left;
      offset2.top -= pageOffset.top;
      cardLeftOffset = offset2.left - (pageWidth - maxWidth) / 2;
      if (app.rtl)
        cardLeftOffset -= $cardEl[0].scrollLeft;
      cardTopOffset = offset2.top - (pageHeight - maxHeight) / 2;
      cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
      cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
      if (app.rtl) {
        [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
      }
      translateX = (cardRightOffset - cardLeftOffset) / 2;
      translateY = (cardBottomOffset - cardTopOffset) / 2;
      $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      $cardContentEl.css({
        width: `${maxWidth}px`,
        height: `${maxHeight}px`
      }).transform(`translate3d(${app.rtl ? cardLeftOffset + translateX : -cardLeftOffset - translateX}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
    }
    let cardScrollTop;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchEndX;
    let touchEndY;
    let isScrolling;
    let progress;
    let isV;
    let isH;
    let $cardScrollableEl;
    function onTouchStart2(e) {
      if (!dom7_default(e.target).closest($cardEl).length)
        return;
      if (!$cardEl.hasClass("card-opened"))
        return;
      $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);
      if ($cardScrollableEl[0] && $cardScrollableEl[0] !== $cardContentEl[0] && !$cardScrollableEl[0].contains(e.target)) {
        cardScrollTop = 0;
      } else {
        cardScrollTop = $cardScrollableEl.scrollTop();
      }
      isTouched = true;
      touchStartX = e.targetTouches[0].pageX;
      touchStartY = e.targetTouches[0].pageY;
      isScrolling = void 0;
      isV = false;
      isH = false;
    }
    function onTouchMove2(e) {
      if (!isTouched)
        return;
      touchEndX = e.targetTouches[0].pageX;
      touchEndY = e.targetTouches[0].pageY;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
      }
      if (!isH && !isV) {
        if (!isScrolling && e.targetTouches[0].clientX <= 50) {
          isH = true;
        } else {
          isV = true;
        }
      }
      if (!(isH || isV) || isV && cardScrollTop !== 0) {
        isTouched = true;
        isMoved = true;
        return;
      }
      if (!isMoved) {
        $cardEl.removeClass("card-transitioning");
      }
      isMoved = true;
      progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);
      if (progress > 0 && isV || isH) {
        if (isV && device.ios && $cardScrollableEl[0] === $cardContentEl[0]) {
          $cardScrollableEl.css("-webkit-overflow-scrolling", "auto");
          $cardScrollableEl.scrollTop(0);
        }
        e.preventDefault();
      }
      if (progress > 1)
        progress **= 0.3;
      if (progress > (isV ? 1.3 : 1.1)) {
        isTouched = false;
        isMoved = false;
        app.card.close($cardEl);
      } else {
        $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX * (1 - progress * 0.2)}, ${scaleY * (1 - progress * 0.2)})`);
      }
    }
    function onTouchEnd2() {
      if (!isTouched || !isMoved)
        return;
      isTouched = false;
      isMoved = false;
      if (device.ios) {
        $cardScrollableEl.css("-webkit-overflow-scrolling", "");
      }
      if (progress >= 0.8) {
        app.card.close($cardEl);
      } else {
        $cardEl.addClass("card-transitioning").transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      }
    }
    $cardEl[0].detachEventHandlers = function detachEventHandlers() {
      app.off("resize", onResize2);
      if (support2.touch && cardParams.swipeToClose) {
        app.off("touchstart:passive", onTouchStart2);
        app.off("touchmove:active", onTouchMove2);
        app.off("touchend:passive", onTouchEnd2);
      }
    };
    app.on("resize", onResize2);
    if (support2.touch && cardParams.swipeToClose) {
      app.on("touchstart:passive", onTouchStart2);
      app.on("touchmove:active", onTouchMove2);
      app.on("touchend:passive", onTouchEnd2);
    }
  },
  close(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = ".card-expandable.card-opened";
    }
    if (animate === void 0) {
      animate = true;
    }
    const app = this;
    const device = getDevice();
    const $cardEl = dom7_default(cardEl).eq(0);
    if (!$cardEl || !$cardEl.length)
      return;
    if (!$cardEl.hasClass("card-opened") || $cardEl.hasClass("card-opening") || $cardEl.hasClass("card-closing"))
      return;
    const $cardContentEl = $cardEl.children(".card-content");
    const $pageContentEl = $cardEl.parents(".page-content");
    const $pageEl = $cardEl.parents(".page").eq(0);
    if (!$pageEl.length)
      return;
    const cardParams = Object.assign({
      animate
    }, app.params.card, $cardEl.dataset());
    const $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);
    let $navbarEl;
    let $toolbarEl;
    let $backdropEl;
    if ($cardEl.attr("data-backdrop-el")) {
      $backdropEl = dom7_default($cardEl.attr("data-backdrop-el"));
    }
    if (cardParams.backdrop) {
      $backdropEl = $cardEl.parents(".page-content").find(".card-backdrop");
    }
    if (cardParams.hideNavbarOnOpen) {
      $navbarEl = $pageEl.children(".navbar");
      if (!$navbarEl.length) {
        if ($pageEl[0].f7Page)
          $navbarEl = $pageEl[0].f7Page.$navbarEl;
      }
      if ($navbarEl && $navbarEl.length && !$cardEl[0].f7KeepNavbarOnClose) {
        app.navbar.show($navbarEl, cardParams.animate, true);
      }
    }
    if (cardParams.hideToolbarOnOpen) {
      $toolbarEl = $pageEl.children(".toolbar");
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".view").children(".toolbar");
      }
      if (!$toolbarEl.length) {
        $toolbarEl = $pageEl.parents(".views").children(".toolbar");
      }
      if ($toolbarEl && $toolbarEl.length && !$cardEl[0].f7KeepToolbarOnClose) {
        app.toolbar.show($toolbarEl, cardParams.animate);
      }
    }
    $pageEl.removeClass("page-with-card-opened");
    if (device.ios && $pageContentEl.length) {
      $pageContentEl.css("height", `${$pageContentEl[0].offsetHeight + 1}px`);
      setTimeout(() => {
        $pageContentEl.css("height", "");
      });
    }
    if ($backdropEl && $backdropEl.length) {
      $backdropEl.removeClass("card-backdrop-in").addClass("card-backdrop-out");
    }
    $cardEl.removeClass("card-opened card-transitioning");
    if (cardParams.animate) {
      $cardEl.addClass("card-closing");
    } else {
      $cardEl.addClass("card-no-transition");
    }
    $cardEl.transform("");
    $cardEl.trigger("card:close");
    app.emit("cardClose", $cardEl[0], $pageEl[0]);
    const animateWidth = $cardEl.hasClass("card-expandable-animate-width");
    function transitionEnd3() {
      if (!animateWidth) {
        $cardContentEl.css({
          width: "",
          height: ""
        });
      }
      if ($backdropEl && $backdropEl.length) {
        $backdropEl.removeClass("card-backdrop-in card-backdrop-out");
      }
      $cardEl.removeClass("card-closing card-no-transition");
      $cardEl.trigger("card:closed");
      $cardEl.find(".card-expandable-size").remove();
      app.emit("cardClosed", $cardEl[0], $pageEl[0]);
    }
    if (animateWidth) {
      $cardContentEl.css({
        width: "",
        height: ""
      });
    }
    $cardContentEl.transform("").scrollTop(0, animate ? 300 : 0);
    if ($cardScrollableEl.length && $cardScrollableEl[0] !== $cardContentEl[0]) {
      $cardScrollableEl.scrollTop(0, animate ? 300 : 0);
    }
    if (animate) {
      $cardContentEl.transitionEnd(() => {
        transitionEnd3();
      });
    } else {
      transitionEnd3();
    }
    if ($cardEl[0].detachEventHandlers) {
      $cardEl[0].detachEventHandlers();
      delete $cardEl[0].detachEventHandlers;
    }
  },
  toggle(cardEl, animate) {
    if (cardEl === void 0) {
      cardEl = ".card-expandable";
    }
    const app = this;
    const $cardEl = dom7_default(cardEl).eq(0);
    if (!$cardEl.length)
      return;
    if ($cardEl.hasClass("card-opened")) {
      app.card.close($cardEl, animate);
    } else {
      app.card.open($cardEl, animate);
    }
  }
};
var card_default = {
  name: "card",
  params: {
    card: {
      hideNavbarOnOpen: true,
      hideStatusbarOnOpen: true,
      hideToolbarOnOpen: true,
      scrollableEl: ".card-content",
      swipeToClose: true,
      closeByBackdropClick: true,
      backdrop: true
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      card: CardExpandable
    });
  },
  on: {
    pageBeforeIn(page) {
      const app = this;
      if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find(".card-opened.card-expandable").length) {
        app.navbar.hide(page.navbarEl, true, app.params.card.hideStatusbarOnOpen, true);
      }
      if (app.params.card.hideToolbarOnOpen && page.$el.find(".card-opened.card-expandable").length) {
        let $toolbarEl = page.$el.children(".toolbar");
        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents(".view").children(".toolbar");
        }
        if (!$toolbarEl.length) {
          $toolbarEl = page.$el.parents(".views").children(".toolbar");
        }
        if ($toolbarEl && $toolbarEl.length) {
          app.toolbar.hide($toolbarEl);
        }
      }
    }
  },
  clicks: {
    ".card-close": function closeCard($clickedEl, data) {
      const app = this;
      app.card.close(data.card, data.animate);
    },
    ".card-open": function closeCard2($clickedEl, data) {
      const app = this;
      app.card.open(data.card, data.animate);
    },
    ".card-expandable": function toggleExpandableCard($clickedEl, data, e) {
      const app = this;
      if ($clickedEl.hasClass("card-opened") || $clickedEl.hasClass("card-opening") || $clickedEl.hasClass("card-closing"))
        return;
      if (dom7_default(e.target).closest(".card-prevent-open, .card-close").length)
        return;
      app.card.open($clickedEl);
    },
    ".card-backdrop-in": function onBackdropClick() {
      const app = this;
      let needToClose = false;
      if (app.params.card.closeByBackdropClick)
        needToClose = true;
      const $openedCardEl = dom7_default(".card-opened");
      if (!$openedCardEl.length)
        return;
      if ($openedCardEl.attr("data-close-by-backdrop-click") === "true") {
        needToClose = true;
      } else if ($openedCardEl.attr("data-close-by-backdrop-click") === "false") {
        needToClose = false;
      }
      if (needToClose)
        app.card.close($openedCardEl);
    }
  }
};

// node_modules/framework7/components/chip/chip.js
var chip_default = {
  name: "chip"
};

// node_modules/framework7/components/form/form.js
var FormData = {
  store(form, data) {
    const app = this;
    const window2 = getWindow();
    let formId = form;
    const $formEl = dom7_default(form);
    if ($formEl.length && $formEl.is("form") && $formEl.attr("id")) {
      formId = $formEl.attr("id");
    }
    app.form.data[`form-${formId}`] = data;
    window2.localStorage[`f7form-${formId}`] = JSON.stringify(data);
  },
  get(form) {
    const app = this;
    const window2 = getWindow();
    let formId = form;
    const $formEl = dom7_default(form);
    if ($formEl.length && $formEl.is("form") && $formEl.attr("id")) {
      formId = $formEl.attr("id");
    }
    if (window2.localStorage[`f7form-${formId}`]) {
      return JSON.parse(window2.localStorage[`f7form-${formId}`]);
    }
    if (app.form.data[`form-${formId}`]) {
      return app.form.data[`form-${formId}`];
    }
    return void 0;
  },
  remove(form) {
    const app = this;
    const window2 = getWindow();
    let formId = form;
    const $formEl = dom7_default(form);
    if ($formEl.length && $formEl.is("form") && $formEl.attr("id")) {
      formId = $formEl.attr("id");
    }
    if (app.form.data[`form-${formId}`]) {
      app.form.data[`form-${formId}`] = "";
      delete app.form.data[`form-${formId}`];
    }
    if (window2.localStorage[`f7form-${formId}`]) {
      window2.localStorage[`f7form-${formId}`] = "";
      window2.localStorage.removeItem(`f7form-${formId}`);
    }
  }
};
var FormStorage = {
  init(formEl) {
    const app = this;
    const $formEl = dom7_default(formEl);
    const formId = $formEl.attr("id");
    if (!formId)
      return;
    const initialData = app.form.getFormData(formId);
    if (initialData) {
      app.form.fillFromData($formEl, initialData);
    }
    function store() {
      const data = app.form.convertToData($formEl);
      if (!data)
        return;
      app.form.storeFormData(formId, data);
      $formEl.trigger("form:storedata", data);
      app.emit("formStoreData", $formEl[0], data);
    }
    $formEl.on("change submit", store);
  },
  destroy(formEl) {
    const $formEl = dom7_default(formEl);
    $formEl.off("change submit");
  }
};
function formToData(formEl) {
  const app = this;
  const $formEl = dom7_default(formEl).eq(0);
  if ($formEl.length === 0)
    return void 0;
  const data = {};
  const skipTypes = ["submit", "image", "button", "file"];
  const skipNames = [];
  $formEl.find("input, select, textarea").each((inputEl) => {
    const $inputEl = dom7_default(inputEl);
    if ($inputEl.hasClass("ignore-store-data") || $inputEl.hasClass("no-store-data")) {
      return;
    }
    const name = $inputEl.attr("name");
    const type = $inputEl.attr("type");
    const tag = inputEl.nodeName.toLowerCase();
    if (skipTypes.indexOf(type) >= 0)
      return;
    if (skipNames.indexOf(name) >= 0 || !name)
      return;
    if (tag === "select" && $inputEl.prop("multiple")) {
      skipNames.push(name);
      data[name] = [];
      $formEl.find(`select[name="${name}"] option`).each((el) => {
        if (el.selected)
          data[name].push(el.value);
      });
    } else {
      switch (type) {
        case "checkbox":
          skipNames.push(name);
          data[name] = [];
          $formEl.find(`input[name="${name}"]`).each((el) => {
            if (el.checked)
              data[name].push(el.value);
          });
          break;
        case "radio":
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((el) => {
            if (el.checked)
              data[name] = el.value;
          });
          break;
        default:
          data[name] = $inputEl.val();
          break;
      }
    }
  });
  $formEl.trigger("form:todata", data);
  app.emit("formToData", $formEl[0], data);
  return data;
}
function formFromData(formEl, formData) {
  const app = this;
  const $formEl = dom7_default(formEl).eq(0);
  if (!$formEl.length)
    return;
  let data = formData;
  const formId = $formEl.attr("id");
  if (!data && formId) {
    data = app.form.getFormData(formId);
  }
  if (!data)
    return;
  const skipTypes = ["submit", "image", "button", "file"];
  const skipNames = [];
  $formEl.find("input, select, textarea").each((inputEl) => {
    const $inputEl = dom7_default(inputEl);
    if ($inputEl.hasClass("ignore-store-data") || $inputEl.hasClass("no-store-data")) {
      return;
    }
    const name = $inputEl.attr("name");
    const type = $inputEl.attr("type");
    const tag = inputEl.nodeName.toLowerCase();
    if (typeof data[name] === "undefined" || data[name] === null)
      return;
    if (skipTypes.indexOf(type) >= 0)
      return;
    if (skipNames.indexOf(name) >= 0 || !name)
      return;
    if (tag === "select" && $inputEl.prop("multiple")) {
      skipNames.push(name);
      $formEl.find(`select[name="${name}"] option`).each((el) => {
        const selectEl = el;
        if (data[name].indexOf(el.value) >= 0)
          selectEl.selected = true;
        else
          selectEl.selected = false;
      });
    } else {
      switch (type) {
        case "checkbox":
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((el) => {
            const checkboxEl = el;
            if (data[name].indexOf(el.value) >= 0)
              checkboxEl.checked = true;
            else
              checkboxEl.checked = false;
          });
          break;
        case "radio":
          skipNames.push(name);
          $formEl.find(`input[name="${name}"]`).each((el) => {
            const radioEl = el;
            if (data[name] === el.value)
              radioEl.checked = true;
            else
              radioEl.checked = false;
          });
          break;
        default:
          $inputEl.val(data[name]);
          break;
      }
    }
    if (tag === "select" || tag === "input" || tag === "textarea") {
      $inputEl.trigger("change", "fromdata");
    }
  });
  $formEl.trigger("form:fromdata", data);
  app.emit("formFromData", $formEl[0], data);
}
function initAjaxForm() {
  const app = this;
  const window2 = getWindow();
  const document = getDocument();
  function onSubmitChange(e, fromData) {
    const $formEl = dom7_default(this);
    if (e.type === "change" && !$formEl.hasClass("form-ajax-submit-onchange"))
      return;
    if (e.type === "submit")
      e.preventDefault();
    if (e.type === "change" && fromData === "fromdata")
      return;
    const method = ($formEl.attr("method") || "GET").toUpperCase();
    const contentType = $formEl.prop("enctype") || $formEl.attr("enctype");
    const url = $formEl.attr("action");
    if (!url)
      return;
    let data;
    if (method === "POST") {
      if (contentType === "application/x-www-form-urlencoded") {
        data = app.form.convertToData($formEl[0]);
      } else {
        data = new window2.FormData($formEl[0]);
      }
    } else {
      data = serializeObject(app.form.convertToData($formEl[0]));
    }
    app.request({
      method,
      url,
      contentType,
      data,
      beforeSend(xhr) {
        $formEl.trigger("formajax:beforesend", {
          data,
          xhr
        });
        app.emit("formAjaxBeforeSend", $formEl[0], data, xhr);
      },
      error(xhr) {
        $formEl.trigger("formajax:error", {
          data,
          xhr
        });
        app.emit("formAjaxError", $formEl[0], data, xhr);
      },
      complete(xhr) {
        $formEl.trigger("formajax:complete", {
          data,
          xhr
        });
        app.emit("formAjaxComplete", $formEl[0], data, xhr);
      },
      success(response, status, xhr) {
        $formEl.trigger("formajax:success", {
          data,
          xhr
        });
        app.emit("formAjaxSuccess", $formEl[0], data, xhr);
      }
    });
  }
  dom7_default(document).on("submit change", "form.form-ajax-submit, form.form-ajax-submit-onchange", onSubmitChange);
}
var form_default = {
  name: "form",
  create() {
    const app = this;
    extend(app, {
      form: {
        data: {},
        storeFormData: FormData.store.bind(app),
        getFormData: FormData.get.bind(app),
        removeFormData: FormData.remove.bind(app),
        convertToData: formToData.bind(app),
        fillFromData: formFromData.bind(app),
        storage: {
          init: FormStorage.init.bind(app),
          destroy: FormStorage.destroy.bind(app)
        }
      }
    });
  },
  on: {
    init() {
      const app = this;
      initAjaxForm.call(app);
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".form-store-data").each((formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".form-store-data").each((formEl) => {
        app.form.storage.init(formEl);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".form-store-data").each((formEl) => {
        app.form.storage.destroy(formEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".form-store-data").each((formEl) => {
        app.form.storage.init(formEl);
      });
    }
  }
};

// node_modules/framework7/components/input/input.js
var Input = {
  ignoreTypes: ["checkbox", "button", "submit", "range", "radio", "image"],
  createTextareaResizableShadow() {
    const document = getDocument();
    const $shadowEl = dom7_default(document.createElement("textarea"));
    $shadowEl.addClass("textarea-resizable-shadow");
    $shadowEl.prop({
      disabled: true,
      readonly: true
    });
    Input.textareaResizableShadow = $shadowEl;
  },
  textareaResizableShadow: void 0,
  resizeTextarea(textareaEl) {
    const app = this;
    const window2 = getWindow();
    const $textareaEl = dom7_default(textareaEl);
    if (!Input.textareaResizableShadow) {
      Input.createTextareaResizableShadow();
    }
    const $shadowEl = Input.textareaResizableShadow;
    if (!$textareaEl.length)
      return;
    if (!$textareaEl.hasClass("resizable"))
      return;
    if (Input.textareaResizableShadow.parents().length === 0) {
      app.$el.append($shadowEl);
    }
    const styles2 = window2.getComputedStyle($textareaEl[0]);
    "padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display".split(" ").forEach((style) => {
      let styleValue = styles2[style];
      if ("font-size line-height letter-spacing width".split(" ").indexOf(style) >= 0) {
        styleValue = styleValue.replace(",", ".");
      }
      $shadowEl.css(style, styleValue);
    });
    const currentHeight = $textareaEl[0].clientHeight;
    $shadowEl.val("");
    const initialHeight = $shadowEl[0].scrollHeight;
    $shadowEl.val($textareaEl.val());
    $shadowEl.css("height", 0);
    const scrollHeight = $shadowEl[0].scrollHeight;
    if (currentHeight !== scrollHeight) {
      if (scrollHeight > initialHeight) {
        $textareaEl.css("height", `${scrollHeight}px`);
      } else if (scrollHeight < currentHeight) {
        $textareaEl.css("height", "");
      }
      if (scrollHeight > initialHeight || scrollHeight < currentHeight) {
        $textareaEl.trigger("textarea:resize", {
          initialHeight,
          currentHeight,
          scrollHeight
        });
        app.emit("textareaResize", {
          initialHeight,
          currentHeight,
          scrollHeight
        });
      }
    }
  },
  validate(inputEl) {
    const $inputEl = dom7_default(inputEl);
    if (!$inputEl.length)
      return true;
    const $itemInputEl = $inputEl.parents(".item-input");
    const $inputWrapEl = $inputEl.parents(".input");
    function unsetReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = false;
      }
    }
    function setReadonly() {
      if ($inputEl[0].f7ValidateReadonly) {
        $inputEl[0].readOnly = true;
      }
    }
    unsetReadonly();
    const validity = $inputEl[0].validity;
    const validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || "";
    if (!validity) {
      setReadonly();
      return true;
    }
    if (!validity.valid) {
      let $errorEl = $inputEl.nextAll(".item-input-error-message, .input-error-message");
      if (validationMessage) {
        if ($errorEl.length === 0) {
          $errorEl = dom7_default(`<div class="${$inputWrapEl.length ? "input-error-message" : "item-input-error-message"}"></div>`);
          $errorEl.insertAfter($inputEl);
        }
        $errorEl.text(validationMessage);
      }
      if ($errorEl.length > 0) {
        $itemInputEl.addClass("item-input-with-error-message");
        $inputWrapEl.addClass("input-with-error-message");
      }
      $itemInputEl.addClass("item-input-invalid");
      $inputWrapEl.addClass("input-invalid");
      $inputEl.addClass("input-invalid");
      setReadonly();
      return false;
    }
    $itemInputEl.removeClass("item-input-invalid item-input-with-error-message");
    $inputWrapEl.removeClass("input-invalid input-with-error-message");
    $inputEl.removeClass("input-invalid");
    setReadonly();
    return true;
  },
  validateInputs(el) {
    const app = this;
    const validates = dom7_default(el).find("input, textarea, select").map((inputEl) => app.input.validate(inputEl));
    return validates.indexOf(false) < 0;
  },
  focus(inputEl) {
    const $inputEl = dom7_default(inputEl);
    const type = $inputEl.attr("type");
    if (Input.ignoreTypes.indexOf(type) >= 0)
      return;
    $inputEl.parents(".item-input").addClass("item-input-focused");
    $inputEl.parents(".input").addClass("input-focused");
    $inputEl.addClass("input-focused");
  },
  blur(inputEl) {
    const $inputEl = dom7_default(inputEl);
    $inputEl.parents(".item-input").removeClass("item-input-focused");
    $inputEl.parents(".input").removeClass("input-focused");
    $inputEl.removeClass("input-focused");
  },
  checkEmptyState(inputEl) {
    const app = this;
    let $inputEl = dom7_default(inputEl);
    if (!$inputEl.is("input, select, textarea, .item-input [contenteditable]")) {
      $inputEl = $inputEl.find("input, select, textarea, .item-input [contenteditable]").eq(0);
    }
    if (!$inputEl.length)
      return;
    const isContentEditable = $inputEl[0].hasAttribute("contenteditable");
    let value;
    if (isContentEditable) {
      if ($inputEl.find(".text-editor-placeholder").length)
        value = "";
      else
        value = $inputEl.html();
    } else {
      value = $inputEl.val();
    }
    const $itemInputEl = $inputEl.parents(".item-input");
    const $inputWrapEl = $inputEl.parents(".input");
    if (value && typeof value === "string" && value.trim() !== "" || Array.isArray(value) && value.length > 0) {
      $itemInputEl.addClass("item-input-with-value");
      $inputWrapEl.addClass("input-with-value");
      $inputEl.addClass("input-with-value");
      $inputEl.trigger("input:notempty");
      app.emit("inputNotEmpty", $inputEl[0]);
    } else {
      $itemInputEl.removeClass("item-input-with-value");
      $inputWrapEl.removeClass("input-with-value");
      $inputEl.removeClass("input-with-value");
      $inputEl.trigger("input:empty");
      app.emit("inputEmpty", $inputEl[0]);
    }
  },
  scrollIntoView(inputEl, duration, centered, force) {
    if (duration === void 0) {
      duration = 0;
    }
    const $inputEl = dom7_default(inputEl);
    const $scrollableEl = $inputEl.parents(".page-content, .panel, .card-expandable .card-content").eq(0);
    if (!$scrollableEl.length) {
      return false;
    }
    const contentHeight = $scrollableEl[0].offsetHeight;
    const contentScrollTop = $scrollableEl[0].scrollTop;
    const contentPaddingTop = parseInt($scrollableEl.css("padding-top"), 10);
    const contentPaddingBottom = parseInt($scrollableEl.css("padding-bottom"), 10);
    const contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;
    const inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
    const inputHeight = $inputEl[0].offsetHeight;
    const min = inputOffsetTop + contentScrollTop - contentPaddingTop;
    const max = inputOffsetTop + contentScrollTop - contentHeight + contentPaddingBottom + inputHeight;
    const centeredPosition = min + (max - min) / 2;
    if (contentScrollTop > min) {
      $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
      return true;
    }
    if (contentScrollTop < max) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
      return true;
    }
    if (force) {
      $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
    }
    return false;
  },
  init() {
    const app = this;
    const device = getDevice();
    const window2 = getWindow();
    const document = getDocument();
    Input.createTextareaResizableShadow();
    function onFocus() {
      const inputEl = this;
      if (app.params.input.scrollIntoViewOnFocus) {
        if (device.android) {
          dom7_default(window2).once("resize", () => {
            if (document && document.activeElement === inputEl) {
              app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
            }
          });
        } else {
          app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
        }
      }
      app.input.focus(inputEl);
    }
    function onBlur() {
      const $inputEl = dom7_default(this);
      const tag = $inputEl[0].nodeName.toLowerCase();
      app.input.blur($inputEl);
      if ($inputEl.dataset().validate || $inputEl.attr("validate") !== null || $inputEl.attr("data-validate-on-blur") !== null) {
        app.input.validate($inputEl);
      }
      if (tag === "textarea" && $inputEl.hasClass("resizable")) {
        if (Input.textareaResizableShadow)
          Input.textareaResizableShadow.remove();
      }
    }
    function onChange() {
      const $inputEl = dom7_default(this);
      const type = $inputEl.attr("type");
      const tag = $inputEl[0].nodeName.toLowerCase();
      const isContentEditable = $inputEl[0].hasAttribute("contenteditable");
      if (Input.ignoreTypes.indexOf(type) >= 0)
        return;
      app.input.checkEmptyState($inputEl);
      if (isContentEditable)
        return;
      if ($inputEl.attr("data-validate-on-blur") === null && ($inputEl.dataset().validate || $inputEl.attr("validate") !== null)) {
        app.input.validate($inputEl);
      }
      if (tag === "textarea" && $inputEl.hasClass("resizable")) {
        app.input.resizeTextarea($inputEl);
      }
    }
    function onInvalid(e) {
      const $inputEl = dom7_default(this);
      if ($inputEl.attr("data-validate-on-blur") === null && ($inputEl.dataset().validate || $inputEl.attr("validate") !== null)) {
        e.preventDefault();
        app.input.validate($inputEl);
      }
    }
    function clearInput() {
      const $clicked = dom7_default(this);
      const $inputEl = $clicked.siblings("input, textarea").eq(0);
      const previousValue = $inputEl.val();
      $inputEl.val("").trigger("input change").focus().trigger("input:clear", previousValue);
      app.emit("inputClear", previousValue);
    }
    function preventDefault(e) {
      e.preventDefault();
    }
    dom7_default(document).on("click", ".input-clear-button", clearInput);
    dom7_default(document).on("mousedown", ".input-clear-button", preventDefault);
    dom7_default(document).on("change input", "input, textarea, select, .item-input [contenteditable]", onChange, true);
    dom7_default(document).on("focus", "input, textarea, select, .item-input [contenteditable]", onFocus, true);
    dom7_default(document).on("blur", "input, textarea, select, .item-input [contenteditable]", onBlur, true);
    dom7_default(document).on("invalid", "input, textarea, select", onInvalid, true);
  }
};
var input_default = {
  name: "input",
  params: {
    input: {
      scrollIntoViewOnFocus: void 0,
      scrollIntoViewCentered: false,
      scrollIntoViewDuration: 0,
      scrollIntoViewAlways: false
    }
  },
  create() {
    const app = this;
    if (typeof app.params.input.scrollIntoViewOnFocus === "undefined") {
      app.params.input.scrollIntoViewOnFocus = getDevice().android;
    }
    bindMethods(app, {
      input: Input
    });
  },
  on: {
    init() {
      const app = this;
      app.input.init();
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      $tabEl.find(".item-input, .input").each((itemInputEl) => {
        const $itemInputEl = dom7_default(itemInputEl);
        $itemInputEl.find("input, select, textarea, [contenteditable]").each((inputEl) => {
          const $inputEl = dom7_default(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr("type")) >= 0)
            return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $tabEl.find("textarea.resizable").each((textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    pageInit(page) {
      const app = this;
      const $pageEl = page.$el;
      $pageEl.find(".item-input, .input").each((itemInputEl) => {
        const $itemInputEl = dom7_default(itemInputEl);
        $itemInputEl.find("input, select, textarea, [contenteditable]").each((inputEl) => {
          const $inputEl = dom7_default(inputEl);
          if (Input.ignoreTypes.indexOf($inputEl.attr("type")) >= 0)
            return;
          app.input.checkEmptyState($inputEl);
        });
      });
      $pageEl.find("textarea.resizable").each((textareaEl) => {
        app.input.resizeTextarea(textareaEl);
      });
    },
    "panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint": function onPanelOpen(instance) {
      const app = this;
      if (instance && instance.$el) {
        instance.$el.find("textarea.resizable").each((textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      } else {
        dom7_default("textarea.resizable").each((textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      }
    }
  }
};

// node_modules/framework7/components/checkbox/checkbox.js
var checkbox_default = {
  name: "checkbox"
};

// node_modules/framework7/components/radio/radio.js
var radio_default = {
  name: "radio"
};

// node_modules/framework7/components/toggle/toggle-class.js
var Toggle = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const toggle5 = this;
    const support2 = getSupport();
    const defaults = {};
    toggle5.useModulesParams(defaults);
    toggle5.params = extend(defaults, params);
    const el = toggle5.params.el;
    if (!el)
      return toggle5;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return toggle5;
    if ($el[0].f7Toggle)
      return $el[0].f7Toggle;
    const $inputEl = $el.children('input[type="checkbox"]');
    extend(toggle5, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl[0],
      disabled: $el.hasClass("disabled") || $inputEl.hasClass("disabled") || $inputEl.attr("disabled") || $inputEl[0].disabled
    });
    Object.defineProperty(toggle5, "checked", {
      enumerable: true,
      configurable: true,
      set(checked) {
        if (!toggle5 || typeof toggle5.$inputEl === "undefined")
          return;
        if (toggle5.checked === checked)
          return;
        $inputEl[0].checked = checked;
        toggle5.$inputEl.trigger("change");
      },
      get() {
        return $inputEl[0].checked;
      }
    });
    $el[0].f7Toggle = toggle5;
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let toggleWidth;
    let touchStartTime;
    let touchStartChecked;
    function handleTouchStart(e) {
      if (isTouched || toggle5.disabled)
        return;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchesDiff = 0;
      isTouched = true;
      isScrolling = void 0;
      touchStartTime = now();
      touchStartChecked = toggle5.checked;
      toggleWidth = $el[0].offsetWidth;
      nextTick(() => {
        if (isTouched) {
          $el.addClass("toggle-active-state");
        }
      });
    }
    function handleTouchMove(e) {
      if (!isTouched || toggle5.disabled)
        return;
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      const inverter = app.rtl ? -1 : 1;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      touchesDiff = pageX - touchesStart.x;
      let changed;
      if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
        changed = true;
      }
      if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
        changed = true;
      }
      if (changed) {
        touchesStart.x = pageX;
        toggle5.checked = !touchStartChecked;
        touchStartChecked = !touchStartChecked;
      }
    }
    function handleTouchEnd() {
      if (!isTouched || toggle5.disabled) {
        if (isScrolling)
          $el.removeClass("toggle-active-state");
        isTouched = false;
        return;
      }
      const inverter = app.rtl ? -1 : 1;
      isTouched = false;
      $el.removeClass("toggle-active-state");
      let changed;
      if (now() - touchStartTime < 300) {
        if (touchesDiff * inverter < 0 && touchStartChecked) {
          changed = true;
        }
        if (touchesDiff * inverter > 0 && !touchStartChecked) {
          changed = true;
        }
        if (changed) {
          toggle5.checked = !touchStartChecked;
        }
      }
    }
    function handleInputChange() {
      toggle5.$el.trigger("toggle:change");
      toggle5.emit("local::change toggleChange", toggle5);
    }
    toggle5.attachEvents = function attachEvents2() {
      const passive = support2.passiveListener ? {
        passive: true
      } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      toggle5.$inputEl.on("change", handleInputChange);
    };
    toggle5.detachEvents = function detachEvents2() {
      const passive = support2.passiveListener ? {
        passive: true
      } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off("touchmove", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      toggle5.$inputEl.off("change", handleInputChange);
    };
    toggle5.useModules();
    toggle5.init();
  }
  toggle() {
    const toggle5 = this;
    toggle5.checked = !toggle5.checked;
  }
  init() {
    const toggle5 = this;
    toggle5.attachEvents();
  }
  destroy() {
    let toggle5 = this;
    toggle5.$el.trigger("toggle:beforedestroy");
    toggle5.emit("local::beforeDestroy toggleBeforeDestroy", toggle5);
    delete toggle5.$el[0].f7Toggle;
    toggle5.detachEvents();
    deleteProps(toggle5);
    toggle5 = null;
  }
};
var toggle_class_default = Toggle;

// node_modules/framework7/components/toggle/toggle.js
var toggle_default = {
  name: "toggle",
  create() {
    const app = this;
    app.toggle = ConstructorMethods({
      defaultSelector: ".toggle",
      constructor: toggle_class_default,
      app,
      domProp: "f7Toggle"
    });
  },
  static: {
    Toggle: toggle_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".toggle-init").each((toggleEl) => app.toggle.create({
        el: toggleEl
      }));
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".toggle-init").each((toggleEl) => {
        if (toggleEl.f7Toggle)
          toggleEl.f7Toggle.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".toggle-init").each((toggleEl) => app.toggle.create({
        el: toggleEl
      }));
    },
    pageBeforeRemove(page) {
      page.$el.find(".toggle-init").each((toggleEl) => {
        if (toggleEl.f7Toggle)
          toggleEl.f7Toggle.destroy();
      });
    }
  },
  vnode: {
    "toggle-init": {
      insert(vnode) {
        const app = this;
        const toggleEl = vnode.elm;
        app.toggle.create({
          el: toggleEl
        });
      },
      destroy(vnode) {
        const toggleEl = vnode.elm;
        if (toggleEl.f7Toggle)
          toggleEl.f7Toggle.destroy();
      }
    }
  }
};

// node_modules/framework7/components/range/range-class.js
var Range = class extends class_default {
  constructor(app, params) {
    super(params, [app]);
    const range = this;
    const support2 = getSupport();
    const defaults = {
      el: null,
      inputEl: null,
      dual: false,
      step: 1,
      label: false,
      min: 0,
      max: 100,
      value: 0,
      draggableBar: true,
      vertical: false,
      verticalReversed: false,
      formatLabel: null,
      scale: false,
      scaleSteps: 5,
      scaleSubSteps: 0,
      formatScaleLabel: null,
      limitKnobPosition: app.theme === "ios"
    };
    range.useModulesParams(defaults);
    range.params = extend(defaults, params);
    const el = range.params.el;
    if (!el)
      return range;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return range;
    if ($el[0].f7Range)
      return $el[0].f7Range;
    const dataset = $el.dataset();
    "step min max value scaleSteps scaleSubSteps".split(" ").forEach((paramName) => {
      if (typeof params[paramName] === "undefined" && typeof dataset[paramName] !== "undefined") {
        range.params[paramName] = parseFloat(dataset[paramName]);
      }
    });
    "dual label vertical verticalReversed scale".split(" ").forEach((paramName) => {
      if (typeof params[paramName] === "undefined" && typeof dataset[paramName] !== "undefined") {
        range.params[paramName] = dataset[paramName];
      }
    });
    if (!range.params.value) {
      if (typeof dataset.value !== "undefined")
        range.params.value = dataset.value;
      if (typeof dataset.valueLeft !== "undefined" && typeof dataset.valueRight !== "undefined") {
        range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
      }
    }
    let $inputEl;
    if (!range.params.dual) {
      if (range.params.inputEl) {
        $inputEl = dom7_default(range.params.inputEl);
      } else if ($el.find('input[type="range"]').length) {
        $inputEl = $el.find('input[type="range"]').eq(0);
      }
    }
    const {
      dual,
      step,
      label,
      min,
      max,
      value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition
    } = range.params;
    extend(range, {
      app,
      $el,
      el: $el[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : void 0,
      dual,
      step,
      label,
      min,
      max,
      value,
      previousValue: value,
      vertical,
      verticalReversed,
      scale,
      scaleSteps,
      scaleSubSteps,
      limitKnobPosition
    });
    if ($inputEl) {
      "step min max".split(" ").forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          range.params[paramName] = parseFloat($inputEl.attr(paramName));
          range[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      if (typeof $inputEl.val() !== "undefined") {
        range.params.value = parseFloat($inputEl.val());
        range.value = parseFloat($inputEl.val());
      }
    }
    if (range.dual) {
      $el.addClass("range-slider-dual");
    }
    if (range.label) {
      $el.addClass("range-slider-label");
    }
    if (range.vertical) {
      $el.addClass("range-slider-vertical");
      if (range.verticalReversed) {
        $el.addClass("range-slider-vertical-reversed");
      }
    } else {
      $el.addClass("range-slider-horizontal");
    }
    const $barEl = dom7_default('<div class="range-bar"></div>');
    const $barActiveEl = dom7_default('<div class="range-bar-active"></div>');
    $barEl.append($barActiveEl);
    const knobHTML = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${range.label ? '<div class="range-knob-label"></div>' : ""}
      </div>
    `;
    const knobs = [dom7_default(knobHTML)];
    if (range.dual) {
      knobs.push(dom7_default(knobHTML));
    }
    $el.append($barEl);
    knobs.forEach(($knobEl) => {
      $el.append($knobEl);
    });
    const labels = [];
    if (range.label) {
      labels.push(knobs[0].find(".range-knob-label"));
      if (range.dual) {
        labels.push(knobs[1].find(".range-knob-label"));
      }
    }
    let $scaleEl;
    if (range.scale && range.scaleSteps >= 1) {
      $scaleEl = dom7_default(`
        <div class="range-scale">
          ${range.renderScale()}
        </div>
      `);
      $el.append($scaleEl);
    }
    extend(range, {
      knobs,
      labels,
      $barEl,
      $barActiveEl,
      $scaleEl
    });
    $el[0].f7Range = range;
    let isTouched;
    const touchesStart = {};
    let isScrolling;
    let rangeOffset;
    let rangeOffsetLeft;
    let rangeOffsetTop;
    let $touchedKnobEl;
    let dualValueIndex;
    let valueChangedByTouch;
    let targetTouchIdentifier;
    function onTouchChange() {
      valueChangedByTouch = true;
    }
    function handleTouchStart(e) {
      if (isTouched)
        return;
      if (!range.params.draggableBar) {
        if (dom7_default(e.target).closest(".range-knob").length === 0) {
          return;
        }
      }
      valueChangedByTouch = false;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      if (e.type === "touchstart") {
        targetTouchIdentifier = e.targetTouches[0].identifier;
      }
      isTouched = true;
      isScrolling = void 0;
      rangeOffset = $el.offset();
      rangeOffsetLeft = rangeOffset.left;
      rangeOffsetTop = rangeOffset.top;
      let progress;
      if (range.vertical) {
        progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed)
          progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = (rangeOffsetLeft + range.rangeWidth - touchesStart.x) / range.rangeWidth;
      } else {
        progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
      }
      let newValue = progress * (range.max - range.min) + range.min;
      if (range.dual) {
        if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
          dualValueIndex = 0;
          $touchedKnobEl = range.knobs[0];
          newValue = [newValue, range.value[1]];
        } else {
          dualValueIndex = 1;
          $touchedKnobEl = range.knobs[1];
          newValue = [range.value[0], newValue];
        }
      } else {
        $touchedKnobEl = range.knobs[0];
        newValue = progress * (range.max - range.min) + range.min;
      }
      nextTick(() => {
        if (isTouched)
          $touchedKnobEl.addClass("range-knob-active-state");
      }, 70);
      range.on("change", onTouchChange);
      range.setValue(newValue, true);
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      let pageX;
      let pageY;
      if (e.type === "touchmove") {
        for (let i = 0; i < e.targetTouches.length; i += 1) {
          if (e.targetTouches[i].identifier === targetTouchIdentifier) {
            pageX = e.targetTouches[i].pageX;
            pageY = e.targetTouches[i].pageY;
          }
        }
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (typeof pageX === "undefined" && typeof pageY === "undefined")
        return;
      if (typeof isScrolling === "undefined" && !range.vertical) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      let progress;
      if (range.vertical) {
        progress = (pageY - rangeOffsetTop) / range.rangeHeight;
        if (!range.verticalReversed)
          progress = 1 - progress;
      } else if (range.app.rtl) {
        progress = (rangeOffsetLeft + range.rangeWidth - pageX) / range.rangeWidth;
      } else {
        progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
      }
      let newValue = progress * (range.max - range.min) + range.min;
      if (range.dual) {
        let leftValue;
        let rightValue;
        if (dualValueIndex === 0) {
          leftValue = newValue;
          rightValue = range.value[1];
          if (leftValue > rightValue) {
            rightValue = leftValue;
          }
        } else {
          leftValue = range.value[0];
          rightValue = newValue;
          if (rightValue < leftValue) {
            leftValue = rightValue;
          }
        }
        newValue = [leftValue, rightValue];
      }
      range.setValue(newValue, true);
    }
    function handleTouchEnd(e) {
      if (e.type === "touchend") {
        let touchEnded;
        for (let i = 0; i < e.changedTouches.length; i += 1) {
          if (e.changedTouches[i].identifier === targetTouchIdentifier)
            touchEnded = true;
        }
        if (!touchEnded)
          return;
      }
      if (!isTouched) {
        if (isScrolling)
          $touchedKnobEl.removeClass("range-knob-active-state");
        isTouched = false;
        return;
      }
      range.off("change", onTouchChange);
      isTouched = false;
      $touchedKnobEl.removeClass("range-knob-active-state");
      if (valueChangedByTouch && range.$inputEl && !range.dual) {
        range.$inputEl.trigger("change");
      }
      valueChangedByTouch = false;
      if (typeof range.previousValue !== "undefined") {
        if (range.dual && (range.previousValue[0] !== range.value[0] || range.previousValue[1] !== range.value[1]) || !range.dual && range.previousValue !== range.value) {
          range.$el.trigger("range:changed", range.value);
          range.emit("local::changed rangeChanged", range, range.value);
        }
      }
    }
    function handleResize() {
      range.calcSize();
      range.layout();
    }
    let parentModals;
    let parentPanel;
    let parentPage;
    range.attachEvents = function attachEvents2() {
      const passive = support2.passiveListener ? {
        passive: true
      } : false;
      range.$el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      app.on("tabShow", handleResize);
      app.on("resize", handleResize);
      parentModals = range.$el.parents(".sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast");
      parentModals.on("modal:open", handleResize);
      parentPanel = range.$el.parents(".panel");
      parentPanel.on("panel:open panel:resize", handleResize);
      parentPage = range.$el.parents(".page").eq(0);
      parentPage.on("page:reinit", handleResize);
    };
    range.detachEvents = function detachEvents2() {
      const passive = support2.passiveListener ? {
        passive: true
      } : false;
      range.$el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off("touchmove", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("tabShow", handleResize);
      app.off("resize", handleResize);
      if (parentModals) {
        parentModals.off("modal:open", handleResize);
      }
      if (parentPanel) {
        parentPanel.off("panel:open panel:resize", handleResize);
      }
      if (parentPage) {
        parentPage.off("page:reinit", handleResize);
      }
      parentModals = null;
      parentPanel = null;
      parentPage = null;
    };
    range.useModules();
    range.init();
    return range;
  }
  calcSize() {
    const range = this;
    if (range.vertical) {
      const height = range.$el.outerHeight();
      if (height === 0)
        return;
      range.rangeHeight = height;
      range.knobHeight = range.knobs[0].outerHeight();
    } else {
      const width = range.$el.outerWidth();
      if (width === 0)
        return;
      range.rangeWidth = width;
      range.knobWidth = range.knobs[0].outerWidth();
    }
  }
  layout() {
    const range = this;
    const {
      app,
      knobWidth,
      knobHeight,
      rangeWidth,
      rangeHeight,
      min,
      max,
      knobs,
      $barActiveEl,
      value,
      label,
      labels,
      vertical,
      verticalReversed,
      limitKnobPosition
    } = range;
    const knobSize = vertical ? knobHeight : knobWidth;
    const rangeSize = vertical ? rangeHeight : rangeWidth;
    const positionProperty = vertical ? verticalReversed ? "top" : "bottom" : app.rtl ? "right" : "left";
    if (range.dual) {
      const progress = [(value[0] - min) / (max - min), (value[1] - min) / (max - min)];
      $barActiveEl.css({
        [positionProperty]: `${progress[0] * 100}%`,
        [vertical ? "height" : "width"]: `${(progress[1] - progress[0]) * 100}%`
      });
      knobs.forEach(($knobEl, knobIndex) => {
        let startPos = rangeSize * progress[knobIndex];
        if (limitKnobPosition) {
          const realStartPos = rangeSize * progress[knobIndex] - knobSize / 2;
          if (realStartPos < 0)
            startPos = knobSize / 2;
          if (realStartPos + knobSize > rangeSize)
            startPos = rangeSize - knobSize / 2;
        }
        $knobEl.css(positionProperty, `${startPos}px`);
        if (label)
          labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0]));
      });
    } else {
      const progress = (value - min) / (max - min);
      $barActiveEl.css(vertical ? "height" : "width", `${progress * 100}%`);
      let startPos = rangeSize * progress;
      if (limitKnobPosition) {
        const realStartPos = rangeSize * progress - knobSize / 2;
        if (realStartPos < 0)
          startPos = knobSize / 2;
        if (realStartPos + knobSize > rangeSize)
          startPos = rangeSize - knobSize / 2;
      }
      knobs[0].css(positionProperty, `${startPos}px`);
      if (label)
        labels[0].text(range.formatLabel(value, labels[0][0]));
    }
    if (range.dual && value.indexOf(min) >= 0 || !range.dual && value === min) {
      range.$el.addClass("range-slider-min");
    } else {
      range.$el.removeClass("range-slider-min");
    }
    if (range.dual && value.indexOf(max) >= 0 || !range.dual && value === max) {
      range.$el.addClass("range-slider-max");
    } else {
      range.$el.removeClass("range-slider-max");
    }
  }
  setValue(newValue, byTouchMove) {
    const range = this;
    const {
      step,
      min,
      max
    } = range;
    let valueChanged;
    let oldValue;
    if (range.dual) {
      oldValue = [range.value[0], range.value[1]];
      let newValues = newValue;
      if (!Array.isArray(newValues))
        newValues = [newValue, newValue];
      if (newValue[0] > newValue[1]) {
        newValues = [newValues[0], newValues[0]];
      }
      newValues = newValues.map((value) => Math.max(Math.min(Math.round(value / step) * step, max), min));
      if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
        return range;
      }
      newValues.forEach((value, valueIndex) => {
        range.value[valueIndex] = value;
      });
      valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
      range.layout();
    } else {
      oldValue = range.value;
      const value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
      range.value = value;
      range.layout();
      valueChanged = oldValue !== value;
    }
    if (valueChanged) {
      range.previousValue = oldValue;
    }
    if (!valueChanged)
      return range;
    range.$el.trigger("range:change", range.value);
    if (range.$inputEl && !range.dual) {
      range.$inputEl.val(range.value);
      if (!byTouchMove) {
        range.$inputEl.trigger("input change");
      } else {
        range.$inputEl.trigger("input");
      }
    }
    if (!byTouchMove) {
      range.$el.trigger("range:changed", range.value);
      range.emit("local::changed rangeChanged", range, range.value);
    }
    range.emit("local::change rangeChange", range, range.value);
    return range;
  }
  getValue() {
    return this.value;
  }
  formatLabel(value, labelEl) {
    const range = this;
    if (range.params.formatLabel)
      return range.params.formatLabel.call(range, value, labelEl);
    return value;
  }
  formatScaleLabel(value) {
    const range = this;
    if (range.params.formatScaleLabel)
      return range.params.formatScaleLabel.call(range, value);
    return value;
  }
  renderScale() {
    const range = this;
    const {
      app,
      verticalReversed,
      vertical
    } = range;
    const positionProperty = vertical ? verticalReversed ? "top" : "bottom" : app.rtl ? "right" : "left";
    let html2 = "";
    Array.from({
      length: range.scaleSteps + 1
    }).forEach((scaleEl, index2) => {
      const scaleStepValue = (range.max - range.min) / range.scaleSteps;
      const scaleValue = range.min + scaleStepValue * index2;
      const progress = (scaleValue - range.min) / (range.max - range.min);
      html2 += `<div class="range-scale-step" style="${positionProperty}: ${progress * 100}%">${range.formatScaleLabel(scaleValue)}</div>`;
      if (range.scaleSubSteps && range.scaleSubSteps > 1 && index2 < range.scaleSteps) {
        Array.from({
          length: range.scaleSubSteps - 1
        }).forEach((subStepEl, subIndex) => {
          const subStep = scaleStepValue / range.scaleSubSteps;
          const scaleSubValue = scaleValue + subStep * (subIndex + 1);
          const subProgress = (scaleSubValue - range.min) / (range.max - range.min);
          html2 += `<div class="range-scale-step range-scale-substep" style="${positionProperty}: ${subProgress * 100}%"></div>`;
        });
      }
    });
    return html2;
  }
  updateScale() {
    const range = this;
    if (!range.scale || range.scaleSteps < 1) {
      if (range.$scaleEl)
        range.$scaleEl.remove();
      delete range.$scaleEl;
      return;
    }
    if (!range.$scaleEl) {
      range.$scaleEl = dom7_default('<div class="range-scale"></div>');
      range.$el.append(range.$scaleEl);
    }
    range.$scaleEl.html(range.renderScale());
  }
  init() {
    const range = this;
    range.calcSize();
    range.layout();
    range.attachEvents();
    return range;
  }
  destroy() {
    let range = this;
    range.$el.trigger("range:beforedestroy");
    range.emit("local::beforeDestroy rangeBeforeDestroy", range);
    delete range.$el[0].f7Range;
    range.detachEvents();
    deleteProps(range);
    range = null;
  }
};
var range_class_default = Range;

// node_modules/framework7/components/range/range.js
var range_default = {
  name: "range",
  create() {
    const app = this;
    app.range = extend(ConstructorMethods({
      defaultSelector: ".range-slider",
      constructor: range_class_default,
      app,
      domProp: "f7Range"
    }), {
      getValue(el) {
        if (el === void 0) {
          el = ".range-slider";
        }
        const range = app.range.get(el);
        if (range)
          return range.getValue();
        return void 0;
      },
      setValue(el, value) {
        if (el === void 0) {
          el = ".range-slider";
        }
        const range = app.range.get(el);
        if (range)
          return range.setValue(value);
        return void 0;
      }
    });
  },
  static: {
    Range: range_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".range-slider-init").each((rangeEl) => new range_class_default(app, {
        el: rangeEl
      }));
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".range-slider-init").each((rangeEl) => {
        if (rangeEl.f7Range)
          rangeEl.f7Range.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".range-slider-init").each((rangeEl) => new range_class_default(app, {
        el: rangeEl
      }));
    },
    pageBeforeRemove(page) {
      page.$el.find(".range-slider-init").each((rangeEl) => {
        if (rangeEl.f7Range)
          rangeEl.f7Range.destroy();
      });
    }
  },
  vnode: {
    "range-slider-init": {
      insert(vnode) {
        const rangeEl = vnode.elm;
        const app = this;
        app.range.create({
          el: rangeEl
        });
      },
      destroy(vnode) {
        const rangeEl = vnode.elm;
        if (rangeEl.f7Range)
          rangeEl.f7Range.destroy();
      }
    }
  }
};

// node_modules/framework7/components/stepper/stepper-class.js
var Stepper = class extends class_default {
  constructor(app, params) {
    super(params, [app]);
    const stepper = this;
    const defaults = {
      el: null,
      inputEl: null,
      valueEl: null,
      value: 0,
      formatValue: null,
      step: 1,
      min: 0,
      max: 100,
      watchInput: true,
      autorepeat: false,
      autorepeatDynamic: false,
      wraps: false,
      manualInputMode: false,
      decimalPoint: 4,
      buttonsEndInputMode: true
    };
    stepper.useModulesParams(defaults);
    stepper.params = extend(defaults, params);
    if (stepper.params.value < stepper.params.min) {
      stepper.params.value = stepper.params.min;
    }
    if (stepper.params.value > stepper.params.max) {
      stepper.params.value = stepper.params.max;
    }
    const el = stepper.params.el;
    if (!el)
      return stepper;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return stepper;
    if ($el[0].f7Stepper)
      return $el[0].f7Stepper;
    let $inputEl;
    if (stepper.params.inputEl) {
      $inputEl = dom7_default(stepper.params.inputEl);
    } else if ($el.find(".stepper-input-wrap").find("input, textarea").length) {
      $inputEl = $el.find(".stepper-input-wrap").find("input, textarea").eq(0);
    }
    if ($inputEl && $inputEl.length) {
      "step min max".split(" ").forEach((paramName) => {
        if (!params[paramName] && $inputEl.attr(paramName)) {
          stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
        }
      });
      const decimalPoint2 = parseInt(stepper.params.decimalPoint, 10);
      if (Number.isNaN(decimalPoint2)) {
        stepper.params.decimalPoint = 0;
      } else {
        stepper.params.decimalPoint = decimalPoint2;
      }
      const inputValue = parseFloat($inputEl.val());
      if (typeof params.value === "undefined" && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
        stepper.params.value = inputValue;
      }
    }
    let $valueEl;
    if (stepper.params.valueEl) {
      $valueEl = dom7_default(stepper.params.valueEl);
    } else if ($el.find(".stepper-value").length) {
      $valueEl = $el.find(".stepper-value").eq(0);
    }
    const $buttonPlusEl = $el.find(".stepper-button-plus");
    const $buttonMinusEl = $el.find(".stepper-button-minus");
    const {
      step,
      min,
      max,
      value,
      decimalPoint
    } = stepper.params;
    extend(stepper, {
      app,
      $el,
      el: $el[0],
      $buttonPlusEl,
      buttonPlusEl: $buttonPlusEl[0],
      $buttonMinusEl,
      buttonMinusEl: $buttonMinusEl[0],
      $inputEl,
      inputEl: $inputEl ? $inputEl[0] : void 0,
      $valueEl,
      valueEl: $valueEl ? $valueEl[0] : void 0,
      step,
      min,
      max,
      value,
      decimalPoint,
      typeModeChanged: false
    });
    $el[0].f7Stepper = stepper;
    const touchesStart = {};
    let isTouched;
    let isScrolling;
    let preventButtonClick;
    let intervalId;
    let timeoutId;
    let autorepeatAction = null;
    let autorepeatInAction = false;
    let manualInput = false;
    function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        if (current === 1) {
          preventButtonClick = true;
          autorepeatInAction = true;
        }
        clearInterval(intervalId);
        action();
        intervalId = setInterval(() => {
          action();
        }, repeatEvery);
        if (current < progressions) {
          dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
        }
      }, current === 1 ? startsIn : progressionStep);
    }
    function onTouchStart2(e) {
      if (isTouched)
        return;
      if (manualInput) {
        return;
      }
      if (dom7_default(e.target).closest($buttonPlusEl).length) {
        autorepeatAction = "increment";
      } else if (dom7_default(e.target).closest($buttonMinusEl).length) {
        autorepeatAction = "decrement";
      }
      if (!autorepeatAction)
        return;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      isScrolling = void 0;
      const progressions = stepper.params.autorepeatDynamic ? 4 : 1;
      dynamicRepeat(1, progressions, 500, 1e3, 300, () => {
        stepper[autorepeatAction]();
      });
    }
    function onTouchMove2(e) {
      if (!isTouched)
        return;
      if (manualInput) {
        return;
      }
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined" && !autorepeatInAction) {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      const distance = ((pageX - touchesStart.x) ** 2 + (pageY - touchesStart.y) ** 2) ** 0.5;
      if (isScrolling || distance > 20) {
        isTouched = false;
        clearTimeout(timeoutId);
        clearInterval(intervalId);
      }
    }
    function onTouchEnd2() {
      clearTimeout(timeoutId);
      clearInterval(intervalId);
      autorepeatAction = null;
      autorepeatInAction = false;
      isTouched = false;
    }
    function onMinusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }
        return;
      }
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.decrement(true);
    }
    function onPlusClick() {
      if (manualInput) {
        if (stepper.params.buttonsEndInputMode) {
          manualInput = false;
          stepper.endTypeMode(true);
        }
        return;
      }
      if (preventButtonClick) {
        preventButtonClick = false;
        return;
      }
      stepper.increment(true);
    }
    function onInputClick(e) {
      if (!e.target.readOnly && stepper.params.manualInputMode) {
        manualInput = true;
        if (typeof e.target.selectionStart === "number") {
          e.target.selectionStart = e.target.value.length;
          e.target.selectionEnd = e.target.value.length;
        }
      }
    }
    function onInputKey(e) {
      if (e.keyCode === 13 || e.which === 13) {
        e.preventDefault();
        manualInput = false;
        stepper.endTypeMode();
      }
    }
    function onInputBlur() {
      manualInput = false;
      stepper.endTypeMode(true);
    }
    function onInput(e) {
      if (manualInput) {
        stepper.typeValue(e.target.value);
        return;
      }
      if (e.detail && e.detail.sentByF7Stepper)
        return;
      stepper.setValue(e.target.value, true);
    }
    stepper.attachEvents = function attachEvents2() {
      $buttonMinusEl.on("click", onMinusClick);
      $buttonPlusEl.on("click", onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.on("input", onInput);
        $inputEl.on("click", onInputClick);
        $inputEl.on("blur", onInputBlur);
        $inputEl.on("keyup", onInputKey);
      }
      if (stepper.params.autorepeat) {
        app.on("touchstart:passive", onTouchStart2);
        app.on("touchmove:active", onTouchMove2);
        app.on("touchend:passive", onTouchEnd2);
      }
    };
    stepper.detachEvents = function detachEvents2() {
      $buttonMinusEl.off("click", onMinusClick);
      $buttonPlusEl.off("click", onPlusClick);
      if (stepper.params.watchInput && $inputEl && $inputEl.length) {
        $inputEl.off("input", onInput);
        $inputEl.off("click", onInputClick);
        $inputEl.off("blur", onInputBlur);
        $inputEl.off("keyup", onInputKey);
      }
    };
    stepper.useModules();
    stepper.init();
    return stepper;
  }
  minus() {
    return this.decrement();
  }
  plus() {
    return this.increment();
  }
  decrement() {
    const stepper = this;
    return stepper.setValue(stepper.value - stepper.step, false, true);
  }
  increment() {
    const stepper = this;
    return stepper.setValue(stepper.value + stepper.step, false, true);
  }
  setValue(newValue, forceUpdate, withWraps) {
    const stepper = this;
    const {
      step,
      min,
      max
    } = stepper;
    const oldValue = stepper.value;
    let value = Math.round(newValue / step) * step;
    if (stepper.params.wraps && withWraps) {
      if (value > max)
        value = min;
      if (value < min)
        value = max;
    } else {
      value = Math.max(Math.min(value, max), min);
    }
    if (Number.isNaN(value)) {
      value = oldValue;
    }
    stepper.value = value;
    const valueChanged = oldValue !== value;
    if (!valueChanged && !forceUpdate)
      return stepper;
    stepper.$el.trigger("stepper:change", stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger("input change", {
        sentByF7Stepper: true
      });
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit("local::change stepperChange", stepper, stepper.value);
    return stepper;
  }
  endTypeMode(noBlur) {
    const stepper = this;
    const {
      min,
      max
    } = stepper;
    let value = parseFloat(stepper.value);
    if (Number.isNaN(value))
      value = 0;
    value = Math.max(Math.min(value, max), min);
    stepper.value = value;
    if (!stepper.typeModeChanged) {
      if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
        stepper.$inputEl.blur();
      }
      return stepper;
    }
    stepper.typeModeChanged = false;
    stepper.$el.trigger("stepper:change", stepper.value);
    const formattedValue = stepper.formatValue(stepper.value);
    if (stepper.$inputEl && stepper.$inputEl.length) {
      stepper.$inputEl.val(formattedValue);
      stepper.$inputEl.trigger("input change", {
        sentByF7Stepper: true
      });
      if (!noBlur)
        stepper.$inputEl.blur();
    }
    if (stepper.$valueEl && stepper.$valueEl.length) {
      stepper.$valueEl.html(formattedValue);
    }
    stepper.emit("local::change stepperChange", stepper, stepper.value);
    return stepper;
  }
  typeValue(value) {
    const stepper = this;
    stepper.typeModeChanged = true;
    let inputTxt = String(value);
    if (inputTxt.length === 1 && inputTxt === "-")
      return stepper;
    if (inputTxt.lastIndexOf(".") + 1 === inputTxt.length || inputTxt.lastIndexOf(",") + 1 === inputTxt.length) {
      if (inputTxt.lastIndexOf(".") !== inputTxt.indexOf(".") || inputTxt.lastIndexOf(",") !== inputTxt.indexOf(",")) {
        inputTxt = inputTxt.slice(0, -1);
        stepper.value = inputTxt;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
    } else {
      let newValue = parseFloat(inputTxt.replace(",", "."));
      if (newValue === 0) {
        stepper.value = inputTxt.replace(",", ".");
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      if (Number.isNaN(newValue)) {
        stepper.value = 0;
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      const powVal = 10 ** stepper.params.decimalPoint;
      newValue = Math.round(newValue * powVal).toFixed(stepper.params.decimalPoint + 1) / powVal;
      stepper.value = parseFloat(String(newValue).replace(",", "."));
      stepper.$inputEl.val(stepper.value);
      return stepper;
    }
    stepper.value = inputTxt;
    stepper.$inputEl.val(inputTxt);
    return stepper;
  }
  getValue() {
    return this.value;
  }
  formatValue(value) {
    const stepper = this;
    if (!stepper.params.formatValue)
      return value;
    return stepper.params.formatValue.call(stepper, value);
  }
  init() {
    const stepper = this;
    stepper.attachEvents();
    if (stepper.$valueEl && stepper.$valueEl.length) {
      const formattedValue = stepper.formatValue(stepper.value);
      stepper.$valueEl.html(formattedValue);
    }
    return stepper;
  }
  destroy() {
    let stepper = this;
    stepper.$el.trigger("stepper:beforedestroy");
    stepper.emit("local::beforeDestroy stepperBeforeDestroy", stepper);
    delete stepper.$el[0].f7Stepper;
    stepper.detachEvents();
    deleteProps(stepper);
    stepper = null;
  }
};
var stepper_class_default = Stepper;

// node_modules/framework7/components/stepper/stepper.js
var stepper_default = {
  name: "stepper",
  create() {
    const app = this;
    app.stepper = extend(ConstructorMethods({
      defaultSelector: ".stepper",
      constructor: stepper_class_default,
      app,
      domProp: "f7Stepper"
    }), {
      getValue(el) {
        if (el === void 0) {
          el = ".stepper";
        }
        const stepper = app.stepper.get(el);
        if (stepper)
          return stepper.getValue();
        return void 0;
      },
      setValue(el, value) {
        if (el === void 0) {
          el = ".stepper";
        }
        const stepper = app.stepper.get(el);
        if (stepper)
          return stepper.setValue(value);
        return void 0;
      }
    });
  },
  static: {
    Stepper: stepper_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".stepper-init").each((stepperEl) => {
        const dataset = dom7_default(stepperEl).dataset();
        app.stepper.create(extend({
          el: stepperEl
        }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".stepper-init").each((stepperEl) => {
        if (stepperEl.f7Stepper)
          stepperEl.f7Stepper.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".stepper-init").each((stepperEl) => {
        const dataset = dom7_default(stepperEl).dataset();
        app.stepper.create(extend({
          el: stepperEl
        }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".stepper-init").each((stepperEl) => {
        if (stepperEl.f7Stepper)
          stepperEl.f7Stepper.destroy();
      });
    }
  },
  vnode: {
    "stepper-init": {
      insert(vnode) {
        const app = this;
        const stepperEl = vnode.elm;
        const dataset = dom7_default(stepperEl).dataset();
        app.stepper.create(extend({
          el: stepperEl
        }, dataset || {}));
      },
      destroy(vnode) {
        const stepperEl = vnode.elm;
        if (stepperEl.f7Stepper)
          stepperEl.f7Stepper.destroy();
      }
    }
  }
};

// node_modules/framework7/components/searchbar/remove-diacritics.js
var defaultDiacriticsRemovalap = [{
  base: "A",
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: "AA",
  letters: "\uA732"
}, {
  base: "AE",
  letters: "\xC6\u01FC\u01E2"
}, {
  base: "AO",
  letters: "\uA734"
}, {
  base: "AU",
  letters: "\uA736"
}, {
  base: "AV",
  letters: "\uA738\uA73A"
}, {
  base: "AY",
  letters: "\uA73C"
}, {
  base: "B",
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: "C",
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: "D",
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: "DZ",
  letters: "\u01F1\u01C4"
}, {
  base: "Dz",
  letters: "\u01F2\u01C5"
}, {
  base: "E",
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: "F",
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: "G",
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: "H",
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: "I",
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: "J",
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: "K",
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: "L",
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: "LJ",
  letters: "\u01C7"
}, {
  base: "Lj",
  letters: "\u01C8"
}, {
  base: "M",
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: "N",
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: "NJ",
  letters: "\u01CA"
}, {
  base: "Nj",
  letters: "\u01CB"
}, {
  base: "O",
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: "OI",
  letters: "\u01A2"
}, {
  base: "OO",
  letters: "\uA74E"
}, {
  base: "OU",
  letters: "\u0222"
}, {
  base: "OE",
  letters: "\x8C\u0152"
}, {
  base: "oe",
  letters: "\x9C\u0153"
}, {
  base: "P",
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: "Q",
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: "R",
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: "S",
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: "T",
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: "TZ",
  letters: "\uA728"
}, {
  base: "U",
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: "V",
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: "VY",
  letters: "\uA760"
}, {
  base: "W",
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: "X",
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: "Y",
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: "Z",
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: "a",
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: "aa",
  letters: "\uA733"
}, {
  base: "ae",
  letters: "\xE6\u01FD\u01E3"
}, {
  base: "ao",
  letters: "\uA735"
}, {
  base: "au",
  letters: "\uA737"
}, {
  base: "av",
  letters: "\uA739\uA73B"
}, {
  base: "ay",
  letters: "\uA73D"
}, {
  base: "b",
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: "c",
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: "d",
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: "dz",
  letters: "\u01F3\u01C6"
}, {
  base: "e",
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: "f",
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: "g",
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: "h",
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: "hv",
  letters: "\u0195"
}, {
  base: "i",
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: "j",
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: "k",
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: "l",
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: "lj",
  letters: "\u01C9"
}, {
  base: "m",
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: "n",
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: "nj",
  letters: "\u01CC"
}, {
  base: "o",
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: "oi",
  letters: "\u01A3"
}, {
  base: "ou",
  letters: "\u0223"
}, {
  base: "oo",
  letters: "\uA74F"
}, {
  base: "p",
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: "q",
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: "r",
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: "s",
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: "t",
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: "tz",
  letters: "\uA729"
}, {
  base: "u",
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: "v",
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: "vy",
  letters: "\uA761"
}, {
  base: "w",
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: "x",
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: "y",
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: "z",
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var diacriticsMap = {};
for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
  const letters = defaultDiacriticsRemovalap[i].letters;
  for (let j = 0; j < letters.length; j += 1) {
    diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
  }
}
function removeDiacritics(str) {
  return str.replace(/[^\u0000-\u007E]/g, (a) => diacriticsMap[a] || a);
}
var remove_diacritics_default = removeDiacritics;

// node_modules/framework7/components/smart-select/smart-select-class.js
var SmartSelect = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const ss = this;
    const defaults = extend({
      on: {}
    }, app.params.smartSelect);
    if (typeof defaults.searchbarDisableButton === "undefined") {
      defaults.searchbarDisableButton = app.theme !== "aurora";
    }
    ss.useModulesParams(defaults);
    ss.params = extend({}, defaults, params);
    ss.app = app;
    const $el = dom7_default(ss.params.el).eq(0);
    if ($el.length === 0)
      return ss;
    if ($el[0].f7SmartSelect)
      return $el[0].f7SmartSelect;
    const $selectEl = $el.find("select").eq(0);
    if ($selectEl.length === 0)
      return ss;
    let $valueEl;
    if (ss.params.setValueText) {
      $valueEl = dom7_default(ss.params.valueEl);
      if ($valueEl.length === 0) {
        $valueEl = $el.find(".item-after");
      }
      if ($valueEl.length === 0) {
        $valueEl = dom7_default('<div class="item-after"></div>');
        $valueEl.insertAfter($el.find(".item-title"));
      }
    }
    let url = params.url;
    if (!url) {
      if ($el.attr("href") && $el.attr("href") !== "#")
        url = $el.attr("href");
      else if ($selectEl.attr("name"))
        url = `${$selectEl.attr("name").toLowerCase()}-select/`;
    }
    if (!url)
      url = ss.params.url;
    const multiple = $selectEl[0].multiple;
    const inputType = multiple ? "checkbox" : "radio";
    const selectId = id();
    extend(ss, {
      $el,
      el: $el[0],
      $selectEl,
      selectEl: $selectEl[0],
      $valueEl,
      valueEl: $valueEl && $valueEl[0],
      url,
      multiple,
      inputType,
      id: selectId,
      inputName: `${inputType}-${selectId}`,
      selectName: $selectEl.attr("name"),
      maxLength: $selectEl.attr("maxlength") || params.maxLength
    });
    $el[0].f7SmartSelect = ss;
    function onClick4() {
      ss.open();
    }
    function onChange() {
      const value = ss.$selectEl.val();
      ss.$el.trigger("smartselect:change", value);
      ss.emit("local::change smartSelectChange", ss, value);
      if (ss.vl) {
        ss.vl.clearCache();
      }
      ss.setValueText();
    }
    ss.attachEvents = function attachEvents2() {
      $el.on("click", onClick4);
      $el.on("change", "select", onChange);
    };
    ss.detachEvents = function detachEvents2() {
      $el.off("click", onClick4);
      $el.off("change", "select", onChange);
    };
    function handleInputChange() {
      let optionEl;
      let text2;
      const inputEl = this;
      const value = inputEl.value;
      let optionText = [];
      let displayAs;
      if (inputEl.type === "checkbox") {
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];
          if (optionEl.value === value) {
            optionEl.selected = inputEl.checked;
          }
          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-value-as");
            text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
            optionText.push(text2.trim());
          }
        }
        if (ss.maxLength) {
          ss.checkMaxLength();
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${value}"]`)[0];
        if (!optionEl) {
          optionEl = ss.$selectEl.find("option").filter((optEl) => optEl.value === value)[0];
        }
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-as");
        text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
        optionText = [text2];
        ss.selectEl.value = value;
      }
      ss.$selectEl.trigger("change");
      if (ss.params.setValueText) {
        ss.$valueEl.text(ss.formatValueText(optionText));
      }
      if (ss.params.closeOnSelect && ss.inputType === "radio") {
        ss.close();
      }
    }
    ss.attachInputsEvents = function attachInputsEvents() {
      ss.$containerEl.on("change", 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.detachInputsEvents = function detachInputsEvents() {
      ss.$containerEl.off("change", 'input[type="checkbox"], input[type="radio"]', handleInputChange);
    };
    ss.useModules();
    ss.init();
    return ss;
  }
  setValue(value) {
    const ss = this;
    let newValue = value;
    let optionText = [];
    let optionEl;
    let displayAs;
    let text2;
    if (ss.multiple) {
      if (!Array.isArray(newValue))
        newValue = [newValue];
      for (let i = 0; i < ss.selectEl.options.length; i += 1) {
        optionEl = ss.selectEl.options[i];
        if (newValue.indexOf(optionEl.value) >= 0) {
          optionEl.selected = true;
        } else {
          optionEl.selected = false;
        }
        if (optionEl.selected) {
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-value-as");
          text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
          optionText.push(text2.trim());
        }
      }
    } else {
      optionEl = ss.$selectEl.find(`option[value="${newValue}"]`)[0];
      if (optionEl) {
        displayAs = optionEl.dataset ? optionEl.dataset.displayAs : dom7_default(optionEl).data("display-as");
        text2 = displayAs && typeof displayAs !== "undefined" ? displayAs : optionEl.textContent;
        optionText = [text2];
      }
      ss.selectEl.value = newValue;
    }
    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText(optionText));
    }
    ss.$selectEl.trigger("change");
    return ss;
  }
  unsetValue() {
    const ss = this;
    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText([]));
    }
    ss.$selectEl.find("option").each((optionEl) => {
      optionEl.selected = false;
      optionEl.checked = false;
    });
    ss.$selectEl[0].value = null;
    if (ss.$containerEl) {
      ss.$containerEl.find(`input[name="${ss.inputName}"][type="checkbox"], input[name="${ss.inputName}"][type="radio"]`).prop("checked", false);
    }
    ss.$selectEl.trigger("change");
  }
  getValue() {
    const ss = this;
    return ss.$selectEl.val();
  }
  get view() {
    const {
      params,
      $el
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    }
    if (!view) {
      view = $el.parents(".view").length && $el.parents(".view")[0].f7View;
    }
    if (!view && params.openIn === "page") {
      throw Error("Smart Select requires initialized View");
    }
    return view;
  }
  checkMaxLength() {
    const ss = this;
    const $containerEl = ss.$containerEl;
    if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
      $containerEl.find('input[type="checkbox"]').each((inputEl) => {
        if (!inputEl.checked) {
          dom7_default(inputEl).parents("li").addClass("disabled");
        } else {
          dom7_default(inputEl).parents("li").removeClass("disabled");
        }
      });
    } else {
      $containerEl.find(".disabled").removeClass("disabled");
    }
  }
  formatValueText(values) {
    const ss = this;
    let textValue;
    if (ss.params.formatValueText) {
      textValue = ss.params.formatValueText.call(ss, values, ss);
    } else {
      textValue = values.join(", ");
    }
    return textValue;
  }
  setValueText(value) {
    const ss = this;
    let valueArray = [];
    if (typeof value !== "undefined") {
      if (Array.isArray(value)) {
        valueArray = value;
      } else {
        valueArray = [value];
      }
    } else {
      ss.$selectEl.find("option").each((optionEl) => {
        const $optionEl = dom7_default(optionEl);
        if (optionEl.selected) {
          const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data("display-value-as");
          if (displayAs && typeof displayAs !== "undefined") {
            valueArray.push(displayAs);
          } else {
            valueArray.push(optionEl.textContent.trim());
          }
        }
      });
    }
    if (ss.params.setValueText) {
      ss.$valueEl.text(ss.formatValueText(valueArray));
    }
  }
  getItemsData() {
    const ss = this;
    const theme = ss.app.theme;
    const items = [];
    let previousGroupEl;
    ss.$selectEl.find("option").each((optionEl) => {
      const $optionEl = dom7_default(optionEl);
      const optionData = $optionEl.dataset();
      const optionImage = optionData.optionImage || ss.params.optionImage;
      const optionIcon = optionData.optionIcon || ss.params.optionIcon;
      const optionIconIos = theme === "ios" && (optionData.optionIconIos || ss.params.optionIconIos);
      const optionIconMd = theme === "md" && (optionData.optionIconMd || ss.params.optionIconMd);
      const optionIconAurora = theme === "aurora" && (optionData.optionIconAurora || ss.params.optionIconAurora);
      const optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd || optionIconAurora;
      const optionColor = optionData.optionColor;
      let optionClassName = optionData.optionClass || "";
      if ($optionEl[0].disabled)
        optionClassName += " disabled";
      const optionGroupEl = $optionEl.parent("optgroup")[0];
      const optionGroupLabel = optionGroupEl && optionGroupEl.label;
      let optionIsLabel = false;
      if (optionGroupEl && optionGroupEl !== previousGroupEl) {
        optionIsLabel = true;
        previousGroupEl = optionGroupEl;
        items.push({
          groupLabel: optionGroupLabel,
          isLabel: optionIsLabel
        });
      }
      items.push({
        value: $optionEl[0].value,
        text: $optionEl[0].textContent.trim(),
        selected: $optionEl[0].selected,
        groupEl: optionGroupEl,
        groupLabel: optionGroupLabel,
        image: optionImage,
        icon: optionIcon,
        iconIos: optionIconIos,
        iconMd: optionIconMd,
        iconAurora: optionIconAurora,
        color: optionColor,
        className: optionClassName,
        disabled: $optionEl[0].disabled,
        id: ss.id,
        hasMedia: optionHasMedia,
        checkbox: ss.inputType === "checkbox",
        radio: ss.inputType === "radio",
        inputName: ss.inputName,
        inputType: ss.inputType
      });
    });
    ss.items = items;
    return items;
  }
  renderSearchbar() {
    const ss = this;
    if (ss.params.renderSearchbar)
      return ss.params.renderSearchbar.call(ss);
    return jsx_default2("form", {
      class: "searchbar"
    }, jsx_default2("div", {
      class: "searchbar-inner"
    }, jsx_default2("div", {
      class: "searchbar-input-wrap"
    }, jsx_default2("input", {
      type: "search",
      spellcheck: ss.params.searchbarSpellcheck || "false",
      placeholder: ss.params.searchbarPlaceholder
    }), jsx_default2("i", {
      class: "searchbar-icon"
    }), jsx_default2("span", {
      class: "input-clear-button"
    })), ss.params.searchbarDisableButton && jsx_default2("span", {
      class: "searchbar-disable-button"
    }, ss.params.searchbarDisableText)));
  }
  renderItem(item, index2) {
    const ss = this;
    if (ss.params.renderItem)
      return ss.params.renderItem.call(ss, item, index2);
    function getIconContent(iconValue) {
      if (iconValue === void 0) {
        iconValue = "";
      }
      if (iconValue.indexOf(":") >= 0) {
        return iconValue.split(":")[1];
      }
      return "";
    }
    function getIconClass(iconValue) {
      if (iconValue === void 0) {
        iconValue = "";
      }
      if (iconValue.indexOf(":") >= 0) {
        let className = iconValue.split(":")[0];
        if (className === "f7")
          className = "f7-icons";
        if (className === "material")
          className = "material-icons";
        return className;
      }
      return iconValue;
    }
    let itemHtml;
    if (item.isLabel) {
      itemHtml = `<li class="item-divider">${item.groupLabel}</li>`;
    } else {
      let selected = item.selected;
      let disabled;
      if (ss.params.virtualList) {
        const ssValue = ss.getValue();
        selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;
        if (ss.multiple) {
          disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
        }
      }
      const {
        icon,
        iconIos,
        iconMd,
        iconAurora
      } = item;
      const hasIcon = icon || iconIos || iconMd || iconAurora;
      const iconContent = getIconContent(icon || iconIos || iconMd || iconAurora || "");
      const iconClass = getIconClass(icon || iconIos || iconMd || iconAurora || "");
      itemHtml = jsx_default2("li", {
        class: `${item.className || ""}${disabled ? " disabled" : ""}`
      }, jsx_default2("label", {
        class: `item-${item.inputType} item-content`
      }, jsx_default2("input", {
        type: item.inputType,
        name: item.inputName,
        value: item.value,
        _checked: selected
      }), jsx_default2("i", {
        class: `icon icon-${item.inputType}`
      }), item.hasMedia && jsx_default2("div", {
        class: "item-media"
      }, hasIcon && jsx_default2("i", {
        class: `icon ${iconClass}`
      }, iconContent), item.image && jsx_default2("img", {
        src: item.image
      })), jsx_default2("div", {
        class: "item-inner"
      }, jsx_default2("div", {
        class: `item-title${item.color ? ` text-color-${item.color}` : ""}`
      }, item.text))));
    }
    return itemHtml;
  }
  renderItems() {
    const ss = this;
    if (ss.params.renderItems)
      return ss.params.renderItems.call(ss, ss.items);
    const itemsHtml = `
      ${ss.items.map((item, index2) => `${ss.renderItem(item, index2)}`).join("")}
    `;
    return itemsHtml;
  }
  renderPage() {
    const ss = this;
    if (ss.params.renderPage)
      return ss.params.renderPage.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === "undefined") {
      const $itemTitleEl = ss.$el.find(".item-title");
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : "";
    }
    const cssClass = ss.params.cssClass;
    return jsx_default2("div", {
      class: `page smart-select-page ${cssClass}`,
      "data-name": "smart-select-page",
      "data-select-name": ss.selectName
    }, jsx_default2("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, jsx_default2("div", {
      class: "navbar-bg"
    }), jsx_default2("div", {
      class: `navbar-inner sliding ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, jsx_default2("div", {
      class: "left"
    }, jsx_default2("a", {
      class: "link back"
    }, jsx_default2("i", {
      class: "icon icon-back"
    }), jsx_default2("span", {
      class: "if-not-md"
    }, ss.params.pageBackLinkText))), pageTitle && jsx_default2("div", {
      class: "title"
    }, pageTitle), ss.params.searchbar && jsx_default2("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && jsx_default2("div", {
      class: "searchbar-backdrop"
    }), jsx_default2("div", {
      class: "page-content"
    }, jsx_default2("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default2("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }
  renderPopup() {
    const ss = this;
    if (ss.params.renderPopup)
      return ss.params.renderPopup.call(ss, ss.items);
    let pageTitle = ss.params.pageTitle;
    if (typeof pageTitle === "undefined") {
      const $itemTitleEl = ss.$el.find(".item-title");
      pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : "";
    }
    const cssClass = ss.params.cssClass || "";
    return jsx_default2("div", {
      class: `popup smart-select-popup ${cssClass} ${ss.params.popupTabletFullscreen ? "popup-tablet-fullscreen" : ""}`,
      "data-select-name": ss.selectName
    }, jsx_default2("div", {
      class: "view"
    }, jsx_default2("div", {
      class: `page smart-select-page ${ss.params.searchbar ? "page-with-subnavbar" : ""}`,
      "data-name": "smart-select-page"
    }, jsx_default2("div", {
      class: `navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ""}`
    }, jsx_default2("div", {
      class: "navbar-bg"
    }), jsx_default2("div", {
      class: "navbar-inner sliding"
    }, pageTitle && jsx_default2("div", {
      class: "title"
    }, pageTitle), jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link popup-close",
      "data-popup": `.smart-select-popup[data-select-name='${ss.selectName}']`
    }, ss.params.popupCloseLinkText)), ss.params.searchbar && jsx_default2("div", {
      class: "subnavbar"
    }, ss.renderSearchbar()))), ss.params.searchbar && jsx_default2("div", {
      class: "searchbar-backdrop"
    }), jsx_default2("div", {
      class: "page-content"
    }, jsx_default2("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default2("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))))));
  }
  renderSheet() {
    const ss = this;
    if (ss.params.renderSheet)
      return ss.params.renderSheet.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    return jsx_default2("div", {
      class: `sheet-modal smart-select-sheet ${cssClass}`,
      "data-select-name": ss.selectName
    }, jsx_default2("div", {
      class: `toolbar toolbar-top ${ss.params.toolbarColorTheme ? `color-${ss.params.toolbarColorTheme}` : ""}`
    }, jsx_default2("div", {
      class: "toolbar-inner"
    }, jsx_default2("div", {
      class: "left"
    }), jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link sheet-close"
    }, ss.params.sheetCloseLinkText)))), jsx_default2("div", {
      class: "sheet-modal-inner"
    }, jsx_default2("div", {
      class: "page-content"
    }, jsx_default2("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default2("ul", null, !ss.params.virtualList && ss.renderItems(ss.items))))));
  }
  renderPopover() {
    const ss = this;
    if (ss.params.renderPopover)
      return ss.params.renderPopover.call(ss, ss.items);
    const cssClass = ss.params.cssClass;
    return jsx_default2("div", {
      class: `popover smart-select-popover ${cssClass}`,
      "data-select-name": ss.selectName
    }, jsx_default2("div", {
      class: "popover-inner"
    }, jsx_default2("div", {
      class: `list smart-select-list-${ss.id} ${ss.params.virtualList ? " virtual-list" : ""} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ""}`
    }, jsx_default2("ul", null, !ss.params.virtualList && ss.renderItems(ss.items)))));
  }
  scrollToSelectedItem() {
    const ss = this;
    const {
      params,
      $containerEl
    } = ss;
    if (!ss.opened)
      return ss;
    if (params.virtualList) {
      let selectedIndex;
      ss.vl.items.forEach((item, index2) => {
        if (typeof selectedIndex === "undefined" && item.selected) {
          selectedIndex = index2;
        }
      });
      if (typeof selectedIndex !== "undefined") {
        ss.vl.scrollToItem(selectedIndex);
      }
    } else {
      const $selectedItemEl = $containerEl.find("input:checked").parents("li");
      if (!$selectedItemEl.length)
        return ss;
      const $scrollableEl = $containerEl.find(".page-content, .popover-inner");
      if (!$scrollableEl.length)
        return ss;
      $scrollableEl.scrollTop($selectedItemEl.offset().top - $scrollableEl.offset().top - parseInt($scrollableEl.css("padding-top"), 10));
    }
    return ss;
  }
  onOpen(type, containerEl) {
    const ss = this;
    const app = ss.app;
    const $containerEl = dom7_default(containerEl);
    ss.$containerEl = $containerEl;
    ss.openedIn = type;
    ss.opened = true;
    if (ss.params.virtualList) {
      ss.vl = app.virtualList.create({
        el: $containerEl.find(".virtual-list"),
        items: ss.items,
        renderItem: ss.renderItem.bind(ss),
        height: ss.params.virtualListHeight,
        searchByItem(query, item) {
          if (item.text && remove_diacritics_default(item.text).toLowerCase().indexOf(query.trim().toLowerCase()) >= 0)
            return true;
          return false;
        }
      });
    }
    if (ss.params.scrollToSelectedItem) {
      ss.scrollToSelectedItem();
    }
    if (ss.params.searchbar) {
      let $searchbarEl = $containerEl.find(".searchbar");
      if (type === "page" && app.theme === "ios") {
        $searchbarEl = dom7_default(app.navbar.getElByPage($containerEl)).find(".searchbar");
      }
      if (ss.params.appendSearchbarNotFound && (type === "page" || type === "popup")) {
        let $notFoundEl = null;
        if (typeof ss.params.appendSearchbarNotFound === "string") {
          $notFoundEl = dom7_default(`<div class="block searchbar-not-found">${ss.params.appendSearchbarNotFound}</div>`);
        } else if (typeof ss.params.appendSearchbarNotFound === "boolean") {
          $notFoundEl = dom7_default('<div class="block searchbar-not-found">Nothing found</div>');
        } else {
          $notFoundEl = ss.params.appendSearchbarNotFound;
        }
        if ($notFoundEl) {
          $containerEl.find(".page-content").append($notFoundEl[0]);
        }
      }
      const searchbarParams = extend({
        el: $searchbarEl,
        backdropEl: $containerEl.find(".searchbar-backdrop"),
        searchContainer: `.smart-select-list-${ss.id}`,
        searchIn: ".item-title"
      }, typeof ss.params.searchbar === "object" ? ss.params.searchbar : {});
      ss.searchbar = app.searchbar.create(searchbarParams);
    }
    if (ss.maxLength) {
      ss.checkMaxLength();
    }
    if (ss.params.closeOnSelect) {
      ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents("label").once("click", () => {
        ss.close();
      });
    }
    ss.attachInputsEvents();
    ss.$el.trigger("smartselect:open");
    ss.emit("local::open smartSelectOpen", ss);
  }
  onOpened() {
    const ss = this;
    ss.$el.trigger("smartselect:opened");
    ss.emit("local::opened smartSelectOpened", ss);
  }
  onClose() {
    const ss = this;
    if (ss.destroyed)
      return;
    if (ss.vl && ss.vl.destroy) {
      ss.vl.destroy();
      ss.vl = null;
      delete ss.vl;
    }
    if (ss.searchbar && ss.searchbar.destroy) {
      ss.searchbar.destroy();
      ss.searchbar = null;
      delete ss.searchbar;
    }
    ss.detachInputsEvents();
    ss.$el.trigger("smartselect:close");
    ss.emit("local::close smartSelectClose", ss);
  }
  onClosed() {
    const ss = this;
    if (ss.destroyed)
      return;
    ss.opened = false;
    ss.$containerEl = null;
    delete ss.$containerEl;
    ss.$el.trigger("smartselect:closed");
    ss.emit("local::closed smartSelectClosed", ss);
  }
  openPage() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const pageHtml = ss.renderPage(ss.items);
    ss.view.router.navigate({
      url: ss.url,
      route: {
        content: pageHtml,
        path: ss.url,
        on: {
          pageBeforeIn(e, page) {
            ss.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            ss.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            ss.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            ss.onClosed("page", page.el);
          }
        }
      }
    });
    return ss;
  }
  openPopup() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const popupHtml = ss.renderPopup(ss.items);
    const popupParams = {
      content: popupHtml,
      push: ss.params.popupPush,
      swipeToClose: ss.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ss.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          ss.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          ss.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          ss.onClosed("popup", popup.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popup: popupParams
        }
      });
    } else {
      ss.modal = ss.app.popup.create(popupParams).open();
    }
    return ss;
  }
  openSheet() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const sheetHtml = ss.renderSheet(ss.items);
    const sheetParams = {
      content: sheetHtml,
      backdrop: ss.params.sheetBackdrop,
      scrollToEl: ss.$el,
      closeByOutsideClick: true,
      push: ss.params.sheetPush,
      swipeToClose: ss.params.sheetSwipeToClose,
      on: {
        sheetOpen(sheet) {
          ss.onOpen("sheet", sheet.el);
        },
        sheetOpened(sheet) {
          ss.onOpened("sheet", sheet.el);
        },
        sheetClose(sheet) {
          ss.onClose("sheet", sheet.el);
        },
        sheetClosed(sheet) {
          ss.onClosed("sheet", sheet.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          sheet: sheetParams
        }
      });
    } else {
      ss.modal = ss.app.sheet.create(sheetParams).open();
    }
    return ss;
  }
  openPopover() {
    const ss = this;
    if (ss.opened)
      return ss;
    ss.getItemsData();
    const popoverHtml = ss.renderPopover(ss.items);
    const popoverParams = {
      content: popoverHtml,
      targetEl: ss.$el,
      on: {
        popoverOpen(popover) {
          ss.onOpen("popover", popover.el);
        },
        popoverOpened(popover) {
          ss.onOpened("popover", popover.el);
        },
        popoverClose(popover) {
          ss.onClose("popover", popover.el);
        },
        popoverClosed(popover) {
          ss.onClosed("popover", popover.el);
        }
      }
    };
    if (ss.params.routableModals && ss.view) {
      ss.view.router.navigate({
        url: ss.url,
        route: {
          path: ss.url,
          popover: popoverParams
        }
      });
    } else {
      ss.modal = ss.app.popover.create(popoverParams).open();
    }
    return ss;
  }
  open(type) {
    const ss = this;
    if (ss.opened)
      return ss;
    let prevented = false;
    function prevent() {
      prevented = true;
    }
    if (ss.$el) {
      ss.$el.trigger("smartselect:beforeopen", {
        prevent
      });
    }
    ss.emit("local::beforeOpen smartSelectBeforeOpen", ss, prevent);
    if (prevented)
      return ss;
    const openIn = type || ss.params.openIn;
    ss[`open${openIn.split("").map((el, index2) => {
      if (index2 === 0)
        return el.toUpperCase();
      return el;
    }).join("")}`]();
    return ss;
  }
  close() {
    const ss = this;
    if (!ss.opened)
      return ss;
    if (ss.params.routableModals && ss.view || ss.openedIn === "page") {
      ss.view.router.back();
    } else {
      ss.modal.once("modalClosed", () => {
        nextTick(() => {
          if (ss.destroyed)
            return;
          ss.modal.destroy();
          delete ss.modal;
        });
      });
      ss.modal.close();
    }
    return ss;
  }
  init() {
    const ss = this;
    ss.attachEvents();
    ss.setValueText();
  }
  destroy() {
    const ss = this;
    ss.emit("local::beforeDestroy smartSelectBeforeDestroy", ss);
    ss.$el.trigger("smartselect:beforedestroy");
    ss.detachEvents();
    delete ss.$el[0].f7SmartSelect;
    deleteProps(ss);
    ss.destroyed = true;
  }
};
var smart_select_class_default = SmartSelect;

// node_modules/framework7/components/smart-select/smart-select.js
var smart_select_default = {
  name: "smartSelect",
  params: {
    smartSelect: {
      el: void 0,
      valueEl: void 0,
      setValueText: true,
      formatValueText: null,
      openIn: "page",
      popupPush: false,
      popupSwipeToClose: void 0,
      sheetPush: false,
      sheetSwipeToClose: void 0,
      sheetBackdrop: false,
      pageTitle: void 0,
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      popupTabletFullscreen: false,
      sheetCloseLinkText: "Done",
      searchbar: false,
      searchbarPlaceholder: "Search",
      searchbarDisableText: "Cancel",
      searchbarDisableButton: void 0,
      searchbarSpellcheck: false,
      closeOnSelect: false,
      virtualList: false,
      virtualListHeight: void 0,
      scrollToSelectedItem: false,
      formColorTheme: void 0,
      navbarColorTheme: void 0,
      routableModals: false,
      url: "select/",
      cssClass: "",
      renderPage: void 0,
      renderPopup: void 0,
      renderSheet: void 0,
      renderPopover: void 0,
      renderItems: void 0,
      renderItem: void 0,
      renderSearchbar: void 0
    }
  },
  static: {
    SmartSelect: smart_select_class_default
  },
  create() {
    const app = this;
    app.smartSelect = extend(ConstructorMethods({
      defaultSelector: ".smart-select",
      constructor: smart_select_class_default,
      app,
      domProp: "f7SmartSelect"
    }), {
      open(smartSelectEl) {
        const ss = app.smartSelect.get(smartSelectEl);
        if (ss && ss.open)
          return ss.open();
        return void 0;
      },
      close(smartSelectEl) {
        const ss = app.smartSelect.get(smartSelectEl);
        if (ss && ss.close)
          return ss.close();
        return void 0;
      }
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".smart-select-init").each((smartSelectEl) => {
        app.smartSelect.create(extend({
          el: smartSelectEl
        }, dom7_default(smartSelectEl).dataset()));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".smart-select-init").each((smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".smart-select-init").each((smartSelectEl) => {
        app.smartSelect.create(extend({
          el: smartSelectEl
        }, dom7_default(smartSelectEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".smart-select-init").each((smartSelectEl) => {
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      });
    }
  },
  clicks: {
    ".smart-select": function open3($clickedEl, data) {
      const app = this;
      if (!$clickedEl[0].f7SmartSelect) {
        const ss = app.smartSelect.create(extend({
          el: $clickedEl
        }, data));
        ss.open();
      }
    }
  },
  vnode: {
    "smart-select-init": {
      insert(vnode) {
        const app = this;
        const smartSelectEl = vnode.elm;
        app.smartSelect.create(extend({
          el: smartSelectEl
        }, dom7_default(smartSelectEl).dataset()));
      },
      destroy(vnode) {
        const smartSelectEl = vnode.elm;
        if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
          smartSelectEl.f7SmartSelect.destroy();
        }
      }
    }
  }
};

// node_modules/framework7/components/grid/grid.js
function getElMinSize(dimension, $el) {
  let minSize = $el.css(`min-${dimension}`);
  if (minSize === "auto" || minSize === "none") {
    minSize = 0;
  } else if (minSize.indexOf("px") >= 0) {
    minSize = parseFloat(minSize);
  } else if (minSize.indexOf("%") >= 0) {
    minSize = $el.parent()[0][dimension === "height" ? "offsetHeight" : "offsetWidth"] * parseFloat(minSize) / 100;
  }
  return minSize;
}
function getElMaxSize(dimension, $el) {
  let maxSize = $el.css(`max-${dimension}`);
  if (maxSize === "auto" || maxSize === "none") {
    maxSize = null;
  } else if (maxSize.indexOf("px") >= 0) {
    maxSize = parseFloat(maxSize);
  } else if (maxSize.indexOf("%") >= 0) {
    maxSize = $el.parent()[0][dimension === "height" ? "offsetHeight" : "offsetWidth"] * parseFloat(maxSize) / 100;
  }
  return maxSize;
}
var Grid = {
  init() {
    const app = this;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let $resizeHandlerEl;
    let $prevResizableEl;
    let $nextResizableEl;
    let prevElSize;
    let prevElMinSize;
    let prevElMaxSize;
    let nextElSize;
    let nextElMinSize;
    let nextElMaxSize;
    let parentSize;
    let itemsInFlow;
    let gapSize;
    let isScrolling;
    function handleTouchStart(e) {
      if (isTouched || isMoved)
        return;
      $resizeHandlerEl = dom7_default(e.target).closest(".resize-handler");
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      isTouched = true;
      $prevResizableEl = void 0;
      $nextResizableEl = void 0;
      isScrolling = void 0;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const isRow = $resizeHandlerEl.parent(".row").length === 1;
      const sizeProp = isRow ? "height" : "width";
      const getSizeProp = isRow ? "offsetHeight" : "offsetWidth";
      if (!isMoved) {
        $prevResizableEl = $resizeHandlerEl.parent(isRow ? ".row" : ".col");
        if ($prevResizableEl.length && (!$prevResizableEl.hasClass("resizable") || $prevResizableEl.hasClass("resizable-fixed"))) {
          $prevResizableEl = $prevResizableEl.prevAll(".resizable:not(.resizable-fixed)").eq(0);
        }
        $nextResizableEl = $prevResizableEl.next(isRow ? ".row" : ".col");
        if ($nextResizableEl.length && (!$nextResizableEl.hasClass("resizable") || $nextResizableEl.hasClass("resizable-fixed"))) {
          $nextResizableEl = $nextResizableEl.nextAll(".resizable:not(.resizable-fixed)").eq(0);
        }
        if ($prevResizableEl.length) {
          prevElSize = $prevResizableEl[0][getSizeProp];
          prevElMinSize = getElMinSize(sizeProp, $prevResizableEl);
          prevElMaxSize = getElMaxSize(sizeProp, $prevResizableEl);
          parentSize = $prevResizableEl.parent()[0][getSizeProp];
          itemsInFlow = $prevResizableEl.parent().children(isRow ? ".row" : '[class*="col-"], .col').length;
          gapSize = parseFloat($prevResizableEl.css(isRow ? "--f7-grid-row-gap" : "--f7-grid-gap"));
        }
        if ($nextResizableEl.length) {
          nextElSize = $nextResizableEl[0][getSizeProp];
          nextElMinSize = getElMinSize(sizeProp, $nextResizableEl);
          nextElMaxSize = getElMaxSize(sizeProp, $nextResizableEl);
          if (!$prevResizableEl.length) {
            parentSize = $nextResizableEl.parent()[0][getSizeProp];
            itemsInFlow = $nextResizableEl.parent().children(isRow ? ".row" : '[class*="col-"], .col').length;
            gapSize = parseFloat($nextResizableEl.css(isRow ? "--f7-grid-row-gap" : "--f7-grid-gap"));
          }
        }
      }
      isMoved = true;
      const touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined" && !isRow) {
        isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
      }
      if (isScrolling) {
        isTouched = false;
        isMoved = false;
        return;
      }
      const isAbsolute = $prevResizableEl.hasClass("resizable-absolute") || $nextResizableEl.hasClass("resizable-absolute");
      const resizeNextEl = !isRow || isRow && !isAbsolute;
      if (resizeNextEl && !$nextResizableEl.length || !$prevResizableEl.length) {
        isTouched = false;
        isMoved = false;
        return;
      }
      e.preventDefault();
      let diff = isRow ? touchCurrentY - touchStartY : touchCurrentX - touchStartX;
      let prevElNewSize;
      let nextElNewSize;
      if ($prevResizableEl.length) {
        prevElNewSize = prevElSize + diff;
        if (prevElNewSize < prevElMinSize) {
          prevElNewSize = prevElMinSize;
          diff = prevElNewSize - prevElSize;
        }
        if (prevElMaxSize && prevElNewSize > prevElMaxSize) {
          prevElNewSize = prevElMaxSize;
          diff = prevElNewSize - prevElSize;
        }
      }
      if ($nextResizableEl.length && resizeNextEl) {
        nextElNewSize = nextElSize - diff;
        if (nextElNewSize < nextElMinSize) {
          nextElNewSize = nextElMinSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
        if (nextElMaxSize && nextElNewSize > nextElMaxSize) {
          nextElNewSize = nextElMaxSize;
          diff = nextElSize - nextElNewSize;
          prevElNewSize = prevElSize + diff;
        }
      }
      if (isAbsolute) {
        $prevResizableEl[0].style[sizeProp] = `${prevElNewSize}px`;
        if (resizeNextEl) {
          $nextResizableEl[0].style[sizeProp] = `${nextElNewSize}px`;
        }
        $prevResizableEl.trigger("grid:resize");
        $nextResizableEl.trigger("grid:resize");
        app.emit("gridResize", $prevResizableEl[0]);
        app.emit("gridResize", $nextResizableEl[0]);
        return;
      }
      const gapAddSize = (itemsInFlow - 1) * gapSize / itemsInFlow;
      const gapAddSizeCSS = isRow ? `${itemsInFlow - 1} * var(--f7-grid-row-gap) / ${itemsInFlow}` : "(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)";
      const prevElNewSizeNormalized = prevElNewSize + gapAddSize;
      const nextElNewSizeNormalized = nextElNewSize + gapAddSize;
      $prevResizableEl[0].style[sizeProp] = `calc(${prevElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $nextResizableEl[0].style[sizeProp] = `calc(${nextElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
      $prevResizableEl.trigger("grid:resize");
      $nextResizableEl.trigger("grid:resize");
      app.emit("gridResize", $prevResizableEl[0]);
      app.emit("gridResize", $nextResizableEl[0]);
    }
    function handleTouchEnd() {
      if (!isTouched)
        return;
      if (!isMoved) {
        isTouched = false;
      }
      isTouched = false;
      isMoved = false;
    }
    const document = getDocument();
    dom7_default(document).on(app.touchEvents.start, ".col > .resize-handler, .row > .resize-handler", handleTouchStart);
    app.on("touchmove", handleTouchMove);
    app.on("touchend", handleTouchEnd);
  }
};
var grid_default = {
  name: "grid",
  create() {
    const app = this;
    extend(app, {
      grid: {
        init: Grid.init.bind(app)
      }
    });
  },
  on: {
    init() {
      const app = this;
      app.grid.init();
    }
  }
};

// node_modules/framework7/components/calendar/calendar-class.js
var Calendar = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const calendar = this;
    calendar.params = extend({}, app.params.calendar, params);
    let $containerEl;
    if (calendar.params.containerEl) {
      $containerEl = dom7_default(calendar.params.containerEl);
      if ($containerEl.length === 0)
        return calendar;
    }
    let $inputEl;
    if (calendar.params.inputEl) {
      $inputEl = dom7_default(calendar.params.inputEl);
    }
    const isHorizontal = calendar.params.direction === "horizontal";
    let inverter = 1;
    if (isHorizontal) {
      inverter = app.rtl ? -1 : 1;
    }
    extend(calendar, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      initialized: false,
      opened: false,
      url: calendar.params.url,
      isHorizontal,
      inverter,
      animating: false,
      allowTouchMove: true,
      hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple
    });
    calendar.dayFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        day: "numeric"
      });
      return formatter.format(date).replace(/日/, "");
    };
    calendar.monthFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        month: "long"
      });
      return formatter.format(date);
    };
    calendar.yearFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, {
        year: "numeric"
      });
      return formatter.format(date);
    };
    calendar.timeSelectorFormatter = (date) => {
      const formatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);
      return formatter.format(date);
    };
    const timeFormatCheckDate = calendar.timeSelectorFormatter(new Date()).toLowerCase();
    calendar.is12HoursFormat = timeFormatCheckDate.indexOf("pm") >= 0 || timeFormatCheckDate.indexOf("am") >= 0;
    let {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar.params;
    const {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    } = calendar.getIntlNames();
    if (monthNames === "auto")
      monthNames = monthNamesIntl;
    if (monthNamesShort === "auto")
      monthNamesShort = monthNamesShortIntl;
    if (dayNames === "auto")
      dayNames = dayNamesIntl;
    if (dayNamesShort === "auto")
      dayNamesShort = dayNamesShortIntl;
    extend(calendar, {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    });
    function onInputClick() {
      calendar.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onInputClear() {
      calendar.setValue([]);
      if (calendar.opened) {
        calendar.update();
      }
    }
    function onHtmlClick(e) {
      const $targetEl = dom7_default(e.target);
      if (calendar.destroyed || !calendar.params)
        return;
      if (calendar.isPopover())
        return;
      if (!calendar.opened || calendar.closing)
        return;
      if ($targetEl.closest('[class*="backdrop"]').length)
        return;
      if (calendar.monthPickerPopover || calendar.yearPickerPopover || calendar.timePickerPopover)
        return;
      if ($inputEl && $inputEl.length > 0) {
        if ($targetEl[0] !== $inputEl[0] && $targetEl.closest(".sheet-modal, .calendar-modal").length === 0) {
          calendar.close();
        }
      } else if (dom7_default(e.target).closest(".sheet-modal, .calendar-modal").length === 0) {
        calendar.close();
      }
    }
    extend(calendar, {
      attachInputEvents() {
        calendar.$inputEl.on("click", onInputClick);
        calendar.$inputEl.on("input:clear", onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.on("focus mousedown", onInputFocus);
          if (calendar.$inputEl[0]) {
            calendar.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        calendar.$inputEl.off("click", onInputClick);
        calendar.$inputEl.off("input:clear", onInputClear);
        if (calendar.params.inputReadOnly) {
          calendar.$inputEl.off("focus mousedown", onInputFocus);
          if (calendar.$inputEl[0]) {
            delete calendar.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app.on("click", onHtmlClick);
      },
      detachHtmlEvents() {
        app.off("click", onHtmlClick);
      }
    });
    calendar.attachCalendarEvents = function attachCalendarEvents() {
      let allowItemClick = true;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;
      let touchStartTime;
      let touchEndTime;
      let currentTranslate;
      let wrapperWidth;
      let wrapperHeight;
      let percentage;
      let touchesDiff;
      let isScrolling;
      const {
        $el,
        $wrapperEl
      } = calendar;
      function handleTouchStart(e) {
        if (isMoved || isTouched)
          return;
        isTouched = true;
        touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        touchStartTime = new Date().getTime();
        percentage = 0;
        allowItemClick = true;
        isScrolling = void 0;
        currentTranslate = calendar.monthsTranslate;
      }
      function handleTouchMove(e) {
        if (!isTouched)
          return;
        const {
          isHorizontal: isH
        } = calendar;
        touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === "undefined") {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }
        if (isH && isScrolling || !calendar.allowTouchMove) {
          isTouched = false;
          return;
        }
        e.preventDefault();
        if (calendar.animating) {
          isTouched = false;
          return;
        }
        allowItemClick = false;
        if (!isMoved) {
          isMoved = true;
          wrapperWidth = $wrapperEl[0].offsetWidth;
          wrapperHeight = $wrapperEl[0].offsetHeight;
          $wrapperEl.transition(0);
        }
        touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
        percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
        currentTranslate = (calendar.monthsTranslate * calendar.inverter + percentage) * 100;
        $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }
        isTouched = false;
        isMoved = false;
        touchEndTime = new Date().getTime();
        if (touchEndTime - touchStartTime < 300) {
          if (Math.abs(touchesDiff) < 10) {
            calendar.resetMonth();
          } else if (touchesDiff >= 10) {
            if (app.rtl)
              calendar.nextMonth();
            else
              calendar.prevMonth();
          } else if (app.rtl)
            calendar.prevMonth();
          else
            calendar.nextMonth();
        } else if (percentage <= -0.5) {
          if (app.rtl)
            calendar.prevMonth();
          else
            calendar.nextMonth();
        } else if (percentage >= 0.5) {
          if (app.rtl)
            calendar.nextMonth();
          else
            calendar.prevMonth();
        } else {
          calendar.resetMonth();
        }
        setTimeout(() => {
          allowItemClick = true;
        }, 100);
      }
      function handleDayClick(e) {
        if (!allowItemClick)
          return;
        let $dayEl = dom7_default(e.target).parents(".calendar-day");
        if ($dayEl.length === 0 && dom7_default(e.target).hasClass("calendar-day")) {
          $dayEl = dom7_default(e.target);
        }
        if ($dayEl.length === 0)
          return;
        if ($dayEl.hasClass("calendar-day-disabled"))
          return;
        if (!calendar.params.rangePicker) {
          if ($dayEl.hasClass("calendar-day-next"))
            calendar.nextMonth();
          if ($dayEl.hasClass("calendar-day-prev"))
            calendar.prevMonth();
        }
        const dateYear = parseInt($dayEl.attr("data-year"), 10);
        const dateMonth = parseInt($dayEl.attr("data-month"), 10);
        const dateDay = parseInt($dayEl.attr("data-day"), 10);
        calendar.emit("local::dayClick calendarDayClick", calendar, $dayEl[0], dateYear, dateMonth, dateDay);
        if (!$dayEl.hasClass("calendar-day-selected") || calendar.params.multiple || calendar.params.rangePicker) {
          const valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);
          if (calendar.hasTimePicker) {
            if (calendar.value && calendar.value[0]) {
              valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
            } else {
              valueToAdd.setHours(new Date().getHours(), new Date().getMinutes());
            }
          }
          calendar.addValue(valueToAdd);
        }
        if (calendar.params.closeOnSelect) {
          if (calendar.params.rangePicker && calendar.value.length === 2 || !calendar.params.rangePicker) {
            calendar.close();
          }
        }
      }
      function onNextMonthClick() {
        calendar.nextMonth();
      }
      function onPrevMonthClick() {
        calendar.prevMonth();
      }
      function onNextYearClick() {
        calendar.nextYear();
      }
      function onPrevYearClick() {
        calendar.prevYear();
      }
      function onMonthSelectorClick() {
        calendar.openMonthPicker();
      }
      function onYearSelectorClick() {
        calendar.openYearPicker();
      }
      function onTimeSelectorClick() {
        calendar.openTimePicker();
      }
      const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
        passive: true,
        capture: false
      } : false;
      $el.find(".calendar-prev-month-button").on("click", onPrevMonthClick);
      $el.find(".calendar-next-month-button").on("click", onNextMonthClick);
      $el.find(".calendar-prev-year-button").on("click", onPrevYearClick);
      $el.find(".calendar-next-year-button").on("click", onNextYearClick);
      if (calendar.params.monthPicker) {
        $el.find(".current-month-value").on("click", onMonthSelectorClick);
      }
      if (calendar.params.yearPicker) {
        $el.find(".current-year-value").on("click", onYearSelectorClick);
      }
      if (calendar.hasTimePicker) {
        $el.find(".calendar-time-selector a").on("click", onTimeSelectorClick);
      }
      $wrapperEl.on("click", handleDayClick);
      if (calendar.params.touchMove) {
        $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on("touchmove:active", handleTouchMove);
        app.on("touchend:passive", handleTouchEnd);
      }
      calendar.detachCalendarEvents = function detachCalendarEvents() {
        $el.find(".calendar-prev-month-button").off("click", onPrevMonthClick);
        $el.find(".calendar-next-month-button").off("click", onNextMonthClick);
        $el.find(".calendar-prev-year-button").off("click", onPrevYearClick);
        $el.find(".calendar-next-year-button").off("click", onNextYearClick);
        if (calendar.params.monthPicker) {
          $el.find(".current-month-value").off("click", onMonthSelectorClick);
        }
        if (calendar.params.yearPicker) {
          $el.find(".current-year-value").off("click", onYearSelectorClick);
        }
        if (calendar.hasTimePicker) {
          $el.find(".calendar-time-selector a").off("click", onTimeSelectorClick);
        }
        $wrapperEl.off("click", handleDayClick);
        if (calendar.params.touchMove) {
          $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
          app.off("touchmove:active", handleTouchMove);
          app.off("touchend:passive", handleTouchEnd);
        }
      };
    };
    calendar.init();
    return calendar;
  }
  get view() {
    const {
      $inputEl,
      app,
      params
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  getIntlNames() {
    const calendar = this;
    const locale = calendar.params.locale;
    const monthNamesIntl = [];
    const monthNamesShortIntl = [];
    const dayNamesIntl = [];
    const dayNamesShortIntl = [];
    const formatterMonthNames = new Intl.DateTimeFormat(locale, {
      month: "long"
    });
    const formatterMonthNamesShort = new Intl.DateTimeFormat(locale, {
      month: "short"
    });
    const formatterDayNames = new Intl.DateTimeFormat(locale, {
      weekday: "long"
    });
    const formatterDayNamesShort = new Intl.DateTimeFormat(locale, {
      weekday: "short"
    });
    let year;
    let yearStarted;
    let yearEnded;
    for (let i = 0; i < 24; i += 1) {
      const date = new Date().setMonth(i, 1);
      const currentYear = calendar.yearFormatter(date);
      if (year && currentYear !== year) {
        if (yearStarted)
          yearEnded = true;
        yearStarted = true;
        year = currentYear;
      }
      if (!year) {
        year = currentYear;
      }
      if (yearStarted && year === currentYear && !yearEnded) {
        monthNamesIntl.push(formatterMonthNames.format(date));
        monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
      }
    }
    const weekDay = new Date().getDay();
    for (let i = 0; i < 7; i += 1) {
      const date = new Date().getTime() + (i - weekDay) * 24 * 60 * 60 * 1e3;
      dayNamesIntl.push(formatterDayNames.format(date));
      dayNamesShortIntl.push(formatterDayNamesShort.format(date));
    }
    return {
      monthNamesIntl,
      monthNamesShortIntl,
      dayNamesIntl,
      dayNamesShortIntl
    };
  }
  normalizeDate(date) {
    const calendar = this;
    const d = new Date(date);
    if (calendar.hasTimePicker) {
      return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
    }
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }
  normalizeValues(values) {
    const calendar = this;
    let newValues = [];
    if (values && Array.isArray(values)) {
      newValues = values.map((val) => calendar.normalizeDate(val));
    }
    return newValues;
  }
  initInput() {
    const calendar = this;
    if (!calendar.$inputEl)
      return;
    if (calendar.params.inputReadOnly)
      calendar.$inputEl.prop("readOnly", true);
  }
  isPopover() {
    const calendar = this;
    const {
      app,
      modal,
      params
    } = calendar;
    const device = getDevice();
    if (params.openIn === "sheet")
      return false;
    if (modal && modal.type !== "popover")
      return false;
    if (!calendar.inline && calendar.inputEl) {
      if (params.openIn === "popover")
        return true;
      if (device.ios) {
        return !!device.ipad;
      }
      if (app.width >= 768) {
        return true;
      }
      if (device.desktop && app.theme === "aurora") {
        return true;
      }
    }
    return false;
  }
  formatDate(d) {
    const calendar = this;
    const date = new Date(d);
    const year = date.getFullYear();
    const month = date.getMonth();
    const month1 = month + 1;
    const day = date.getDate();
    const weekDay = date.getDay();
    const {
      monthNames,
      monthNamesShort,
      dayNames,
      dayNamesShort
    } = calendar;
    const {
      dateFormat,
      locale
    } = calendar.params;
    function twoDigits(number) {
      return number < 10 ? `0${number}` : number;
    }
    if (typeof dateFormat === "string") {
      const tokens = {
        yyyy: year,
        yy: String(year).substring(2),
        mm: twoDigits(month1),
        m: month1,
        MM: monthNames[month],
        M: monthNamesShort[month],
        dd: twoDigits(day),
        d: day,
        DD: dayNames[weekDay],
        D: dayNamesShort[weekDay]
      };
      if (calendar.params.timePicker) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        let hours12 = hours;
        if (hours > 12)
          hours12 = hours - 12;
        if (hours === 0)
          hours12 = 12;
        const a = hours >= 12 && hours !== 0 ? "pm" : "am";
        Object.assign(tokens, {
          HH: twoDigits(hours),
          H: hours,
          hh: twoDigits(hours12),
          h: hours12,
          ss: twoDigits(seconds),
          s: seconds,
          ":mm": twoDigits(minutes),
          ":m": minutes,
          a,
          A: a.toUpperCase()
        });
      }
      const regexp = new RegExp(Object.keys(tokens).map((t) => `(${t})`).join("|"), "g");
      return dateFormat.replace(regexp, (token) => {
        if (token in tokens)
          return tokens[token];
        return token;
      });
    }
    if (typeof dateFormat === "function") {
      return dateFormat(date);
    }
    const formatter = new Intl.DateTimeFormat(locale, dateFormat);
    return formatter.format(date);
  }
  formatValue() {
    const calendar = this;
    const {
      value
    } = calendar;
    if (calendar.params.formatValue) {
      return calendar.params.formatValue.call(calendar, value);
    }
    return value.map((v) => calendar.formatDate(v)).join(calendar.params.rangePicker ? " - " : ", ");
  }
  addValue(newValue) {
    const calendar = this;
    const {
      multiple,
      rangePicker,
      rangePickerMinDays,
      rangePickerMaxDays
    } = calendar.params;
    if (multiple) {
      if (!calendar.value)
        calendar.value = [];
      let inValuesIndex;
      for (let i = 0; i < calendar.value.length; i += 1) {
        if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
          inValuesIndex = i;
        }
      }
      if (typeof inValuesIndex === "undefined") {
        calendar.value.push(newValue);
      } else {
        calendar.value.splice(inValuesIndex, 1);
      }
      calendar.updateValue();
    } else if (rangePicker) {
      if (!calendar.value)
        calendar.value = [];
      if (calendar.value.length === 2 || calendar.value.length === 0) {
        calendar.value = [];
      }
      if (calendar.value.length === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1e3 && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1e3))
        calendar.value.push(newValue);
      else
        calendar.value = [];
      calendar.value.sort((a, b) => a - b);
      calendar.updateValue();
    } else {
      calendar.value = [newValue];
      calendar.updateValue();
    }
  }
  setValue(values) {
    const calendar = this;
    const currentValue = calendar.value;
    if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
      let equal = true;
      currentValue.forEach((v, index2) => {
        if (v !== values[index2])
          equal = false;
      });
      if (equal)
        return;
    }
    calendar.value = values;
    calendar.updateValue();
  }
  getValue() {
    const calendar = this;
    return calendar.value;
  }
  updateValue(onlyHeader) {
    const calendar = this;
    const {
      $el,
      $wrapperEl,
      $inputEl,
      value,
      params
    } = calendar;
    let i;
    if ($el && $el.length > 0) {
      $wrapperEl.find(".calendar-day-selected").removeClass("calendar-day-selected calendar-day-selected-range calendar-day-selected-left calendar-day-selected-right");
      let valueDate;
      if (params.rangePicker && value.length === 2) {
        const leftDate = new Date(value[0]).getTime();
        const rightDate = new Date(value[1]).getTime();
        for (i = leftDate; i <= rightDate; i += 24 * 60 * 60 * 1e3) {
          valueDate = new Date(i);
          let addClass2 = "calendar-day-selected";
          if (leftDate !== rightDate) {
            if (i !== leftDate && i !== rightDate) {
              addClass2 += " calendar-day-selected-range";
            }
            if (i === leftDate) {
              addClass2 += " calendar-day-selected-left";
            }
            if (i === rightDate) {
              addClass2 += " calendar-day-selected-right";
            }
          }
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass(addClass2);
        }
        valueDate = new Date(leftDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-left");
        valueDate = new Date(rightDate);
        $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).removeClass("calendar-day-selected-range").addClass("calendar-day-selected calendar-day-selected-right");
      } else {
        for (i = 0; i < calendar.value.length; i += 1) {
          valueDate = new Date(value[i]);
          $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass("calendar-day-selected");
        }
      }
    }
    if (!onlyHeader) {
      calendar.emit("local::change calendarChange", calendar, value);
    }
    if ($el && $el.length > 0 && calendar.hasTimePicker) {
      $el.find(".calendar-time-selector a").text(value && value.length ? calendar.timeSelectorFormatter(value[0]) : calendar.params.timePickerPlaceholder);
    }
    if ($inputEl && $inputEl.length || params.header) {
      const inputValue = calendar.formatValue(value);
      if (params.header && $el && $el.length) {
        $el.find(".calendar-selected-date").text(inputValue);
      }
      if ($inputEl && $inputEl.length && !onlyHeader) {
        $inputEl.val(inputValue);
        $inputEl.trigger("change");
      }
    }
  }
  updateCurrentMonthYear(dir) {
    const calendar = this;
    const {
      $months,
      $el,
      monthNames
    } = calendar;
    let currentLocaleMonth;
    let currentLocaleYear;
    if (typeof dir === "undefined") {
      calendar.currentMonth = parseInt($months.eq(1).attr("data-month"), 10);
      calendar.currentYear = parseInt($months.eq(1).attr("data-year"), 10);
      currentLocaleMonth = $months.eq(1).attr("data-locale-month");
      currentLocaleYear = $months.eq(1).attr("data-locale-year");
    } else {
      calendar.currentMonth = parseInt($months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-month"), 10);
      calendar.currentYear = parseInt($months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-year"), 10);
      currentLocaleMonth = $months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-locale-month");
      currentLocaleYear = $months.eq(dir === "next" ? $months.length - 1 : 0).attr("data-locale-year");
    }
    $el.find(".current-month-value").text(monthNames[currentLocaleMonth]);
    $el.find(".current-year-value").text(currentLocaleYear);
  }
  update() {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl
    } = calendar;
    const currentDate = new Date(currentYear, currentMonth);
    const prevMonthHtml = calendar.renderMonth(currentDate, "prev");
    const currentMonthHtml = calendar.renderMonth(currentDate);
    const nextMonthHtml = calendar.renderMonth(currentDate, "next");
    $wrapperEl.transition(0).html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`).transform("translate3d(0,0,0)");
    calendar.$months = $wrapperEl.find(".calendar-month");
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    calendar.$months.each((monthEl) => {
      calendar.emit("local::monthAdd calendarMonthAdd", monthEl);
    });
  }
  onMonthChangeStart(dir) {
    const calendar = this;
    const {
      $months,
      currentYear,
      currentMonth
    } = calendar;
    calendar.updateCurrentMonthYear(dir);
    $months.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
    const currentIndex = dir === "next" ? $months.length - 1 : 0;
    $months.eq(currentIndex).addClass("calendar-month-current");
    $months.eq(dir === "next" ? currentIndex - 1 : currentIndex + 1).addClass(dir === "next" ? "calendar-month-prev" : "calendar-month-next");
    calendar.emit("local::monthYearChangeStart calendarMonthYearChangeStart", calendar, currentYear, currentMonth);
  }
  onMonthChangeEnd(dir, rebuildBoth) {
    const calendar = this;
    const {
      currentYear,
      currentMonth,
      $wrapperEl,
      monthsTranslate
    } = calendar;
    calendar.animating = false;
    let nextMonthHtml;
    let prevMonthHtml;
    let currentMonthHtml;
    $wrapperEl.find(".calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)").remove();
    if (typeof dir === "undefined") {
      dir = "next";
      rebuildBoth = true;
    }
    if (!rebuildBoth) {
      currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
    } else {
      $wrapperEl.find(".calendar-month-next, .calendar-month-prev").remove();
      prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), "prev");
      nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), "next");
    }
    if (dir === "next" || rebuildBoth) {
      $wrapperEl.append(currentMonthHtml || nextMonthHtml);
    }
    if (dir === "prev" || rebuildBoth) {
      $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
    }
    const $months = $wrapperEl.find(".calendar-month");
    calendar.$months = $months;
    calendar.setMonthsTranslate(monthsTranslate);
    calendar.emit("local::monthAdd calendarMonthAdd", calendar, dir === "next" ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]);
    calendar.emit("local::monthYearChangeEnd calendarMonthYearChangeEnd", calendar, currentYear, currentMonth);
  }
  setMonthsTranslate(translate) {
    const calendar = this;
    const {
      $months,
      isHorizontal: isH,
      inverter
    } = calendar;
    translate = translate || calendar.monthsTranslate || 0;
    if (typeof calendar.monthsTranslate === "undefined") {
      calendar.monthsTranslate = translate;
    }
    $months.removeClass("calendar-month-current calendar-month-prev calendar-month-next");
    const prevMonthTranslate = -(translate + 1) * 100 * inverter;
    const currentMonthTranslate = -translate * 100 * inverter;
    const nextMonthTranslate = -(translate - 1) * 100 * inverter;
    $months.eq(0).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass("calendar-month-prev");
    $months.eq(1).transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`).addClass("calendar-month-current");
    $months.eq(2).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass("calendar-month-next");
  }
  nextMonth(transition2) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;
    if (typeof transition2 === "undefined" || typeof transition2 === "object") {
      transition2 = "";
      if (!params.animate)
        transition2 = 0;
    }
    const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr("data-month"), 10);
    const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr("data-year"), 10);
    const nextDate = new Date(nextYear, nextMonth);
    const nextDateTime = nextDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.maxDate) {
      if (nextDateTime > new Date(params.maxDate).getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate -= 1;
    if (nextMonth === calendar.currentMonth) {
      const nextMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const nextMonthHtml = dom7_default(calendar.renderMonth(nextDateTime, "next")).transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`).addClass("calendar-month-next");
      $wrapperEl.append(nextMonthHtml[0]);
      calendar.$months = $wrapperEl.find(".calendar-month");
      calendar.emit("local::monthAdd calendarMonthAdd", calendar.$months.eq(calendar.$months.length - 1)[0]);
    }
    calendar.animating = true;
    calendar.onMonthChangeStart("next");
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd("next");
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd("next");
    }
  }
  prevMonth(transition2) {
    const calendar = this;
    const {
      params,
      $wrapperEl,
      inverter,
      isHorizontal: isH
    } = calendar;
    if (typeof transition2 === "undefined" || typeof transition2 === "object") {
      transition2 = "";
      if (!params.animate)
        transition2 = 0;
    }
    const prevMonth = parseInt(calendar.$months.eq(0).attr("data-month"), 10);
    const prevYear = parseInt(calendar.$months.eq(0).attr("data-year"), 10);
    const prevDate = new Date(prevYear, prevMonth + 1, -1);
    const prevDateTime = prevDate.getTime();
    const transitionEndCallback = !calendar.animating;
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (prevDateTime < minDate.getTime()) {
        calendar.resetMonth();
        return;
      }
    }
    calendar.monthsTranslate += 1;
    if (prevMonth === calendar.currentMonth) {
      const prevMonthTranslate = -calendar.monthsTranslate * 100 * inverter;
      const prevMonthHtml = dom7_default(calendar.renderMonth(prevDateTime, "prev")).transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`).addClass("calendar-month-prev");
      $wrapperEl.prepend(prevMonthHtml[0]);
      calendar.$months = $wrapperEl.find(".calendar-month");
      calendar.emit("local::monthAdd calendarMonthAdd", calendar.$months.eq(0)[0]);
    }
    calendar.animating = true;
    calendar.onMonthChangeStart("prev");
    const translate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd("prev");
      });
    }
    if (!params.animate) {
      calendar.onMonthChangeEnd("prev");
    }
  }
  resetMonth(transition2) {
    if (transition2 === void 0) {
      transition2 = "";
    }
    const calendar = this;
    const {
      $wrapperEl,
      inverter,
      isHorizontal: isH,
      monthsTranslate
    } = calendar;
    const translate = monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
  }
  setYearMonth(year, month, transition2) {
    const calendar = this;
    const {
      params,
      isHorizontal: isH,
      $wrapperEl,
      inverter
    } = calendar;
    if (typeof year === "undefined")
      year = calendar.currentYear;
    if (typeof month === "undefined")
      month = calendar.currentMonth;
    if (typeof transition2 === "undefined" || typeof transition2 === "object") {
      transition2 = "";
      if (!params.animate)
        transition2 = 0;
    }
    let targetDate;
    if (year < calendar.currentYear) {
      targetDate = new Date(year, month + 1, -1).getTime();
    } else {
      targetDate = new Date(year, month).getTime();
    }
    if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
      return false;
    }
    if (params.minDate) {
      let minDate = new Date(params.minDate);
      minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
      if (targetDate < minDate.getTime()) {
        return false;
      }
    }
    const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
    const dir = targetDate > currentDate ? "next" : "prev";
    const newMonthHTML = calendar.renderMonth(new Date(year, month));
    calendar.monthsTranslate = calendar.monthsTranslate || 0;
    const prevTranslate = calendar.monthsTranslate;
    let monthTranslate;
    const transitionEndCallback = !calendar.animating && transition2 !== 0;
    if (targetDate > currentDate) {
      calendar.monthsTranslate -= 1;
      if (!calendar.animating)
        calendar.$months.eq(calendar.$months.length - 1).remove();
      $wrapperEl.append(newMonthHTML);
      calendar.$months = $wrapperEl.find(".calendar-month");
      monthTranslate = -(prevTranslate - 1) * 100 * inverter;
      calendar.$months.eq(calendar.$months.length - 1).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass("calendar-month-next");
    } else {
      calendar.monthsTranslate += 1;
      if (!calendar.animating)
        calendar.$months.eq(0).remove();
      $wrapperEl.prepend(newMonthHTML);
      calendar.$months = $wrapperEl.find(".calendar-month");
      monthTranslate = -(prevTranslate + 1) * 100 * inverter;
      calendar.$months.eq(0).transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`).addClass("calendar-month-prev");
    }
    calendar.emit("local::monthAdd calendarMonthAdd", dir === "next" ? calendar.$months.eq(calendar.$months.length - 1)[0] : calendar.$months.eq(0)[0]);
    calendar.animating = true;
    calendar.onMonthChangeStart(dir);
    const wrapperTranslate = calendar.monthsTranslate * 100 * inverter;
    $wrapperEl.transition(transition2).transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);
    if (transitionEndCallback) {
      $wrapperEl.transitionEnd(() => {
        calendar.onMonthChangeEnd(dir, true);
      });
    }
    if (!params.animate || transition2 === 0) {
      calendar.onMonthChangeEnd(dir, true);
    }
  }
  nextYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear + 1);
  }
  prevYear() {
    const calendar = this;
    calendar.setYearMonth(calendar.currentYear - 1);
  }
  dateInRange(dayDate, range) {
    let match = false;
    let i;
    if (!range)
      return false;
    if (Array.isArray(range)) {
      for (i = 0; i < range.length; i += 1) {
        if (range[i].from || range[i].to) {
          if (range[i].from && range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime() && dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].from) {
            if (dayDate >= new Date(range[i].from).getTime()) {
              match = true;
            }
          } else if (range[i].to) {
            if (dayDate <= new Date(range[i].to).getTime()) {
              match = true;
            }
          }
        } else if (range[i].date) {
          if (dayDate === new Date(range[i].date).getTime()) {
            match = true;
          }
        } else if (dayDate === new Date(range[i]).getTime()) {
          match = true;
        }
      }
    } else if (range.from || range.to) {
      if (range.from && range.to) {
        if (dayDate <= new Date(range.to).getTime() && dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.from) {
        if (dayDate >= new Date(range.from).getTime()) {
          match = true;
        }
      } else if (range.to) {
        if (dayDate <= new Date(range.to).getTime()) {
          match = true;
        }
      }
    } else if (range.date) {
      match = dayDate === new Date(range.date).getTime();
    } else if (typeof range === "function") {
      match = range(new Date(dayDate));
    }
    return match;
  }
  daysInMonth(date) {
    const d = new Date(date);
    return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
  }
  renderMonths(date) {
    const calendar = this;
    if (calendar.params.renderMonths) {
      return calendar.params.renderMonths.call(calendar, date);
    }
    return jsx_default2("div", {
      class: "calendar-months-wrapper"
    }, calendar.renderMonth(date, "prev"), calendar.renderMonth(date), calendar.renderMonth(date, "next"));
  }
  renderMonth(d, offset2) {
    const calendar = this;
    const {
      params,
      value
    } = calendar;
    if (params.renderMonth) {
      return params.renderMonth.call(calendar, d, offset2);
    }
    let date = new Date(d);
    let year = date.getFullYear();
    let month = date.getMonth();
    let localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
    if (localeMonth < 0)
      localeMonth = month;
    let localeYear = calendar.yearFormatter(date);
    if (offset2 === "next") {
      if (month === 11)
        date = new Date(year + 1, 0);
      else
        date = new Date(year, month + 1, 1);
    }
    if (offset2 === "prev") {
      if (month === 0)
        date = new Date(year - 1, 11);
      else
        date = new Date(year, month - 1, 1);
    }
    if (offset2 === "next" || offset2 === "prev") {
      month = date.getMonth();
      year = date.getFullYear();
      localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter(date));
      if (localeMonth < 0)
        localeMonth = month;
      localeYear = calendar.yearFormatter(date);
    }
    const currentValues = [];
    const today = new Date().setHours(0, 0, 0, 0);
    const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
    const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
    const rows = 6;
    const cols = 7;
    const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - 10 * 24 * 60 * 60 * 1e3);
    const daysInMonth = calendar.daysInMonth(date);
    const minDayNumber = params.firstDay === 6 ? 0 : 1;
    let monthHtml = "";
    let dayIndex = 0 + (params.firstDay - 1);
    let disabled;
    let hasEvents;
    let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
    if (firstDayOfMonthIndex === 0)
      firstDayOfMonthIndex = 7;
    if (value && value.length) {
      for (let i = 0; i < value.length; i += 1) {
        currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
      }
    }
    for (let row = 1; row <= rows; row += 1) {
      let rowHtml = "";
      for (let col = 1; col <= cols; col += 1) {
        dayIndex += 1;
        let dayDate;
        let dayNumber = dayIndex - firstDayOfMonthIndex;
        let addClass2 = "";
        if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
          dayIndex -= 7;
          dayNumber = dayIndex - firstDayOfMonthIndex;
        }
        const weekDayIndex = col - 1 + params.firstDay > 6 ? col - 1 - 7 + params.firstDay : col - 1 + params.firstDay;
        if (dayNumber < 0) {
          dayNumber = daysInPrevMonth + dayNumber + 1;
          addClass2 += " calendar-day-prev";
          dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
        } else {
          dayNumber += 1;
          if (dayNumber > daysInMonth) {
            dayNumber -= daysInMonth;
            addClass2 += " calendar-day-next";
            dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
          } else {
            dayDate = new Date(year, month, dayNumber).getTime();
          }
        }
        if (dayDate === today)
          addClass2 += " calendar-day-today";
        if (params.rangePicker && currentValues.length === 2) {
          if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) {
            addClass2 += " calendar-day-selected";
          }
          if (currentValues[0] !== currentValues[1]) {
            if (dayDate > currentValues[0] && dayDate < currentValues[1]) {
              addClass2 += " calendar-day-selected-range";
            }
            if (dayDate === currentValues[0]) {
              addClass2 += " calendar-day-selected-left";
            }
            if (dayDate === currentValues[1]) {
              addClass2 += " calendar-day-selected-right";
            }
          }
        } else if (currentValues.indexOf(dayDate) >= 0)
          addClass2 += " calendar-day-selected";
        if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
          addClass2 += " calendar-day-weekend";
        }
        let eventsHtml = "";
        hasEvents = false;
        if (params.events) {
          if (calendar.dateInRange(dayDate, params.events)) {
            hasEvents = true;
          }
        }
        if (hasEvents) {
          addClass2 += " calendar-day-has-events";
          eventsHtml = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `;
          if (Array.isArray(params.events)) {
            const eventDots = [];
            params.events.forEach((ev) => {
              const color = ev.color || "";
              if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                eventDots.push(color);
              }
            });
            eventsHtml = `
              <span class="calendar-day-events">
                ${eventDots.map((color) => `
                  <span class="calendar-day-event" style="${color ? `background-color: ${color}` : ""}"></span>
                `.trim()).join("")}
              </span>
            `;
          }
        }
        if (params.rangesClasses) {
          for (let k = 0; k < params.rangesClasses.length; k += 1) {
            if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
              addClass2 += ` ${params.rangesClasses[k].cssClass}`;
            }
          }
        }
        disabled = false;
        if (minDate && dayDate < minDate || maxDate && dayDate > maxDate) {
          disabled = true;
        }
        if (params.disabled) {
          if (calendar.dateInRange(dayDate, params.disabled)) {
            disabled = true;
          }
        }
        if (disabled) {
          addClass2 += " calendar-day-disabled";
        }
        dayDate = new Date(dayDate);
        const dayYear = dayDate.getFullYear();
        const dayMonth = dayDate.getMonth();
        const dayNumberDisplay = calendar.dayFormatter(dayDate);
        rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass2}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span class="calendar-day-number">${dayNumberDisplay}${eventsHtml}</span>
          </div>`.trim();
      }
      monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
    }
    monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}" data-locale-year="${localeYear}" data-locale-month="${localeMonth}">${monthHtml}</div>`;
    return monthHtml;
  }
  renderWeekHeader() {
    const calendar = this;
    if (calendar.params.renderWeekHeader) {
      return calendar.params.renderWeekHeader.call(calendar);
    }
    const {
      params
    } = calendar;
    let weekDaysHtml = "";
    for (let i = 0; i < 7; i += 1) {
      const dayIndex = i + params.firstDay > 6 ? i - 7 + params.firstDay : i + params.firstDay;
      const dayName = calendar.dayNamesShort[dayIndex];
      weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
    }
    return jsx_default2("div", {
      class: "calendar-week-header"
    }, weekDaysHtml);
  }
  renderMonthSelector() {
    const calendar = this;
    if (calendar.params.renderMonthSelector) {
      return calendar.params.renderMonthSelector.call(calendar);
    }
    return jsx_default2("div", {
      class: "calendar-month-selector"
    }, jsx_default2("a", {
      class: "link icon-only calendar-prev-month-button"
    }, jsx_default2("i", {
      class: "icon icon-prev"
    })), calendar.params.monthPicker ? jsx_default2("a", {
      class: "current-month-value link"
    }) : jsx_default2("span", {
      class: "current-month-value"
    }), jsx_default2("a", {
      class: "link icon-only calendar-next-month-button"
    }, jsx_default2("i", {
      class: "icon icon-next"
    })));
  }
  renderYearSelector() {
    const calendar = this;
    if (calendar.params.renderYearSelector) {
      return calendar.params.renderYearSelector.call(calendar);
    }
    return jsx_default2("div", {
      class: "calendar-year-selector"
    }, jsx_default2("a", {
      class: "link icon-only calendar-prev-year-button"
    }, jsx_default2("i", {
      class: "icon icon-prev"
    })), calendar.params.yearPicker ? jsx_default2("a", {
      class: "current-year-value link"
    }) : jsx_default2("span", {
      class: "current-year-value"
    }), jsx_default2("a", {
      class: "link icon-only calendar-next-year-button"
    }, jsx_default2("i", {
      class: "icon icon-next"
    })));
  }
  renderTimeSelector() {
    const calendar = this;
    const value = calendar.value && calendar.value[0];
    let timeString;
    if (value)
      timeString = calendar.timeSelectorFormatter(value);
    return jsx_default2("div", {
      class: "calendar-time-selector"
    }, jsx_default2("span", null, calendar.params.timePickerLabel), jsx_default2("a", {
      class: "link"
    }, timeString || calendar.params.timePickerPlaceholder));
  }
  renderHeader() {
    const calendar = this;
    if (calendar.params.renderHeader) {
      return calendar.params.renderHeader.call(calendar);
    }
    return jsx_default2("div", {
      class: "calendar-header"
    }, jsx_default2("div", {
      class: "calendar-selected-date"
    }, calendar.params.headerPlaceholder));
  }
  renderFooter() {
    const calendar = this;
    const app = calendar.app;
    if (calendar.params.renderFooter) {
      return calendar.params.renderFooter.call(calendar);
    }
    return jsx_default2("div", {
      class: "calendar-footer"
    }, jsx_default2("a", {
      class: `${app.theme === "md" ? "button" : "link"} calendar-close sheet-close popover-close`
    }, calendar.params.toolbarCloseText));
  }
  renderToolbar() {
    const calendar = this;
    if (calendar.params.renderToolbar) {
      return calendar.params.renderToolbar.call(calendar, calendar);
    }
    return jsx_default2("div", {
      class: "toolbar toolbar-top no-shadow"
    }, jsx_default2("div", {
      class: "toolbar-inner"
    }, calendar.params.monthSelector ? calendar.renderMonthSelector() : "", calendar.params.yearSelector ? calendar.renderYearSelector() : ""));
  }
  renderInline() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return jsx_default2("div", {
      class: `calendar calendar-inline ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default2("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderCustomModal() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return jsx_default2("div", {
      class: `calendar calendar-modal ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default2("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderSheet() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return jsx_default2("div", {
      class: `sheet-modal calendar calendar-sheet ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default2("div", {
      class: "sheet-modal-inner calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter());
  }
  renderPopover() {
    const calendar = this;
    const {
      cssClass,
      toolbar,
      header,
      footer,
      rangePicker,
      weekHeader
    } = calendar.params;
    const {
      value,
      hasTimePicker
    } = calendar;
    const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
    return jsx_default2("div", {
      class: "popover calendar-popover"
    }, jsx_default2("div", {
      class: "popover-inner"
    }, jsx_default2("div", {
      class: `calendar ${rangePicker ? "calendar-range" : ""} ${cssClass || ""}`
    }, header && calendar.renderHeader(), toolbar && calendar.renderToolbar(), weekHeader && calendar.renderWeekHeader(), jsx_default2("div", {
      class: "calendar-months"
    }, calendar.renderMonths(date)), hasTimePicker && calendar.renderTimeSelector(), footer && calendar.renderFooter())));
  }
  render() {
    const calendar = this;
    const {
      params
    } = calendar;
    if (params.render)
      return params.render.call(calendar);
    if (!calendar.inline) {
      let modalType = params.openIn;
      if (modalType === "auto")
        modalType = calendar.isPopover() ? "popover" : "sheet";
      if (modalType === "popover")
        return calendar.renderPopover();
      if (modalType === "sheet")
        return calendar.renderSheet();
      return calendar.renderCustomModal();
    }
    return calendar.renderInline();
  }
  openMonthPicker() {
    const calendar = this;
    const {
      $el,
      app
    } = calendar;
    if (!$el || !$el.length)
      return;
    $el.append('<div class="popover calendar-popover calendar-month-picker-popover"><div class="popover-inner"><div class="calendar-month-picker"></div></div></div>');
    calendar.monthPickerPopover = app.popover.create({
      el: $el.find(".calendar-month-picker-popover"),
      targetEl: $el.find(".calendar-month-selector"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeMonthPicker();
        },
        closed() {
          if (calendar.monthPickerPopover.$el)
            calendar.monthPickerPopover.$el.remove();
          calendar.monthPickerPopover.destroy();
          if (calendar.monthPickerInstance) {
            calendar.monthPickerInstance.close();
            calendar.monthPickerInstance.destroy();
          }
          delete calendar.monthPickerInstance;
          delete calendar.monthPickerPopover;
        }
      }
    });
    calendar.monthPickerPopover.open();
    const localeMonth = parseInt(calendar.$el.find(".calendar-month-current").attr("data-locale-month"), 10);
    const values = [];
    const displayValues = [];
    calendar.monthNames.forEach((m, index2) => {
      values.push(index2);
      displayValues.push(m);
    });
    calendar.monthPickerInstance = app.picker.create({
      containerEl: calendar.monthPickerPopover.$el.find(".calendar-month-picker"),
      value: [localeMonth],
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values,
        displayValues
      }]
    });
  }
  closeMonthPicker() {
    const calendar = this;
    if (calendar.monthPickerPopover && calendar.monthPickerPopover.opened)
      calendar.monthPickerPopover.close();
    const index2 = calendar.monthPickerInstance.value[0];
    const localeMonthIndex = parseInt(calendar.$el.find(".calendar-month-current").attr("data-locale-month"), 10);
    const monthIndex = calendar.currentMonth;
    const diff = localeMonthIndex - monthIndex;
    const diffIndex = index2 - diff;
    calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
  }
  openYearPicker() {
    const calendar = this;
    const {
      $el,
      app
    } = calendar;
    if (!$el || !$el.length)
      return;
    $el.append('<div class="popover calendar-popover calendar-year-picker-popover"><div class="popover-inner"><div class="calendar-year-picker"></div></div></div>');
    calendar.yearPickerPopover = app.popover.create({
      el: $el.find(".calendar-year-picker-popover"),
      targetEl: $el.find(".calendar-year-selector"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeYearPicker();
        },
        closed() {
          if (calendar.yearPickerPopover.$el)
            calendar.yearPickerPopover.$el.remove();
          calendar.yearPickerPopover.destroy();
          if (calendar.yearPickerInstance) {
            calendar.yearPickerInstance.close();
            calendar.yearPickerInstance.destroy();
          }
          delete calendar.yearPickerInstance;
          delete calendar.yearPickerPopover;
        }
      }
    });
    calendar.yearPickerPopover.open();
    const currentYear = calendar.currentYear;
    let yearMin = calendar.params.yearPickerMin || new Date().getFullYear() - 100;
    if (calendar.params.minDate) {
      yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
    }
    let yearMax = calendar.params.yearPickerMax || new Date().getFullYear() + 100;
    if (calendar.params.maxDate) {
      yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
    }
    const years = [];
    for (let i = yearMin; i <= yearMax; i += 1) {
      years.push(i);
    }
    calendar.yearPickerInstance = app.picker.create({
      containerEl: calendar.yearPickerPopover.$el.find(".calendar-year-picker"),
      value: [currentYear],
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values: years
      }]
    });
  }
  closeYearPicker() {
    const calendar = this;
    if (calendar.yearPickerPopover && calendar.yearPickerPopover.opened)
      calendar.yearPickerPopover.close();
    calendar.setYearMonth(calendar.yearPickerInstance.value[0], void 0, 0);
  }
  openTimePicker() {
    const calendar = this;
    const {
      $el,
      app,
      is12HoursFormat
    } = calendar;
    if (!$el || !$el.length)
      return;
    $el.append('<div class="popover calendar-popover calendar-time-picker-popover"><div class="popover-inner"><div class="calendar-time-picker"></div></div></div>');
    const hoursArr = [];
    const minutesArr = [];
    const hoursMin = is12HoursFormat ? 1 : 0;
    const hoursMax = is12HoursFormat ? 12 : 23;
    for (let i = hoursMin; i <= hoursMax; i += 1) {
      hoursArr.push(i);
    }
    for (let i = 0; i <= 59; i += 1) {
      minutesArr.push(i);
    }
    let value;
    if (calendar.value && calendar.value.length) {
      value = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
    } else {
      value = [new Date().getHours(), new Date().getMinutes()];
    }
    if (is12HoursFormat) {
      value.push(value[0] < 12 ? "AM" : "PM");
      if (value[0] > 12)
        value[0] -= 12;
      if (value[0] === 0)
        value[0] = 12;
    }
    calendar.timePickerPopover = app.popover.create({
      el: $el.find(".calendar-time-picker-popover"),
      targetEl: $el.find(".calendar-time-selector .link"),
      backdrop: true,
      backdropUnique: true,
      on: {
        close() {
          calendar.closeTimePicker();
        },
        closed() {
          if (calendar.timePickerPopover.$el)
            calendar.timePickerPopover.$el.remove();
          calendar.timePickerPopover.destroy();
          if (calendar.timePickerInstance) {
            calendar.timePickerInstance.close();
            calendar.timePickerInstance.destroy();
          }
          delete calendar.timePickerInstance;
          delete calendar.timePickerPopover;
        }
      }
    });
    calendar.timePickerPopover.open();
    calendar.timePickerInstance = app.picker.create({
      containerEl: calendar.timePickerPopover.$el.find(".calendar-time-picker"),
      value,
      toolbar: false,
      rotateEffect: false,
      toolbarCloseText: calendar.params.toolbarCloseText,
      cols: [{
        values: hoursArr
      }, {
        divider: true,
        content: ":"
      }, {
        values: minutesArr,
        displayValues: minutesArr.map((m) => m < 10 ? `0${m}` : m)
      }, ...is12HoursFormat ? [{
        values: ["AM", "PM"]
      }] : []]
    });
  }
  closeTimePicker() {
    const calendar = this;
    const {
      is12HoursFormat
    } = calendar;
    if (calendar.timePickerInstance) {
      const timePickerValue = calendar.timePickerInstance.value;
      let hours = parseInt(timePickerValue[0], 10);
      const minutes = parseInt(timePickerValue[1], 10);
      const period = calendar.timePickerInstance.value[2];
      if (is12HoursFormat) {
        if (period === "AM" && hours === 12) {
          hours = 0;
        } else if (period === "PM" && hours !== 12) {
          hours += 12;
        }
      }
      let value = calendar.value && calendar.value.length && calendar.value[0];
      if (!value) {
        value = new Date();
        value.setHours(hours, minutes, 0, 0);
      } else {
        value = new Date(value);
        value.setHours(hours, minutes);
      }
      calendar.setValue([value]);
      if (calendar.timePickerPopover && calendar.timePickerPopover.opened)
        calendar.timePickerPopover.close();
    }
  }
  onOpen() {
    const calendar = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params
    } = calendar;
    calendar.closing = false;
    calendar.opened = true;
    calendar.opening = true;
    calendar.attachCalendarEvents();
    const updateValue = !value && params.value;
    if (!initialized) {
      if (value)
        calendar.setValue(value, 0);
      else if (params.value) {
        calendar.setValue(calendar.normalizeValues(params.value), 0);
      }
    } else if (value) {
      calendar.setValue(value, 0);
    }
    calendar.updateCurrentMonthYear();
    calendar.monthsTranslate = 0;
    calendar.setMonthsTranslate();
    if (updateValue)
      calendar.updateValue();
    else if (params.header && value) {
      calendar.updateValue(true);
    }
    if (!inline && $inputEl && $inputEl.length && app.theme === "md") {
      $inputEl.trigger("focus");
    }
    calendar.initialized = true;
    calendar.$months.each((monthEl) => {
      calendar.emit("local::monthAdd calendarMonthAdd", monthEl);
    });
    if ($el) {
      $el.trigger("calendar:open");
    }
    if ($inputEl) {
      $inputEl.trigger("calendar:open");
    }
    calendar.emit("local::open calendarOpen", calendar);
  }
  onOpened() {
    const calendar = this;
    calendar.opening = false;
    if (calendar.$el) {
      calendar.$el.trigger("calendar:opened");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:opened");
    }
    calendar.emit("local::opened calendarOpened", calendar);
  }
  onClose() {
    const calendar = this;
    const app = calendar.app;
    calendar.opening = false;
    calendar.closing = true;
    if (calendar.$inputEl) {
      if (app.theme === "md") {
        calendar.$inputEl.trigger("blur");
      } else {
        const validate = calendar.$inputEl.attr("validate");
        const required = calendar.$inputEl.attr("required");
        if (validate && required) {
          app.input.validate(calendar.$inputEl);
        }
      }
    }
    if (calendar.detachCalendarEvents) {
      calendar.detachCalendarEvents();
    }
    if (calendar.$el) {
      calendar.$el.trigger("calendar:close");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:close");
    }
    calendar.emit("local::close calendarClose", calendar);
  }
  onClosed() {
    const calendar = this;
    calendar.opened = false;
    calendar.closing = false;
    if (!calendar.inline) {
      nextTick(() => {
        if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
          if (!calendar.params.routableModals) {
            calendar.modal.destroy();
          }
        }
        delete calendar.modal;
      });
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy)
        calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if (calendar.$el) {
      calendar.$el.trigger("calendar:closed");
    }
    if (calendar.$inputEl) {
      calendar.$inputEl.trigger("calendar:closed");
    }
    calendar.emit("local::closed calendarClosed", calendar);
  }
  open() {
    const calendar = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      params
    } = calendar;
    if (opened)
      return;
    if (inline) {
      calendar.$el = dom7_default(calendar.render());
      calendar.$el[0].f7Calendar = calendar;
      calendar.$wrapperEl = calendar.$el.find(".calendar-months-wrapper");
      calendar.$months = calendar.$wrapperEl.find(".calendar-month");
      calendar.$containerEl.append(calendar.$el);
      calendar.onOpen();
      calendar.onOpened();
      return;
    }
    let modalType = params.openIn;
    if (modalType === "auto") {
      modalType = calendar.isPopover() ? "popover" : "sheet";
    }
    const modalContent = calendar.render();
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: params.scrollToInput ? $inputEl : void 0,
      content: modalContent,
      backdrop: params.backdrop === true || modalType === "popover" && app.params.popover.backdrop !== false && params.backdrop !== false,
      closeByBackdropClick: params.closeByBackdropClick,
      on: {
        open() {
          const modal = this;
          calendar.modal = modal;
          calendar.$el = modalType === "popover" ? modal.$el.find(".calendar") : modal.$el;
          calendar.$wrapperEl = calendar.$el.find(".calendar-months-wrapper");
          calendar.$months = calendar.$wrapperEl.find(".calendar-month");
          calendar.$el[0].f7Calendar = calendar;
          if (modalType === "customModal") {
            dom7_default(calendar.$el).find(".calendar-close").once("click", () => {
              calendar.close();
            });
          }
          calendar.onOpen();
        },
        opened() {
          calendar.onOpened();
        },
        close() {
          calendar.onClose();
        },
        closed() {
          calendar.onClosed();
        }
      }
    };
    if (modalType === "sheet") {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && calendar.view) {
      calendar.view.router.navigate({
        url: calendar.url,
        route: {
          path: calendar.url,
          [modalType]: modalParams
        }
      });
    } else {
      calendar.modal = app[modalType].create(modalParams);
      calendar.modal.open();
    }
  }
  close() {
    const calendar = this;
    const {
      opened,
      inline
    } = calendar;
    if (!opened)
      return;
    if (inline) {
      calendar.onClose();
      calendar.onClosed();
      return;
    }
    if (calendar.params.routableModals && calendar.view) {
      calendar.view.router.back();
    } else {
      calendar.modal.close();
    }
  }
  init() {
    const calendar = this;
    calendar.initInput();
    if (calendar.inline) {
      calendar.open();
      calendar.emit("local::init calendarInit", calendar);
      return;
    }
    if (!calendar.initialized && calendar.params.value) {
      calendar.setValue(calendar.normalizeValues(calendar.params.value));
    }
    if (calendar.$inputEl) {
      calendar.attachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.attachHtmlEvents();
    }
    calendar.emit("local::init calendarInit", calendar);
  }
  destroy() {
    const calendar = this;
    if (calendar.destroyed)
      return;
    const {
      $el
    } = calendar;
    calendar.emit("local::beforeDestroy calendarBeforeDestroy", calendar);
    if ($el)
      $el.trigger("calendar:beforedestroy");
    calendar.close();
    if (calendar.$inputEl) {
      calendar.detachInputEvents();
    }
    if (calendar.params.closeByOutsideClick) {
      calendar.detachHtmlEvents();
    }
    if (calendar.timePickerInstance) {
      if (calendar.timePickerInstance.destroy)
        calendar.timePickerInstance.destroy();
      delete calendar.timePickerInstance;
    }
    if ($el && $el.length)
      delete calendar.$el[0].f7Calendar;
    deleteProps(calendar);
    calendar.destroyed = true;
  }
};
var calendar_class_default = Calendar;

// node_modules/framework7/components/calendar/calendar.js
var calendar_default = {
  name: "calendar",
  static: {
    Calendar: calendar_class_default
  },
  create() {
    const app = this;
    app.calendar = ConstructorMethods({
      defaultSelector: ".calendar",
      constructor: calendar_class_default,
      app,
      domProp: "f7Calendar"
    });
    app.calendar.close = function close6(el) {
      if (el === void 0) {
        el = ".calendar";
      }
      const $el = dom7_default(el);
      if ($el.length === 0)
        return;
      const calendar = $el[0].f7Calendar;
      if (!calendar || calendar && !calendar.opened)
        return;
      calendar.close();
    };
  },
  params: {
    calendar: {
      dateFormat: void 0,
      monthNames: "auto",
      monthNamesShort: "auto",
      dayNames: "auto",
      dayNamesShort: "auto",
      locale: void 0,
      firstDay: 1,
      weekendDays: [0, 6],
      multiple: false,
      rangePicker: false,
      rangePickerMinDays: 1,
      rangePickerMaxDays: 0,
      direction: "horizontal",
      minDate: null,
      maxDate: null,
      disabled: null,
      events: null,
      rangesClasses: null,
      touchMove: true,
      animate: true,
      closeOnSelect: false,
      monthSelector: true,
      monthPicker: true,
      yearSelector: true,
      yearPicker: true,
      yearPickerMin: void 0,
      yearPickerMax: void 0,
      timePicker: false,
      timePickerLabel: "Time",
      timePickerFormat: {
        hour: "numeric",
        minute: "numeric"
      },
      timePickerPlaceholder: "Select time",
      weekHeader: true,
      value: null,
      containerEl: null,
      openIn: "auto",
      sheetPush: false,
      sheetSwipeToClose: void 0,
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      header: false,
      headerPlaceholder: "Select date",
      toolbar: true,
      toolbarCloseText: "Done",
      footer: false,
      cssClass: null,
      routableModals: false,
      view: null,
      url: "date/",
      backdrop: null,
      closeByBackdropClick: true,
      renderWeekHeader: null,
      renderMonths: null,
      renderMonth: null,
      renderMonthSelector: null,
      renderYearSelector: null,
      renderHeader: null,
      renderFooter: null,
      renderToolbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      render: null
    }
  }
};

// node_modules/framework7/components/picker/picker-column.js
function pickerColumn(colEl, updateItems) {
  const picker = this;
  const $colEl = dom7_default(colEl);
  const colIndex = $colEl.index();
  const col = picker.cols[colIndex];
  if (col.divider)
    return;
  col.$el = $colEl;
  col.el = $colEl[0];
  col.$itemsEl = col.$el.find(".picker-items");
  col.items = col.$itemsEl.find(".picker-item");
  let itemHeight;
  let colHeight;
  col.replaceValues = function replaceColValues(values, displayValues) {
    col.detachEvents();
    col.values = values;
    col.displayValues = displayValues;
    col.$itemsEl.html(picker.renderColumn(col, true));
    col.items = col.$itemsEl.find(".picker-item");
    col.calcSize();
    col.setValue(col.values[0], true);
    col.attachEvents();
  };
  col.calcSize = function calcColSize() {
    colHeight = col.$el[0].offsetHeight;
    itemHeight = col.items[0].offsetHeight;
    const hadPadding = col.el.style.getPropertyValue("--f7-picker-scroll-padding");
    col.el.style.setProperty("--f7-picker-scroll-padding", `${(colHeight - itemHeight) / 2}px`);
    if (!hadPadding) {
      col.$itemsEl[0].scrollTop = 0;
    }
  };
  col.setValue = function setColValue(newValue, valueCallbacks) {
    const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();
    if (typeof newActiveIndex === "undefined" || newActiveIndex === -1) {
      return;
    }
    const newScrollTop = newActiveIndex * itemHeight;
    col.$itemsEl[0].scrollTop = newScrollTop;
    col.updateItems(newActiveIndex, newScrollTop, valueCallbacks);
  };
  col.updateItems = function updateColItems(activeIndex, scrollTop, valueCallbacks) {
    if (typeof scrollTop === "undefined") {
      scrollTop = col.$itemsEl[0].scrollTop;
    }
    if (typeof activeIndex === "undefined") {
      activeIndex = Math.round(scrollTop / itemHeight);
    }
    if (activeIndex < 0)
      activeIndex = 0;
    if (activeIndex >= col.items.length)
      activeIndex = col.items.length - 1;
    const previousActiveIndex = col.activeIndex;
    col.activeIndex = activeIndex;
    col.$itemsEl.find(".picker-item-selected").removeClass("picker-item-selected");
    const selectedItem = col.items.eq(activeIndex);
    selectedItem.addClass("picker-item-selected").children().transform("");
    if (picker.params.rotateEffect) {
      col.items.each((itemEl) => {
        const $itemEl = dom7_default(itemEl);
        const itemOffset = itemEl.offsetTop - (colHeight - itemHeight) / 2 - scrollTop;
        const percentage = itemOffset / itemHeight;
        const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;
        let angle = -24 * percentage;
        if (angle > 180)
          angle = 180;
        if (angle < -180)
          angle = -180;
        if (Math.abs(percentage) > itemsFit) {
          $itemEl.addClass("picker-item-far");
        } else {
          $itemEl.removeClass("picker-item-far");
        }
        $itemEl.children("span").transform(`translate3d(0, ${-percentage * itemHeight}px, -100px) rotateX(${angle}deg)`);
      });
    }
    if (valueCallbacks || typeof valueCallbacks === "undefined") {
      col.value = selectedItem.attr("data-picker-value");
      col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
      if (previousActiveIndex !== activeIndex) {
        if (col.onChange) {
          col.onChange(picker, col.value, col.displayValue);
        }
        picker.updateValue();
      }
    }
  };
  function handleScroll() {
    col.updateItems();
  }
  function handleClick() {
    const value = dom7_default(this).attr("data-picker-value");
    col.setValue(value);
  }
  col.attachEvents = function attachColEvents() {
    col.$itemsEl.on("scroll", handleScroll);
    col.items.on("click", handleClick);
  };
  col.detachEvents = function detachColEvents() {
    col.items.off("click", handleClick);
  };
  col.init = function initCol() {
    col.calcSize();
    if (colIndex === 0)
      col.$el.addClass("picker-column-first");
    if (colIndex === picker.cols.length - 1)
      col.$el.addClass("picker-column-last");
    if (picker.params.freeMode)
      col.$el.addClass("picker-column-free-mode");
    if (updateItems)
      col.updateItems(0);
    col.attachEvents();
  };
  col.destroy = function destroyCol() {
    col.detachEvents();
  };
  col.init();
}

// node_modules/framework7/components/picker/picker-class.js
var Picker = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const picker = this;
    const device = getDevice();
    const window2 = getWindow();
    picker.params = extend({}, app.params.picker, params);
    let $containerEl;
    if (picker.params.containerEl) {
      $containerEl = dom7_default(picker.params.containerEl);
      if ($containerEl.length === 0)
        return picker;
    }
    let $inputEl;
    if (picker.params.inputEl) {
      $inputEl = dom7_default(picker.params.inputEl);
    }
    let $scrollToEl = picker.params.scrollToInput ? $inputEl : void 0;
    if (picker.params.scrollToEl) {
      const scrollToEl = dom7_default(picker.params.scrollToEl);
      if (scrollToEl.length > 0) {
        $scrollToEl = scrollToEl;
      }
    }
    extend(picker, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      needsOriginFix: device.ios || window2.navigator.userAgent.toLowerCase().indexOf("safari") >= 0 && window2.navigator.userAgent.toLowerCase().indexOf("chrome") < 0 && !device.android,
      cols: [],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $scrollToEl,
      initialized: false,
      opened: false,
      url: picker.params.url
    });
    function onResize2() {
      picker.resizeCols();
    }
    function onInputClick() {
      picker.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    let htmlTouchStartTarget = null;
    function onHtmlTouchStart(e) {
      htmlTouchStartTarget = e.target;
    }
    function onHtmlClick(e) {
      if (picker.destroyed || !picker.params)
        return;
      const $targetEl = dom7_default(e.target);
      if (picker.isPopover())
        return;
      if (!picker.opened || picker.closing)
        return;
      if ($targetEl.closest('[class*="backdrop"]').length)
        return;
      if ($inputEl && $inputEl.length > 0) {
        if (htmlTouchStartTarget === e.target && $targetEl[0] !== $inputEl[0] && $targetEl.closest(".sheet-modal").length === 0) {
          picker.close();
        }
      } else if (dom7_default(e.target).closest(".sheet-modal").length === 0) {
        picker.close();
      }
    }
    extend(picker, {
      attachResizeEvent() {
        app.on("resize", onResize2);
      },
      detachResizeEvent() {
        app.off("resize", onResize2);
      },
      attachInputEvents() {
        picker.$inputEl.on("click", onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.on("focus mousedown", onInputFocus);
          if (picker.$inputEl[0]) {
            picker.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        picker.$inputEl.off("click", onInputClick);
        if (picker.params.inputReadOnly) {
          picker.$inputEl.off("focus mousedown", onInputFocus);
          if (picker.$inputEl[0]) {
            delete picker.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachHtmlEvents() {
        app.on("click", onHtmlClick);
        app.on("touchstart", onHtmlTouchStart);
      },
      detachHtmlEvents() {
        app.off("click", onHtmlClick);
        app.off("touchstart", onHtmlTouchStart);
      }
    });
    picker.init();
    return picker;
  }
  get view() {
    const {
      app,
      params,
      $inputEl
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else if ($inputEl) {
      view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  initInput() {
    const picker = this;
    if (!picker.$inputEl)
      return;
    if (picker.params.inputReadOnly)
      picker.$inputEl.prop("readOnly", true);
  }
  resizeCols() {
    const picker = this;
    if (!picker.opened)
      return;
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (!picker.cols[i].divider) {
        picker.cols[i].calcSize();
        picker.cols[i].setValue(picker.cols[i].value, false);
      }
    }
  }
  isPopover() {
    const picker = this;
    const {
      app,
      modal,
      params
    } = picker;
    const device = getDevice();
    if (params.openIn === "sheet")
      return false;
    if (modal && modal.type !== "popover")
      return false;
    if (!picker.inline && picker.inputEl) {
      if (params.openIn === "popover")
        return true;
      if (device.ios) {
        return !!device.ipad;
      }
      if (app.width >= 768) {
        return true;
      }
      if (device.desktop && app.theme === "aurora") {
        return true;
      }
    }
    return false;
  }
  formatValue() {
    const picker = this;
    const {
      value,
      displayValue
    } = picker;
    if (picker.params.formatValue) {
      return picker.params.formatValue.call(picker, value, displayValue);
    }
    return value.join(" ");
  }
  setValue(values) {
    const picker = this;
    let valueIndex = 0;
    if (picker.cols.length === 0) {
      picker.value = values;
      picker.updateValue(values);
      return;
    }
    for (let i = 0; i < picker.cols.length; i += 1) {
      if (picker.cols[i] && !picker.cols[i].divider) {
        picker.cols[i].setValue(values[valueIndex]);
        valueIndex += 1;
      }
    }
  }
  getValue() {
    const picker = this;
    return picker.value;
  }
  updateValue(forceValues) {
    const picker = this;
    const newValue = forceValues || [];
    const newDisplayValue = [];
    let column;
    if (picker.cols.length === 0) {
      const noDividerColumns = picker.params.cols.filter((c) => !c.divider);
      for (let i = 0; i < noDividerColumns.length; i += 1) {
        column = noDividerColumns[i];
        if (column.displayValues !== void 0 && column.values !== void 0 && column.values.indexOf(newValue[i]) !== -1) {
          newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
        } else {
          newDisplayValue.push(newValue[i]);
        }
      }
    } else {
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          newValue.push(picker.cols[i].value);
          newDisplayValue.push(picker.cols[i].displayValue);
        }
      }
    }
    if (newValue.indexOf(void 0) >= 0) {
      return;
    }
    picker.value = newValue;
    picker.displayValue = newDisplayValue;
    picker.emit("local::change pickerChange", picker, picker.value, picker.displayValue);
    if (picker.inputEl) {
      picker.$inputEl.val(picker.formatValue());
      picker.$inputEl.trigger("change");
    }
  }
  initColumn(colEl, updateItems) {
    const picker = this;
    pickerColumn.call(picker, colEl, updateItems);
  }
  destroyColumn(colEl) {
    const picker = this;
    const $colEl = dom7_default(colEl);
    const index2 = $colEl.index();
    if (picker.cols[index2] && picker.cols[index2].destroy) {
      picker.cols[index2].destroy();
    }
  }
  renderToolbar() {
    const picker = this;
    if (picker.params.renderToolbar)
      return picker.params.renderToolbar.call(picker, picker);
    return jsx_default2("div", {
      class: "toolbar toolbar-top no-shadow"
    }, jsx_default2("div", {
      class: "toolbar-inner"
    }, jsx_default2("div", {
      class: "left"
    }), jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link sheet-close popover-close"
    }, picker.params.toolbarCloseText))));
  }
  renderColumn(col, onlyItems) {
    const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ""} ${col.cssClass || ""}`;
    let columnHtml;
    let columnItemsHtml;
    if (col.divider) {
      columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
    } else {
      columnItemsHtml = col.values.map((value, index2) => `
        <div class="picker-item" data-picker-value="${value}">
          <span>${col.displayValues ? col.displayValues[index2] : value}</span>
        </div>
      `).join("");
      columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
    }
    return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
  }
  renderInline() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const inlineHtml = jsx_default2("div", {
      class: `picker picker-inline ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), jsx_default2("div", {
      class: "picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), jsx_default2("div", {
      class: "picker-center-highlight"
    })));
    return inlineHtml;
  }
  renderSheet() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const sheetHtml = jsx_default2("div", {
      class: `sheet-modal picker picker-sheet ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), jsx_default2("div", {
      class: "sheet-modal-inner picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), jsx_default2("div", {
      class: "picker-center-highlight"
    })));
    return sheetHtml;
  }
  renderPopover() {
    const picker = this;
    const {
      rotateEffect,
      cssClass,
      toolbar
    } = picker.params;
    const popoverHtml = jsx_default2("div", {
      class: "popover picker-popover"
    }, jsx_default2("div", {
      class: "popover-inner"
    }, jsx_default2("div", {
      class: `picker ${rotateEffect ? "picker-3d" : ""} ${cssClass || ""}`
    }, toolbar && picker.renderToolbar(), jsx_default2("div", {
      class: "picker-columns"
    }, picker.cols.map((col) => picker.renderColumn(col)), jsx_default2("div", {
      class: "picker-center-highlight"
    })))));
    return popoverHtml;
  }
  render() {
    const picker = this;
    if (picker.params.render)
      return picker.params.render.call(picker);
    if (!picker.inline) {
      if (picker.isPopover())
        return picker.renderPopover();
      return picker.renderSheet();
    }
    return picker.renderInline();
  }
  onOpen() {
    const picker = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params
    } = picker;
    picker.opened = true;
    picker.closing = false;
    picker.opening = true;
    picker.attachResizeEvent();
    $el.find(".picker-column").each((colEl) => {
      let updateItems = true;
      if (!initialized && params.value || initialized && value) {
        updateItems = false;
      }
      picker.initColumn(colEl, updateItems);
    });
    if (!initialized) {
      if (value)
        picker.setValue(value);
      else if (params.value) {
        picker.setValue(params.value);
      }
    } else if (value) {
      picker.setValue(value);
    }
    if (!inline && $inputEl && $inputEl.length && app.theme === "md") {
      $inputEl.trigger("focus");
    }
    picker.initialized = true;
    if ($el) {
      $el.trigger("picker:open");
    }
    if ($inputEl) {
      $inputEl.trigger("picker:open");
    }
    picker.emit("local::open pickerOpen", picker);
  }
  onOpened() {
    const picker = this;
    picker.opening = false;
    if (picker.$el) {
      picker.$el.trigger("picker:opened");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:opened");
    }
    picker.emit("local::opened pickerOpened", picker);
  }
  onClose() {
    const picker = this;
    const app = picker.app;
    picker.opening = false;
    picker.closing = true;
    picker.detachResizeEvent();
    picker.cols.forEach((col) => {
      if (col.destroy)
        col.destroy();
    });
    if (picker.$inputEl) {
      if (app.theme === "md") {
        picker.$inputEl.trigger("blur");
      } else {
        const validate = picker.$inputEl.attr("validate");
        const required = picker.$inputEl.attr("required");
        if (validate && required) {
          app.input.validate(picker.$inputEl);
        }
      }
    }
    if (picker.$el) {
      picker.$el.trigger("picker:close");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:close");
    }
    picker.emit("local::close pickerClose", picker);
  }
  onClosed() {
    const picker = this;
    picker.opened = false;
    picker.closing = false;
    if (!picker.inline) {
      nextTick(() => {
        if (picker.modal && picker.modal.el && picker.modal.destroy) {
          if (!picker.params.routableModals) {
            picker.modal.destroy();
          }
        }
        delete picker.modal;
      });
    }
    if (picker.$el) {
      picker.$el.trigger("picker:closed");
    }
    if (picker.$inputEl) {
      picker.$inputEl.trigger("picker:closed");
    }
    picker.emit("local::closed pickerClosed", picker);
  }
  open() {
    const picker = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      $scrollToEl,
      params
    } = picker;
    if (opened)
      return;
    if (picker.cols.length === 0 && params.cols.length) {
      params.cols.forEach((col) => {
        picker.cols.push(col);
      });
    }
    if (inline) {
      picker.$el = dom7_default(picker.render());
      picker.$el[0].f7Picker = picker;
      picker.$containerEl.append(picker.$el);
      picker.onOpen();
      picker.onOpened();
      return;
    }
    const isPopover = picker.isPopover();
    const modalType = isPopover ? "popover" : "sheet";
    const modalParams = {
      targetEl: $inputEl,
      scrollToEl: $scrollToEl,
      content: picker.render(),
      backdrop: typeof params.backdrop !== "undefined" ? params.backdrop : isPopover,
      on: {
        open() {
          const modal = this;
          picker.modal = modal;
          picker.$el = isPopover ? modal.$el.find(".picker") : modal.$el;
          picker.$el[0].f7Picker = picker;
          picker.onOpen();
        },
        opened() {
          picker.onOpened();
        },
        close() {
          picker.onClose();
        },
        closed() {
          picker.onClosed();
        }
      }
    };
    if (modalType === "sheet") {
      modalParams.push = params.sheetPush;
      modalParams.swipeToClose = params.sheetSwipeToClose;
    }
    if (params.routableModals && picker.view) {
      picker.view.router.navigate({
        url: picker.url,
        route: {
          path: picker.url,
          [modalType]: modalParams
        }
      });
    } else {
      picker.modal = app[modalType].create(modalParams);
      picker.modal.open();
    }
  }
  close() {
    const picker = this;
    const {
      opened,
      inline
    } = picker;
    if (!opened)
      return;
    if (inline) {
      picker.onClose();
      picker.onClosed();
      return;
    }
    if (picker.params.routableModals && picker.view) {
      picker.view.router.back();
    } else {
      picker.modal.close();
    }
  }
  init() {
    const picker = this;
    picker.initInput();
    if (picker.inline) {
      picker.open();
      picker.emit("local::init pickerInit", picker);
      return;
    }
    if (!picker.initialized && picker.params.value) {
      picker.setValue(picker.params.value);
    }
    if (picker.$inputEl) {
      picker.attachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.attachHtmlEvents();
    }
    picker.emit("local::init pickerInit", picker);
  }
  destroy() {
    const picker = this;
    if (picker.destroyed)
      return;
    const {
      $el
    } = picker;
    picker.emit("local::beforeDestroy pickerBeforeDestroy", picker);
    if ($el)
      $el.trigger("picker:beforedestroy");
    picker.close();
    if (picker.$inputEl) {
      picker.detachInputEvents();
    }
    if (picker.params.closeByOutsideClick) {
      picker.detachHtmlEvents();
    }
    if ($el && $el.length)
      delete picker.$el[0].f7Picker;
    deleteProps(picker);
    picker.destroyed = true;
  }
};
var picker_class_default = Picker;

// node_modules/framework7/components/picker/picker.js
var picker_default = {
  name: "picker",
  static: {
    Picker: picker_class_default
  },
  create() {
    const app = this;
    app.picker = ConstructorMethods({
      defaultSelector: ".picker",
      constructor: picker_class_default,
      app,
      domProp: "f7Picker"
    });
    app.picker.close = function close6(el) {
      if (el === void 0) {
        el = ".picker";
      }
      const $el = dom7_default(el);
      if ($el.length === 0)
        return;
      const picker = $el[0].f7Picker;
      if (!picker || picker && !picker.opened)
        return;
      picker.close();
    };
  },
  params: {
    picker: {
      rotateEffect: false,
      freeMode: false,
      cols: [],
      containerEl: null,
      openIn: "auto",
      sheetPush: false,
      sheetSwipeToClose: void 0,
      backdrop: void 0,
      formatValue: null,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      scrollToEl: void 0,
      toolbar: true,
      toolbarCloseText: "Done",
      cssClass: null,
      routableModals: false,
      view: null,
      url: "select/",
      renderToolbar: null,
      render: null
    }
  }
};

// node_modules/framework7/components/infinite-scroll/infinite-scroll.js
var InfiniteScroll = {
  handle(el, e) {
    const app = this;
    const $el = dom7_default(el);
    const scrollTop = $el[0].scrollTop;
    const scrollHeight = $el[0].scrollHeight;
    const height = $el[0].offsetHeight;
    let distance = $el[0].getAttribute("data-infinite-distance");
    const virtualListContainer = $el.find(".virtual-list");
    let virtualList;
    const onTop = $el.hasClass("infinite-scroll-top");
    if (!distance)
      distance = 50;
    if (typeof distance === "string" && distance.indexOf("%") >= 0) {
      distance = parseInt(distance, 10) / 100 * height;
    }
    if (distance > height)
      distance = height;
    if (onTop) {
      if (scrollTop < distance) {
        $el.trigger("infinite", e);
        app.emit("infinite", $el[0], e);
      }
    } else if (scrollTop + height >= scrollHeight - distance) {
      if (virtualListContainer.length > 0) {
        virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
        if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
          return;
        }
      }
      $el.trigger("infinite", e);
      app.emit("infinite", $el[0], e);
    }
  },
  create(el) {
    const $el = dom7_default(el);
    const app = this;
    function scrollHandler(e) {
      app.infiniteScroll.handle(this, e);
    }
    $el.each((element) => {
      element.f7InfiniteScrollHandler = scrollHandler;
      element.addEventListener("scroll", element.f7InfiniteScrollHandler);
    });
  },
  destroy(el) {
    const $el = dom7_default(el);
    $el.each((element) => {
      element.removeEventListener("scroll", element.f7InfiniteScrollHandler);
      delete element.f7InfiniteScrollHandler;
    });
  }
};
var infinite_scroll_default = {
  name: "infiniteScroll",
  create() {
    const app = this;
    bindMethods(app, {
      infiniteScroll: InfiniteScroll
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      const $isEls = $tabEl.find(".infinite-scroll-content");
      if ($tabEl.is(".infinite-scroll-content"))
        $isEls.add($tabEl);
      $isEls.each((el) => {
        app.infiniteScroll.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = dom7_default(tabEl);
      const app = this;
      const $isEls = $tabEl.find(".infinite-scroll-content");
      if ($tabEl.is(".infinite-scroll-content"))
        $isEls.add($tabEl);
      $isEls.each((el) => {
        app.infiniteScroll.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".infinite-scroll-content").each((el) => {
        app.infiniteScroll.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".infinite-scroll-content").each((el) => {
        app.infiniteScroll.destroy(el);
      });
    }
  }
};

// node_modules/framework7/components/pull-to-refresh/pull-to-refresh-class.js
var PullToRefresh = class extends class_default {
  constructor(app, el) {
    super({}, [app]);
    const ptr = this;
    const device = getDevice();
    const support2 = getSupport();
    const $el = dom7_default(el);
    const $preloaderEl = $el.find(".ptr-preloader");
    ptr.$el = $el;
    ptr.el = $el[0];
    ptr.app = app;
    ptr.bottom = ptr.$el.hasClass("ptr-bottom");
    ptr.useModulesParams({});
    const isMaterial = app.theme === "md";
    const isIos = app.theme === "ios";
    const isAurora = app.theme === "aurora";
    ptr.done = function done() {
      const $transitionTarget = isMaterial ? $preloaderEl : $el;
      const onTranstionEnd = (e) => {
        if (dom7_default(e.target).closest($preloaderEl).length)
          return;
        $el.removeClass("ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing");
        $el.trigger("ptr:done");
        ptr.emit("local::done ptrDone", $el[0]);
        $transitionTarget.off("transitionend", onTranstionEnd);
      };
      $transitionTarget.on("transitionend", onTranstionEnd);
      $el.removeClass("ptr-refreshing").addClass("ptr-transitioning ptr-closing");
      return ptr;
    };
    ptr.refresh = function refresh2() {
      if ($el.hasClass("ptr-refreshing"))
        return ptr;
      $el.addClass("ptr-transitioning ptr-refreshing");
      $el.trigger("ptr:refresh", ptr.done);
      ptr.emit("local::refresh ptrRefresh", $el[0], ptr.done);
      return ptr;
    };
    ptr.mousewheel = $el.attr("data-ptr-mousewheel") === "true";
    let touchId;
    let isTouched;
    let isMoved;
    const touchesStart = {};
    let isScrolling;
    let touchesDiff;
    let refresh = false;
    let useTranslate = false;
    let forceUseTranslate = false;
    let startTranslate = 0;
    let translate;
    let scrollTop;
    let wasScrolled;
    let triggerDistance;
    let dynamicTriggerDistance;
    let pullStarted;
    let hasNavbar = false;
    let scrollHeight;
    let offsetHeight;
    let maxScrollTop;
    const $pageEl = $el.parents(".page");
    if ($pageEl.find(".navbar").length > 0 || $pageEl.parents(".view").children(".navbars").length > 0)
      hasNavbar = true;
    if ($pageEl.hasClass("no-navbar"))
      hasNavbar = false;
    if (!ptr.bottom) {
      const pageNavbarEl = app.navbar.getElByPage($pageEl[0]);
      if (pageNavbarEl) {
        const $pageNavbarEl = dom7_default(pageNavbarEl);
        const isLargeTransparent = $pageNavbarEl.hasClass("navbar-large-transparent") || $pageNavbarEl.hasClass("navbar-large") && $pageNavbarEl.hasClass("navbar-transparent");
        const isTransparent = $pageNavbarEl.hasClass("navbar-transparent") && !$pageNavbarEl.hasClass("navbar-large");
        if (isLargeTransparent) {
          $el.addClass("ptr-with-navbar-large-transparent");
        } else if (isTransparent) {
          $el.addClass("ptr-with-navbar-transparent");
        }
      }
    }
    if (!hasNavbar && !ptr.bottom)
      $el.addClass("ptr-no-navbar");
    if ($el.attr("data-ptr-distance")) {
      dynamicTriggerDistance = true;
    } else if (isMaterial) {
      triggerDistance = 66;
    } else if (isIos) {
      triggerDistance = 44;
    } else if (isAurora) {
      triggerDistance = 38;
    }
    function setPreloaderProgress(progress) {
      if (progress === void 0) {
        progress = 0;
      }
      const $bars = $preloaderEl.find(".preloader-inner-line");
      const perBarProgress = 1 / $bars.length;
      $bars.forEach((barEl, barIndex) => {
        const barProgress = (progress - barIndex * perBarProgress) / perBarProgress;
        barEl.style.opacity = Math.max(Math.min(barProgress, 1), 0) * 0.27;
      });
    }
    function unsetPreloaderProgress() {
      $preloaderEl.find(".preloader-inner-line").css("opacity", "");
    }
    function handleTouchStart(e) {
      if (isTouched) {
        if (device.os === "android") {
          if ("targetTouches" in e && e.targetTouches.length > 1)
            return;
        } else
          return;
      }
      if ($el.hasClass("ptr-refreshing")) {
        return;
      }
      if (dom7_default(e.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length)
        return;
      isMoved = false;
      pullStarted = false;
      isTouched = true;
      isScrolling = void 0;
      wasScrolled = void 0;
      if (e.type === "touchstart")
        touchId = e.targetTouches[0].identifier;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      let pageX;
      let pageY;
      let touch;
      if (e.type === "touchmove") {
        if (touchId && e.touches) {
          for (let i = 0; i < e.touches.length; i += 1) {
            if (e.touches[i].identifier === touchId) {
              touch = e.touches[i];
            }
          }
        }
        if (!touch)
          touch = e.targetTouches[0];
        pageX = touch.pageX;
        pageY = touch.pageY;
      } else {
        pageX = e.pageX;
        pageY = e.pageY;
      }
      if (!pageX || !pageY)
        return;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (!isScrolling) {
        isTouched = false;
        return;
      }
      scrollTop = $el[0].scrollTop;
      if (!isMoved) {
        $el.removeClass("ptr-transitioning");
        if (isIos) {
          setPreloaderProgress(0);
        }
        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;
        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }
        if (scrollTop > scrollHeight) {
          isTouched = false;
          return;
        }
        const $ptrWatchScrollable = dom7_default(e.target).closest(".ptr-watch-scroll");
        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each((ptrScrollableEl) => {
            if (ptrScrollableEl === el)
              return;
            if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && dom7_default(ptrScrollableEl).css("overflow") === "auto" && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
              targetIsScrollable = true;
            }
          });
        }
        if (targetIsScrollable) {
          isTouched = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr("data-ptr-distance");
          if (triggerDistance.indexOf("%") >= 0)
            triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
        }
        startTranslate = $el.hasClass("ptr-refreshing") ? triggerDistance : 0;
        if (scrollHeight === offsetHeight || device.os !== "ios" || isMaterial) {
          useTranslate = true;
        } else {
          useTranslate = false;
        }
        forceUseTranslate = false;
      }
      isMoved = true;
      touchesDiff = pageY - touchesStart.y;
      if (typeof wasScrolled === "undefined" && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0))
        wasScrolled = true;
      const ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;
      if (ptrStarted) {
        if (device.os === "ios" && parseInt(device.osVersion.split(".")[0], 10) > 7) {
          if (!ptr.bottom && scrollTop === 0 && !wasScrolled)
            useTranslate = true;
          if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled)
            useTranslate = true;
        }
        if (!useTranslate && ptr.bottom && !isMaterial) {
          $el.css("-webkit-overflow-scrolling", "auto");
          $el.scrollTop(maxScrollTop);
          forceUseTranslate = true;
        }
        if (useTranslate || forceUseTranslate) {
          if (e.cancelable) {
            e.preventDefault();
          }
          translate = (ptr.bottom ? -1 * Math.abs(touchesDiff) ** 0.85 : touchesDiff ** 0.85) + startTranslate;
          if (isMaterial) {
            $preloaderEl.transform(`translate3d(0,${translate}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(touchesDiff) / 66) + 100}deg)`);
          } else {
            if (ptr.bottom || isIos) {
              $el.children().transform(`translate3d(0,${translate}px,0)`);
            } else {
              $el.transform(`translate3d(0,${translate}px,0)`);
            }
            if (isIos) {
              $preloaderEl.transform(`translate3d(0,0px,0)`);
            }
          }
        } else if (isIos && !ptr.bottom) {
          $preloaderEl.transform(`translate3d(0,${scrollTop}px,0)`);
        }
        let progress;
        if (isIos && !refresh) {
          progress = useTranslate || forceUseTranslate ? Math.abs(touchesDiff) ** 0.85 / triggerDistance : Math.abs(touchesDiff) / (triggerDistance * 2);
          setPreloaderProgress(progress);
        }
        if ((useTranslate || forceUseTranslate) && Math.abs(touchesDiff) ** 0.85 > triggerDistance || !useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2) {
          refresh = true;
          $el.addClass("ptr-pull-up").removeClass("ptr-pull-down");
          unsetPreloaderProgress();
        } else {
          refresh = false;
          $el.removeClass("ptr-pull-up").addClass("ptr-pull-down");
        }
        if (!pullStarted) {
          $el.trigger("ptr:pullstart");
          ptr.emit("local::pullStart ptrPullStart", $el[0]);
          pullStarted = true;
        }
        $el.trigger("ptr:pullmove", {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
        ptr.emit("local::pullMove ptrPullMove", $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
      } else {
        pullStarted = false;
        $el.removeClass("ptr-pull-up ptr-pull-down");
        refresh = false;
      }
    }
    function handleTouchEnd(e) {
      if (e.type === "touchend" && e.changedTouches && e.changedTouches.length > 0 && touchId) {
        if (e.changedTouches[0].identifier !== touchId) {
          isTouched = false;
          isScrolling = false;
          isMoved = false;
          touchId = null;
          return;
        }
      }
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      if (translate) {
        $el.addClass("ptr-transitioning");
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform("").find(".ptr-arrow").transform("");
      } else {
        $preloaderEl.transform("");
        if (ptr.bottom || isIos) {
          $el.children().transform("");
        } else {
          $el.transform("");
        }
      }
      if (!useTranslate && ptr.bottom && !isMaterial) {
        $el.css("-webkit-overflow-scrolling", "");
      }
      if (refresh) {
        $el.addClass("ptr-refreshing");
        $el.trigger("ptr:refresh", ptr.done);
        ptr.emit("local::refresh ptrRefresh", $el[0], ptr.done);
      } else {
        $el.removeClass("ptr-pull-down");
      }
      isTouched = false;
      isMoved = false;
      if (pullStarted) {
        $el.trigger("ptr:pullend");
        ptr.emit("local::pullEnd ptrPullEnd", $el[0]);
      }
    }
    let mousewheelTimeout;
    let mousewheelMoved;
    let mousewheelAllow = true;
    let mousewheelTranslate = 0;
    function handleMouseWheelRelease() {
      mousewheelAllow = true;
      mousewheelMoved = false;
      mousewheelTranslate = 0;
      if (translate) {
        $el.addClass("ptr-transitioning");
        translate = 0;
      }
      if (isMaterial) {
        $preloaderEl.transform("").find(".ptr-arrow").transform("");
      } else {
        $preloaderEl.transform("");
        if (ptr.bottom) {
          $el.children().transform("");
        } else {
          $el.transform("");
        }
      }
      if (refresh) {
        $el.addClass("ptr-refreshing");
        $el.trigger("ptr:refresh", ptr.done);
        ptr.emit("local::refresh ptrRefresh", $el[0], ptr.done);
      } else {
        $el.removeClass("ptr-pull-down");
      }
      if (pullStarted) {
        $el.trigger("ptr:pullend");
        ptr.emit("local::pullEnd ptrPullEnd", $el[0]);
      }
    }
    function handleMouseWheel(e) {
      if (!mousewheelAllow)
        return;
      const {
        deltaX,
        deltaY
      } = e;
      if (Math.abs(deltaX) > Math.abs(deltaY))
        return;
      if ($el.hasClass("ptr-refreshing")) {
        return;
      }
      if (dom7_default(e.target).closest(".sortable-handler, .ptr-ignore, .card-expandable.card-opened").length)
        return;
      clearTimeout(mousewheelTimeout);
      scrollTop = $el[0].scrollTop;
      if (!mousewheelMoved) {
        $el.removeClass("ptr-transitioning");
        if (isIos) {
          setPreloaderProgress(0);
        }
        let targetIsScrollable;
        scrollHeight = $el[0].scrollHeight;
        offsetHeight = $el[0].offsetHeight;
        if (ptr.bottom) {
          maxScrollTop = scrollHeight - offsetHeight;
        }
        if (scrollTop > scrollHeight) {
          mousewheelAllow = false;
          return;
        }
        const $ptrWatchScrollable = dom7_default(e.target).closest(".ptr-watch-scroll");
        if ($ptrWatchScrollable.length) {
          $ptrWatchScrollable.each((ptrScrollableEl) => {
            if (ptrScrollableEl === el)
              return;
            if (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight && dom7_default(ptrScrollableEl).css("overflow") === "auto" && (!ptr.bottom && ptrScrollableEl.scrollTop > 0 || ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)) {
              targetIsScrollable = true;
            }
          });
        }
        if (targetIsScrollable) {
          mousewheelAllow = false;
          return;
        }
        if (dynamicTriggerDistance) {
          triggerDistance = $el.attr("data-ptr-distance");
          if (triggerDistance.indexOf("%") >= 0)
            triggerDistance = scrollHeight * parseInt(triggerDistance, 10) / 100;
        }
      }
      isMoved = true;
      mousewheelTranslate -= deltaY;
      touchesDiff = mousewheelTranslate;
      if (typeof wasScrolled === "undefined" && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0))
        wasScrolled = true;
      const ptrStarted = ptr.bottom ? touchesDiff < 0 && scrollTop >= maxScrollTop || scrollTop > maxScrollTop : touchesDiff > 0 && scrollTop <= 0 || scrollTop < 0;
      if (ptrStarted) {
        if (e.cancelable) {
          e.preventDefault();
        }
        translate = touchesDiff;
        if (Math.abs(translate) > triggerDistance) {
          translate = triggerDistance + (Math.abs(translate) - triggerDistance) ** 0.7;
          if (ptr.bottom)
            translate = -translate;
        }
        if (isMaterial) {
          $preloaderEl.transform(`translate3d(0,${translate}px,0)`).find(".ptr-arrow").transform(`rotate(${180 * (Math.abs(touchesDiff) / 66) + 100}deg)`);
        } else {
          if (ptr.bottom) {
            $el.children().transform(`translate3d(0,${translate}px,0)`);
          } else {
            $el.transform(`translate3d(0,${translate}px,0)`);
            if (isIos) {
              $preloaderEl.transform(`translate3d(0,${-translate}px,0)`);
            }
          }
        }
        let progress;
        if (isIos && !refresh) {
          progress = Math.abs(translate) / triggerDistance;
          setPreloaderProgress(progress);
        }
        if (Math.abs(translate) > triggerDistance) {
          refresh = true;
          $el.addClass("ptr-pull-up").removeClass("ptr-pull-down");
          unsetPreloaderProgress();
        } else {
          refresh = false;
          $el.removeClass("ptr-pull-up").addClass("ptr-pull-down");
        }
        if (!pullStarted) {
          $el.trigger("ptr:pullstart");
          ptr.emit("local::pullStart ptrPullStart", $el[0]);
          pullStarted = true;
        }
        $el.trigger("ptr:pullmove", {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
        ptr.emit("local::pullMove ptrPullMove", $el[0], {
          event: e,
          scrollTop,
          translate,
          touchesDiff
        });
      } else {
        pullStarted = false;
        $el.removeClass("ptr-pull-up ptr-pull-down");
        refresh = false;
      }
      mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
    }
    if (!$pageEl.length || !$el.length)
      return ptr;
    $el[0].f7PullToRefresh = ptr;
    ptr.attachEvents = function attachEvents2() {
      const passive = support2.passiveListener ? {
        passive: true
      } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passive);
      app.on("touchmove:active", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
      if (ptr.mousewheel && !ptr.bottom) {
        $el.on("wheel", handleMouseWheel);
      }
    };
    ptr.detachEvents = function detachEvents2() {
      const passive = support2.passiveListener ? {
        passive: true
      } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passive);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      if (ptr.mousewheel && !ptr.bottom) {
        $el.off("wheel", handleMouseWheel);
      }
    };
    ptr.useModules();
    ptr.init();
    return ptr;
  }
  init() {
    const ptr = this;
    ptr.attachEvents();
  }
  destroy() {
    let ptr = this;
    ptr.emit("local::beforeDestroy ptrBeforeDestroy", ptr);
    ptr.$el.trigger("ptr:beforedestroy");
    delete ptr.el.f7PullToRefresh;
    ptr.detachEvents();
    deleteProps(ptr);
    ptr = null;
  }
};
var pull_to_refresh_class_default = PullToRefresh;

// node_modules/framework7/components/pull-to-refresh/pull-to-refresh.js
var pull_to_refresh_default = {
  name: "pullToRefresh",
  create() {
    const app = this;
    app.ptr = extend(ConstructorMethods({
      defaultSelector: ".ptr-content",
      constructor: pull_to_refresh_class_default,
      app,
      domProp: "f7PullToRefresh"
    }), {
      done(el) {
        const ptr = app.ptr.get(el);
        if (ptr)
          return ptr.done();
        return void 0;
      },
      refresh(el) {
        const ptr = app.ptr.get(el);
        if (ptr)
          return ptr.refresh();
        return void 0;
      }
    });
  },
  static: {
    PullToRefresh: pull_to_refresh_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      const $ptrEls = $tabEl.find(".ptr-content");
      if ($tabEl.is(".ptr-content"))
        $ptrEls.add($tabEl);
      $ptrEls.each((el) => {
        app.ptr.create(el);
      });
    },
    tabBeforeRemove(tabEl) {
      const $tabEl = dom7_default(tabEl);
      const app = this;
      const $ptrEls = $tabEl.find(".ptr-content");
      if ($tabEl.is(".ptr-content"))
        $ptrEls.add($tabEl);
      $ptrEls.each((el) => {
        app.ptr.destroy(el);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".ptr-content").each((el) => {
        app.ptr.create(el);
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".ptr-content").each((el) => {
        app.ptr.destroy(el);
      });
    }
  }
};

// node_modules/framework7/components/lazy/lazy.js
var Lazy = {
  destroy(pageEl) {
    const $pageEl = dom7_default(pageEl).closest(".page");
    if (!$pageEl.length)
      return;
    if ($pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy();
    }
  },
  create(pageEl) {
    const app = this;
    const window2 = getWindow();
    const support2 = getSupport();
    const $pageEl = dom7_default(pageEl).closest(".page").eq(0);
    const $lazyLoadImages = $pageEl.find(".lazy");
    if ($lazyLoadImages.length === 0 && !$pageEl.hasClass("lazy"))
      return;
    const placeholderSrc = app.params.lazy.placeholder;
    if (placeholderSrc !== false) {
      $lazyLoadImages.each((lazyEl) => {
        if (dom7_default(lazyEl).attr("data-src") && !dom7_default(lazyEl).attr("src"))
          dom7_default(lazyEl).attr("src", placeholderSrc);
      });
    }
    const imagesSequence = [];
    let imageIsLoading = false;
    function onImageComplete(lazyEl) {
      if (imagesSequence.indexOf(lazyEl) >= 0) {
        imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
      }
      imageIsLoading = false;
      if (app.params.lazy.sequential && imagesSequence.length > 0) {
        imageIsLoading = true;
        app.lazy.loadImage(imagesSequence[0], onImageComplete);
      }
    }
    function observerCallback(entries, observer) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          if (app.params.lazy.sequential && imageIsLoading) {
            if (imagesSequence.indexOf(entry.target) < 0)
              imagesSequence.push(entry.target);
            return;
          }
          imageIsLoading = true;
          app.lazy.loadImage(entry.target, onImageComplete);
          observer.unobserve(entry.target);
        }
      });
    }
    if (app.params.lazy.observer && support2.intersectionObserver) {
      let observer = $pageEl[0].f7LazyObserver;
      if (!observer) {
        observer = new window2.IntersectionObserver(observerCallback, {
          root: $pageEl[0]
        });
      }
      $lazyLoadImages.each((el) => {
        if (el.f7LazyObserverAdded)
          return;
        el.f7LazyObserverAdded = true;
        observer.observe(el);
      });
      if (!$pageEl[0].f7LazyDestroy) {
        $pageEl[0].f7LazyDestroy = () => {
          observer.disconnect();
          delete $pageEl[0].f7LazyDestroy;
          delete $pageEl[0].f7LazyObserver;
        };
      }
      return;
    }
    function lazyHandler() {
      app.lazy.load($pageEl, (lazyEl) => {
        if (app.params.lazy.sequential && imageIsLoading) {
          if (imagesSequence.indexOf(lazyEl) < 0)
            imagesSequence.push(lazyEl);
          return;
        }
        imageIsLoading = true;
        app.lazy.loadImage(lazyEl, onImageComplete);
      });
    }
    function attachEvents2() {
      $pageEl[0].f7LazyAttached = true;
      $pageEl.on("lazy", lazyHandler);
      $pageEl.on("scroll", lazyHandler, true);
      $pageEl.find(".tab").on("tab:mounted tab:show", lazyHandler);
      app.on("resize", lazyHandler);
    }
    function detachEvents2() {
      $pageEl[0].f7LazyAttached = false;
      delete $pageEl[0].f7LazyAttached;
      $pageEl.off("lazy", lazyHandler);
      $pageEl.off("scroll", lazyHandler, true);
      $pageEl.find(".tab").off("tab:mounted tab:show", lazyHandler);
      app.off("resize", lazyHandler);
    }
    if (!$pageEl[0].f7LazyDestroy) {
      $pageEl[0].f7LazyDestroy = detachEvents2;
    }
    if (!$pageEl[0].f7LazyAttached) {
      attachEvents2();
    }
    lazyHandler();
  },
  isInViewport(lazyEl) {
    const app = this;
    const rect = lazyEl.getBoundingClientRect();
    const threshold = app.params.lazy.threshold || 0;
    return rect.top >= 0 - threshold && rect.left >= 0 - threshold && rect.top <= app.height + threshold && rect.left <= app.width + threshold;
  },
  loadImage(imageEl, callback) {
    const app = this;
    const window2 = getWindow();
    const $imageEl = dom7_default(imageEl);
    const bg = $imageEl.attr("data-background");
    const src = bg || $imageEl.attr("data-src");
    function onLoad() {
      $imageEl.removeClass("lazy").addClass("lazy-loaded");
      if (bg) {
        $imageEl.css("background-image", `url(${src})`);
      } else if (src) {
        $imageEl.attr("src", src);
      }
      if (callback)
        callback(imageEl);
      $imageEl.trigger("lazy:loaded");
      app.emit("lazyLoaded", $imageEl[0]);
    }
    if (!src) {
      $imageEl.trigger("lazy:load");
      app.emit("lazyLoad", $imageEl[0]);
      onLoad();
      return;
    }
    function onError() {
      $imageEl.removeClass("lazy").addClass("lazy-loaded");
      if (bg) {
        $imageEl.css("background-image", `url(${app.params.lazy.placeholder || ""})`);
      } else {
        $imageEl.attr("src", app.params.lazy.placeholder || "");
      }
      if (callback)
        callback(imageEl);
      $imageEl.trigger("lazy:error");
      app.emit("lazyError", $imageEl[0]);
    }
    const image = new window2.Image();
    image.onload = onLoad;
    image.onerror = onError;
    image.src = src;
    $imageEl.removeAttr("data-src").removeAttr("data-background");
    $imageEl.trigger("lazy:load");
    app.emit("lazyLoad", $imageEl[0]);
  },
  load(pageEl, callback) {
    const app = this;
    let $pageEl = dom7_default(pageEl);
    if (!$pageEl.hasClass("page"))
      $pageEl = $pageEl.parents(".page").eq(0);
    if ($pageEl.length === 0) {
      return;
    }
    $pageEl.find(".lazy").each((lazyEl) => {
      const $lazyEl = dom7_default(lazyEl);
      if ($lazyEl.parents(".tab:not(.tab-active)").length > 0) {
        return;
      }
      if (app.lazy.isInViewport(lazyEl)) {
        if (callback)
          callback(lazyEl);
        else
          app.lazy.loadImage(lazyEl);
      }
    });
  }
};
var lazy_default = {
  name: "lazy",
  params: {
    lazy: {
      placeholder: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
      threshold: 0,
      sequential: true,
      observer: true
    }
  },
  create() {
    const app = this;
    bindMethods(app, {
      lazy: Lazy
    });
  },
  on: {
    pageInit(page) {
      const app = this;
      if (page.$el.find(".lazy").length > 0 || page.$el.hasClass("lazy")) {
        app.lazy.create(page.$el);
      }
    },
    pageAfterIn(page) {
      const app = this;
      const support2 = getSupport();
      if (app.params.lazy.observer && support2.intersectionObserver)
        return;
      if (page.$el.find(".lazy").length > 0 || page.$el.hasClass("lazy")) {
        app.lazy.create(page.$el);
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      if (page.$el.find(".lazy").length > 0 || page.$el.hasClass("lazy")) {
        app.lazy.destroy(page.$el);
      }
    },
    tabMounted(tabEl) {
      const app = this;
      const $tabEl = dom7_default(tabEl);
      if ($tabEl.find(".lazy").length > 0 || $tabEl.hasClass("lazy")) {
        app.lazy.create($tabEl);
      }
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      const support2 = getSupport();
      if (app.params.lazy.observer && support2.intersectionObserver)
        return;
      const $tabEl = dom7_default(tabEl);
      if ($tabEl.find(".lazy").length > 0 || $tabEl.hasClass("lazy")) {
        app.lazy.destroy($tabEl);
      }
    }
  }
};

// node_modules/framework7/components/data-table/data-table-class.js
var DataTable = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const table = this;
    const defaults = {};
    table.useModulesParams(defaults);
    table.params = extend(defaults, params);
    const $el = dom7_default(table.params.el);
    if ($el.length === 0)
      return void 0;
    table.$el = $el;
    table.el = $el[0];
    if (table.$el[0].f7DataTable) {
      const instance = table.$el[0].f7DataTable;
      table.destroy();
      return instance;
    }
    table.$el[0].f7DataTable = table;
    extend(table, {
      collapsible: $el.hasClass("data-table-collapsible"),
      $headerEl: $el.find(".data-table-header"),
      $headerSelectedEl: $el.find(".data-table-header-selected")
    });
    function handleChange(e) {
      if (e.detail && e.detail.sentByF7DataTable) {
        return;
      }
      const $inputEl = dom7_default(this);
      const checked = $inputEl[0].checked;
      const columnIndex = $inputEl.parents("td,th").index();
      if ($inputEl.parents("thead").length > 0) {
        if (columnIndex === 0) {
          $el.find("tbody tr")[checked ? "addClass" : "removeClass"]("data-table-row-selected");
        }
        $el.find(`tbody tr td:nth-child(${columnIndex + 1}) input`).prop("checked", checked).trigger("change", {
          sentByF7DataTable: true
        });
        $inputEl.prop("indeterminate", false);
      } else {
        if (columnIndex === 0) {
          $inputEl.parents("tr")[checked ? "addClass" : "removeClass"]("data-table-row-selected");
        }
        const checkedRows = $el.find(`tbody .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]:checked`).length;
        const totalRows = $el.find("tbody tr").length;
        const $headCheckboxEl = $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`);
        if (!checked) {
          $headCheckboxEl.prop("checked", false);
        } else if (checkedRows === totalRows) {
          $headCheckboxEl.prop("checked", true).trigger("change", {
            sentByF7DataTable: true
          });
        }
        $headCheckboxEl.prop("indeterminate", checkedRows > 0 && checkedRows < totalRows);
      }
      table.checkSelectedHeader();
    }
    function handleSortableClick() {
      const $cellEl = dom7_default(this);
      const isActive = $cellEl.hasClass("sortable-cell-active");
      const currentSort = $cellEl.hasClass("sortable-desc") ? "desc" : "asc";
      let newSort;
      if (isActive) {
        newSort = currentSort === "desc" ? "asc" : "desc";
        $cellEl.removeClass("sortable-desc sortable-asc").addClass(`sortable-${newSort}`);
      } else {
        $el.find("thead .sortable-cell-active").removeClass("sortable-cell-active");
        $cellEl.addClass("sortable-cell-active");
        newSort = currentSort;
      }
      $cellEl.trigger("datatable:sort", newSort);
      table.emit("local::sort dataTableSort", table, newSort);
    }
    table.attachEvents = function attachEvents2() {
      table.$el.on("change", '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find("thead .sortable-cell").on("click", handleSortableClick);
    };
    table.detachEvents = function detachEvents2() {
      table.$el.off("change", '.checkbox-cell input[type="checkbox"]', handleChange);
      table.$el.find("thead .sortable-cell").off("click", handleSortableClick);
    };
    table.useModules();
    table.init();
    return table;
  }
  setCollapsibleLabels() {
    const table = this;
    if (!table.collapsible)
      return;
    table.$el.find("tbody td:not(.checkbox-cell)").each((el) => {
      const $el = dom7_default(el);
      const elIndex = $el.index();
      const collpsibleTitle = $el.attr("data-collapsible-title");
      if (!collpsibleTitle && collpsibleTitle !== "") {
        $el.attr("data-collapsible-title", table.$el.find("thead th").eq(elIndex).text());
      }
    });
  }
  checkSelectedHeader() {
    const table = this;
    if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
      const checkedItems = table.$el.find("tbody .checkbox-cell input:checked").length;
      table.$el[checkedItems > 0 ? "addClass" : "removeClass"]("data-table-has-checked");
      table.$headerSelectedEl.find(".data-table-selected-count").text(checkedItems);
    }
  }
  init() {
    const table = this;
    table.attachEvents();
    table.setCollapsibleLabels();
    table.checkSelectedHeader();
  }
  destroy() {
    let table = this;
    table.$el.trigger("datatable:beforedestroy");
    table.emit("local::beforeDestroy dataTableBeforeDestroy", table);
    table.attachEvents();
    if (table.$el[0]) {
      table.$el[0].f7DataTable = null;
      delete table.$el[0].f7DataTable;
    }
    deleteProps(table);
    table = null;
  }
};
var data_table_class_default = DataTable;

// node_modules/framework7/components/data-table/data-table.js
var data_table_default = {
  name: "dataTable",
  static: {
    DataTable: data_table_class_default
  },
  create() {
    const app = this;
    app.dataTable = ConstructorMethods({
      defaultSelector: ".data-table",
      constructor: data_table_class_default,
      app,
      domProp: "f7DataTable"
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".data-table-init").each((tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".data-table-init").each((tableEl) => {
        app.dataTable.create({
          el: tableEl
        });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".data-table-init").each((tableEl) => {
        app.dataTable.destroy(tableEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".data-table-init").each((tableEl) => {
        app.dataTable.create({
          el: tableEl
        });
      });
    }
  },
  vnode: {
    "data-table-init": {
      insert(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.create({
          el: tableEl
        });
      },
      destroy(vnode) {
        const app = this;
        const tableEl = vnode.elm;
        app.dataTable.destroy(tableEl);
      }
    }
  }
};

// node_modules/framework7/components/fab/fab.js
var Fab = {
  morphOpen(fabEl, targetEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl);
    const $targetEl = dom7_default(targetEl);
    if ($targetEl.length === 0)
      return;
    $targetEl.transition(0).addClass("fab-morph-target-visible");
    const target = {
      width: $targetEl[0].offsetWidth,
      height: $targetEl[0].offsetHeight,
      offset: $targetEl.offset(),
      borderRadius: $targetEl.css("border-radius"),
      zIndex: $targetEl.css("z-index")
    };
    const fab = {
      width: $fabEl[0].offsetWidth,
      height: $fabEl[0].offsetHeight,
      offset: $fabEl.offset(),
      translateX: getTranslate($fabEl[0], "x"),
      translateY: getTranslate($fabEl[0], "y")
    };
    $fabEl[0].f7FabMorphData = {
      $targetEl,
      target,
      fab
    };
    const diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
    const diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;
    let borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
    if (borderRadius > 0)
      borderRadius += 2;
    $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
      $fabEl.transition(0).transform("");
      $targetEl.transition(0);
      target.width = $targetEl[0].offsetWidth;
      target.height = $targetEl[0].offsetHeight;
      target.offset = $targetEl.offset();
      fab.offset = $fabEl.offset();
      const diffXNew = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
      const diffYNew = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
      const scaleXNew = target.width / fab.width;
      const scaleYNew = target.height / fab.height;
      $fabEl.transform(`translate3d(${-diffXNew}px, ${-diffYNew}px, 0) scale(${scaleXNew}, ${scaleYNew})`);
    };
    $targetEl.css("opacity", 0).transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl.addClass("fab-opened").css("z-index", target.zIndex - 1).transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $targetEl.transition("");
      nextFrame(() => {
        $targetEl.css("opacity", 1).transform("scale(1,1)");
        $fabEl.transform(`translate3d(${-diffX}px, ${-diffY}px, 0) scale(${scaleX}, ${scaleY})`).css("border-radius", `${borderRadius}px`).css("box-shadow", "none").css("opacity", "0");
      });
      app.on("resize", $fabEl[0].f7FabMorphResizeHandler);
      if ($targetEl.parents(".page-content").length > 0) {
        $targetEl.parents(".page-content").on("scroll", $fabEl[0].f7FabMorphResizeHandler);
      }
    });
  },
  morphClose(fabEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl);
    const morphData = $fabEl[0].f7FabMorphData;
    if (!morphData)
      return;
    const {
      $targetEl,
      target,
      fab
    } = morphData;
    if ($targetEl.length === 0)
      return;
    const diffX = fab.offset.left + fab.width / 2 - (target.offset.left + target.width / 2) - fab.translateX;
    const diffY = fab.offset.top + fab.height / 2 - (target.offset.top + target.height / 2) - fab.translateY;
    const scaleX = target.width / fab.width;
    const scaleY = target.height / fab.height;
    app.off("resize", $fabEl[0].f7FabMorphResizeHandler);
    if ($targetEl.parents(".page-content").length > 0) {
      $targetEl.parents(".page-content").off("scroll", $fabEl[0].f7FabMorphResizeHandler);
    }
    $targetEl.css("opacity", 0).transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
    $fabEl.transition("").css("box-shadow", "").css("border-radius", "").css("opacity", "1").transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
    $fabEl.transitionEnd(() => {
      $fabEl.css("z-index", "").removeClass("fab-opened").transform("");
      nextFrame(() => {
        $fabEl.transitionEnd(() => {
          $targetEl.removeClass("fab-morph-target-visible").css("opacity", "").transform("").transition("");
        });
      });
    });
  },
  open(fabEl, targetEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl).eq(0);
    const $buttonsEl = $fabEl.find(".fab-buttons");
    if (!$fabEl.length)
      return;
    if ($fabEl.hasClass("fab-opened"))
      return;
    if (!$buttonsEl.length && !$fabEl.hasClass("fab-morph"))
      return;
    if (app.fab.openedEl) {
      if (app.fab.openedEl === $fabEl[0])
        return;
      app.fab.close(app.fab.openedEl);
    }
    app.fab.openedEl = $fabEl[0];
    if ($fabEl.hasClass("fab-morph")) {
      app.fab.morphOpen($fabEl, targetEl || $fabEl.attr("data-morph-to"));
    } else {
      $fabEl.addClass("fab-opened");
    }
    $fabEl.siblings(".fab-backdrop").addClass("backdrop-in");
    $fabEl.trigger("fab:open");
  },
  close(fabEl) {
    if (fabEl === void 0) {
      fabEl = ".fab-opened";
    }
    const app = this;
    const $fabEl = dom7_default(fabEl).eq(0);
    const $buttonsEl = $fabEl.find(".fab-buttons");
    if (!$fabEl.length)
      return;
    if (!$fabEl.hasClass("fab-opened"))
      return;
    if (!$buttonsEl.length && !$fabEl.hasClass("fab-morph"))
      return;
    app.fab.openedEl = null;
    if ($fabEl.hasClass("fab-morph")) {
      app.fab.morphClose($fabEl);
    } else {
      $fabEl.removeClass("fab-opened");
    }
    $fabEl.siblings(".fab-backdrop").removeClass("backdrop-in");
    $fabEl.trigger("fab:close");
  },
  toggle(fabEl) {
    const app = this;
    const $fabEl = dom7_default(fabEl);
    if (!$fabEl.hasClass("fab-opened"))
      app.fab.open(fabEl);
    else
      app.fab.close(fabEl);
  }
};
var fab_default = {
  name: "fab",
  create() {
    const app = this;
    bindMethods(app, {
      fab: {
        openedEl: null,
        ...Fab
      }
    });
  },
  clicks: {
    ".fab > a": function open4($clickedEl) {
      const app = this;
      app.fab.toggle($clickedEl.parents(".fab"));
    },
    ".fab-open": function open5($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.fab.open(data.fab);
    },
    ".fab-close": function close4($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      app.fab.close(data.fab);
    },
    ".fab-backdrop": function close5() {
      const app = this;
      app.fab.close();
    }
  }
};

// node_modules/framework7/components/searchbar/searchbar-class.js
var Searchbar = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const sb = this;
    const defaults = {
      el: void 0,
      inputEl: void 0,
      inputEvents: "change input compositionend",
      disableButton: true,
      disableButtonEl: void 0,
      backdropEl: void 0,
      searchContainer: void 0,
      searchItem: "li",
      searchIn: void 0,
      searchGroup: ".list-group",
      searchGroupTitle: ".item-divider, .list-group-title",
      ignore: ".searchbar-ignore",
      foundEl: ".searchbar-found",
      notFoundEl: ".searchbar-not-found",
      hideOnEnableEl: ".searchbar-hide-on-enable",
      hideOnSearchEl: ".searchbar-hide-on-search",
      backdrop: void 0,
      removeDiacritics: true,
      customSearch: false,
      hideDividers: true,
      hideGroups: true,
      disableOnBackdropClick: true,
      expandable: false,
      inline: false
    };
    sb.useModulesParams(defaults);
    sb.params = extend(defaults, params);
    const $el = dom7_default(sb.params.el);
    if ($el.length === 0)
      return sb;
    if ($el[0].f7Searchbar)
      return $el[0].f7Searchbar;
    $el[0].f7Searchbar = sb;
    let $pageEl;
    const $navbarEl = $el.parents(".navbar");
    if ($el.parents(".page").length > 0) {
      $pageEl = $el.parents(".page");
    } else if ($navbarEl.length > 0) {
      $pageEl = dom7_default(app.navbar.getPageByEl($navbarEl[0]));
      if (!$pageEl.length) {
        const $currentPageEl = $el.parents(".view").find(".page-current");
        if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
          $pageEl = $currentPageEl;
        }
      }
    }
    let $foundEl;
    if (params.foundEl) {
      $foundEl = dom7_default(params.foundEl);
    } else if (typeof sb.params.foundEl === "string" && $pageEl) {
      $foundEl = $pageEl.find(sb.params.foundEl);
    }
    let $notFoundEl;
    if (params.notFoundEl) {
      $notFoundEl = dom7_default(params.notFoundEl);
    } else if (typeof sb.params.notFoundEl === "string" && $pageEl) {
      $notFoundEl = $pageEl.find(sb.params.notFoundEl);
    }
    let $hideOnEnableEl;
    if (params.hideOnEnableEl) {
      $hideOnEnableEl = dom7_default(params.hideOnEnableEl);
    } else if (typeof sb.params.hideOnEnableEl === "string" && $pageEl) {
      $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
    }
    let $hideOnSearchEl;
    if (params.hideOnSearchEl) {
      $hideOnSearchEl = dom7_default(params.hideOnSearchEl);
    } else if (typeof sb.params.hideOnSearchEl === "string" && $pageEl) {
      $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
    }
    const expandable = sb.params.expandable || $el.hasClass("searchbar-expandable");
    const inline = sb.params.inline || $el.hasClass("searchbar-inline");
    if (typeof sb.params.backdrop === "undefined") {
      if (!inline)
        sb.params.backdrop = app.theme !== "aurora";
      else
        sb.params.backdrop = false;
    }
    let $backdropEl;
    if (sb.params.backdrop) {
      if (sb.params.backdropEl) {
        $backdropEl = dom7_default(sb.params.backdropEl);
      } else if ($pageEl && $pageEl.length > 0) {
        $backdropEl = $pageEl.find(".searchbar-backdrop");
      } else {
        $backdropEl = $el.siblings(".searchbar-backdrop");
      }
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="searchbar-backdrop"></div>');
        if ($pageEl && $pageEl.length) {
          if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
            $backdropEl.insertBefore($el);
          } else {
            $backdropEl.insertBefore($pageEl.find(".page-content").eq(0));
          }
        } else {
          $backdropEl.insertBefore($el);
        }
      }
    }
    let $searchContainer;
    if (sb.params.searchContainer) {
      $searchContainer = dom7_default(sb.params.searchContainer);
    }
    let $inputEl;
    if (sb.params.inputEl) {
      $inputEl = dom7_default(sb.params.inputEl);
    } else {
      $inputEl = $el.find('input[type="search"]').eq(0);
    }
    let $disableButtonEl;
    if (sb.params.disableButton) {
      if (sb.params.disableButtonEl) {
        $disableButtonEl = dom7_default(sb.params.disableButtonEl);
      } else {
        $disableButtonEl = $el.find(".searchbar-disable-button");
      }
    }
    extend(sb, {
      app,
      view: app.views.get($el.parents(".view")),
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      $searchContainer,
      searchContainer: $searchContainer && $searchContainer[0],
      $inputEl,
      inputEl: $inputEl[0],
      $disableButtonEl,
      disableButtonEl: $disableButtonEl && $disableButtonEl[0],
      disableButtonHasMargin: false,
      $pageEl,
      pageEl: $pageEl && $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl && $navbarEl[0],
      $foundEl,
      foundEl: $foundEl && $foundEl[0],
      $notFoundEl,
      notFoundEl: $notFoundEl && $notFoundEl[0],
      $hideOnEnableEl,
      hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
      $hideOnSearchEl,
      hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
      previousQuery: "",
      query: "",
      isVirtualList: $searchContainer && $searchContainer.hasClass("virtual-list"),
      virtualList: void 0,
      enabled: false,
      expandable,
      inline
    });
    function preventSubmit(e) {
      e.preventDefault();
    }
    function onInputFocus(e) {
      sb.enable(e);
      sb.$el.addClass("searchbar-focused");
    }
    function onInputBlur() {
      sb.$el.removeClass("searchbar-focused");
      if (app.theme === "aurora" && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
        sb.disable();
      }
    }
    function onInputChange() {
      const value = sb.$inputEl.val().trim();
      if (sb.$searchContainer && sb.$searchContainer.length > 0 && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem) || sb.params.customSearch) {
        sb.search(value, true);
      }
    }
    function onInputClear(e, previousValue) {
      sb.$el.trigger("searchbar:clear", previousValue);
      sb.emit("local::clear searchbarClear", sb, previousValue);
    }
    function disableOnClick(e) {
      sb.disable(e);
    }
    function onPageBeforeOut() {
      if (!sb || sb && !sb.$el)
        return;
      if (sb.enabled) {
        sb.$el.removeClass("searchbar-enabled");
        if (sb.expandable) {
          sb.$el.parents(".navbar").removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition");
        }
      }
    }
    function onPageBeforeIn() {
      if (!sb || sb && !sb.$el)
        return;
      if (sb.enabled) {
        sb.$el.addClass("searchbar-enabled");
        if (sb.expandable) {
          sb.$el.parents(".navbar").addClass("with-searchbar-expandable-enabled-no-transition");
        }
      }
    }
    sb.attachEvents = function attachEvents2() {
      $el.on("submit", preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.on("click", disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.on("click", disableOnClick);
      }
      if (sb.expandable && app.theme === "ios" && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.on("page:beforeout", onPageBeforeOut);
        sb.$pageEl.on("page:beforein", onPageBeforeIn);
      }
      sb.$inputEl.on("focus", onInputFocus);
      sb.$inputEl.on("blur", onInputBlur);
      sb.$inputEl.on(sb.params.inputEvents, onInputChange);
      sb.$inputEl.on("input:clear", onInputClear);
    };
    sb.detachEvents = function detachEvents2() {
      $el.off("submit", preventSubmit);
      if (sb.params.disableButton) {
        sb.$disableButtonEl.off("click", disableOnClick);
      }
      if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
        sb.$backdropEl.off("click", disableOnClick);
      }
      if (sb.expandable && app.theme === "ios" && sb.view && $navbarEl.length && sb.$pageEl) {
        sb.$pageEl.off("page:beforeout", onPageBeforeOut);
        sb.$pageEl.off("page:beforein", onPageBeforeIn);
      }
      sb.$inputEl.off("focus", onInputFocus);
      sb.$inputEl.off("blur", onInputBlur);
      sb.$inputEl.off(sb.params.inputEvents, onInputChange);
      sb.$inputEl.off("input:clear", onInputClear);
    };
    sb.useModules();
    sb.init();
    return sb;
  }
  clear(e) {
    const sb = this;
    if (!sb.query && e && dom7_default(e.target).hasClass("searchbar-clear")) {
      sb.disable();
      return sb;
    }
    const previousQuery = sb.value;
    sb.$inputEl.val("").trigger("change").focus();
    sb.$el.trigger("searchbar:clear", previousQuery);
    sb.emit("local::clear searchbarClear", sb, previousQuery);
    return sb;
  }
  setDisableButtonMargin() {
    const sb = this;
    if (sb.expandable)
      return;
    const app = sb.app;
    sb.$disableButtonEl.transition(0).show();
    sb.$disableButtonEl.css(`margin-${app.rtl ? "left" : "right"}`, `${-sb.disableButtonEl.offsetWidth}px`);
    sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
    sb.$disableButtonEl.transition("");
    sb.disableButtonHasMargin = true;
  }
  enable(setFocus) {
    const sb = this;
    if (sb.enabled)
      return sb;
    const app = sb.app;
    const document = getDocument();
    const device = getDevice();
    sb.enabled = true;
    function enable3() {
      if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch) && !sb.$el.hasClass("searchbar-enabled") && !sb.query) {
        sb.backdropShow();
      }
      sb.$el.addClass("searchbar-enabled");
      if (!sb.$disableButtonEl || sb.$disableButtonEl && sb.$disableButtonEl.length === 0) {
        sb.$el.addClass("searchbar-enabled-no-disable-button");
      }
      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== "md") {
        if (!sb.disableButtonHasMargin) {
          sb.setDisableButtonMargin();
        }
        sb.$disableButtonEl.css(`margin-${app.rtl ? "left" : "right"}`, "0px");
      }
      if (sb.expandable) {
        const $navbarEl = sb.$el.parents(".navbar");
        if ($navbarEl.hasClass("navbar-large") && sb.$pageEl) {
          const $pageContentEl = sb.$pageEl.find(".page-content");
          const $titleLargeEl = $navbarEl.find(".title-large");
          $pageContentEl.addClass("with-searchbar-expandable-enabled");
          if ($navbarEl.hasClass("navbar-large") && $navbarEl.hasClass("navbar-large-collapsed") && $titleLargeEl.length && $pageContentEl.length) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop -= $titleLargeEl[0].offsetHeight;
            setTimeout(() => {
              $pageContentEl.transition("");
            }, 200);
          }
        }
        if (app.theme === "md" && $navbarEl.length) {
          $navbarEl.addClass("with-searchbar-expandable-enabled");
        } else {
          $navbarEl.addClass("with-searchbar-expandable-enabled");
          if ($navbarEl.hasClass("navbar-large")) {
            $navbarEl.addClass("navbar-large-collapsed");
          }
        }
      }
      if (sb.$hideOnEnableEl)
        sb.$hideOnEnableEl.addClass("hidden-by-searchbar");
      sb.$el.trigger("searchbar:enable");
      sb.emit("local::enable searchbarEnable", sb);
    }
    let needsFocus = false;
    if (setFocus === true) {
      if (document.activeElement !== sb.inputEl) {
        needsFocus = true;
      }
    }
    const isIos = device.ios && app.theme === "ios";
    if (isIos) {
      if (sb.expandable) {
        if (needsFocus)
          sb.$inputEl.focus();
        enable3();
      } else {
        if (needsFocus)
          sb.$inputEl.focus();
        if (setFocus && (setFocus.type === "focus" || setFocus === true)) {
          nextTick(() => {
            enable3();
          }, 400);
        } else {
          enable3();
        }
      }
    } else {
      if (needsFocus)
        sb.$inputEl.focus();
      if (app.theme === "md" && sb.expandable) {
        sb.$el.parents(".page, .view, .navbar-inner, .navbar").scrollLeft(app.rtl ? 100 : 0);
      }
      enable3();
    }
    return sb;
  }
  disable() {
    const sb = this;
    if (!sb.enabled)
      return sb;
    const app = sb.app;
    sb.$inputEl.val("").trigger("change");
    sb.$el.removeClass("searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button");
    if (sb.expandable) {
      const $navbarEl = sb.$el.parents(".navbar");
      const $pageContentEl = sb.$pageEl && sb.$pageEl.find(".page-content");
      if ($navbarEl.hasClass("navbar-large") && $pageContentEl.length) {
        const $titleLargeEl = $navbarEl.find(".title-large");
        sb.$el.transitionEnd(() => {
          $pageContentEl.removeClass("with-searchbar-expandable-closing");
        });
        if ($navbarEl.hasClass("navbar-large") && $navbarEl.hasClass("navbar-large-collapsed") && $titleLargeEl.length) {
          const scrollTop = $pageContentEl[0].scrollTop;
          const titleLargeHeight = $titleLargeEl[0].offsetHeight;
          if (scrollTop > titleLargeHeight) {
            $pageContentEl.transition(0);
            $pageContentEl[0].scrollTop = scrollTop + titleLargeHeight;
            setTimeout(() => {
              $pageContentEl.transition("");
            }, 200);
          }
        }
        $pageContentEl.removeClass("with-searchbar-expandable-enabled").addClass("with-searchbar-expandable-closing");
      }
      if (app.theme === "md" && $navbarEl.length) {
        $navbarEl.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing");
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass("with-searchbar-expandable-closing");
        });
      } else {
        $navbarEl.removeClass("with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition").addClass("with-searchbar-expandable-closing");
        sb.$el.transitionEnd(() => {
          $navbarEl.removeClass("with-searchbar-expandable-closing");
        });
        if (sb.$pageEl) {
          sb.$pageEl.find(".page-content").trigger("scroll");
        }
      }
    }
    if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== "md") {
      sb.$disableButtonEl.css(`margin-${app.rtl ? "left" : "right"}`, `${-sb.disableButtonEl.offsetWidth}px`);
    }
    if (sb.$backdropEl && (sb.$searchContainer && sb.$searchContainer.length || sb.params.customSearch)) {
      sb.backdropHide();
    }
    sb.enabled = false;
    sb.$inputEl.blur();
    if (sb.$hideOnEnableEl)
      sb.$hideOnEnableEl.removeClass("hidden-by-searchbar");
    sb.$el.trigger("searchbar:disable");
    sb.emit("local::disable searchbarDisable", sb);
    return sb;
  }
  toggle() {
    const sb = this;
    if (sb.enabled)
      sb.disable();
    else
      sb.enable(true);
    return sb;
  }
  backdropShow() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.addClass("searchbar-backdrop-in");
    }
    return sb;
  }
  backdropHide() {
    const sb = this;
    if (sb.$backdropEl) {
      sb.$backdropEl.removeClass("searchbar-backdrop-in");
    }
    return sb;
  }
  search(query, internal) {
    const sb = this;
    sb.previousQuery = sb.query || "";
    if (query === sb.previousQuery)
      return sb;
    if (!internal) {
      if (!sb.enabled) {
        sb.enable();
      }
      sb.$inputEl.val(query);
      sb.$inputEl.trigger("input");
    }
    sb.query = query;
    sb.value = query;
    const {
      $searchContainer,
      $el,
      $foundEl,
      $notFoundEl,
      $hideOnSearchEl,
      isVirtualList
    } = sb;
    if (query.length > 0 && $hideOnSearchEl) {
      $hideOnSearchEl.addClass("hidden-by-searchbar");
    } else if ($hideOnSearchEl) {
      $hideOnSearchEl.removeClass("hidden-by-searchbar");
    }
    if ($searchContainer && $searchContainer.length && $el.hasClass("searchbar-enabled") || sb.params.customSearch && $el.hasClass("searchbar-enabled")) {
      if (query.length === 0) {
        sb.backdropShow();
      } else {
        sb.backdropHide();
      }
    }
    if (sb.params.customSearch) {
      $el.trigger("searchbar:search", {
        query,
        previousQuery: sb.previousQuery
      });
      sb.emit("local::search searchbarSearch", sb, query, sb.previousQuery);
      return sb;
    }
    let foundItems = [];
    let vlQuery;
    if (isVirtualList) {
      sb.virtualList = $searchContainer[0].f7VirtualList;
      if (query.trim() === "") {
        sb.virtualList.resetFilter();
        if ($notFoundEl)
          $notFoundEl.hide();
        if ($foundEl)
          $foundEl.show();
        $el.trigger("searchbar:search", {
          query,
          previousQuery: sb.previousQuery
        });
        sb.emit("local::search searchbarSearch", sb, query, sb.previousQuery);
        return sb;
      }
      vlQuery = sb.params.removeDiacritics ? remove_diacritics_default(query) : query;
      if (sb.virtualList.params.searchAll) {
        foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
      } else if (sb.virtualList.params.searchByItem) {
        for (let i = 0; i < sb.virtualList.items.length; i += 1) {
          if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.items[i], i)) {
            foundItems.push(i);
          }
        }
      }
    } else {
      let values;
      if (sb.params.removeDiacritics)
        values = remove_diacritics_default(query.trim().toLowerCase()).split(" ");
      else {
        values = query.trim().toLowerCase().split(" ");
      }
      $searchContainer.find(sb.params.searchItem).removeClass("hidden-by-searchbar").each((itemEl) => {
        const $itemEl = dom7_default(itemEl);
        let compareWithText = [];
        let $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
        if (sb.params.searchIn === sb.params.searchItem) {
          $searchIn = $itemEl;
        }
        $searchIn.each((searchInEl) => {
          let itemText = dom7_default(searchInEl).text().trim().toLowerCase();
          if (sb.params.removeDiacritics)
            itemText = remove_diacritics_default(itemText);
          compareWithText.push(itemText);
        });
        compareWithText = compareWithText.join(" ");
        let wordsMatch = 0;
        for (let i = 0; i < values.length; i += 1) {
          if (compareWithText.indexOf(values[i]) >= 0)
            wordsMatch += 1;
        }
        if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
          $itemEl.addClass("hidden-by-searchbar");
        } else {
          foundItems.push($itemEl[0]);
        }
      });
      if (sb.params.hideDividers) {
        $searchContainer.find(sb.params.searchGroupTitle).each((titleEl) => {
          const $titleEl = dom7_default(titleEl);
          const $nextElements = $titleEl.nextAll(sb.params.searchItem);
          let hide = true;
          for (let i = 0; i < $nextElements.length; i += 1) {
            const $nextEl = $nextElements.eq(i);
            if ($nextEl.is(sb.params.searchGroupTitle))
              break;
            if (!$nextEl.hasClass("hidden-by-searchbar")) {
              hide = false;
            }
          }
          const ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
          if (hide && !ignore)
            $titleEl.addClass("hidden-by-searchbar");
          else
            $titleEl.removeClass("hidden-by-searchbar");
        });
      }
      if (sb.params.hideGroups) {
        $searchContainer.find(sb.params.searchGroup).each((groupEl) => {
          const $groupEl = dom7_default(groupEl);
          const ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
          const notHidden = $groupEl.find(sb.params.searchItem).filter((el) => {
            return !dom7_default(el).hasClass("hidden-by-searchbar");
          });
          if (notHidden.length === 0 && !ignore) {
            $groupEl.addClass("hidden-by-searchbar");
          } else {
            $groupEl.removeClass("hidden-by-searchbar");
          }
        });
      }
    }
    if (foundItems.length === 0) {
      if ($notFoundEl)
        $notFoundEl.show();
      if ($foundEl)
        $foundEl.hide();
    } else {
      if ($notFoundEl)
        $notFoundEl.hide();
      if ($foundEl)
        $foundEl.show();
    }
    if (isVirtualList && sb.virtualList) {
      sb.virtualList.filterItems(foundItems);
    }
    $el.trigger("searchbar:search", {
      query,
      previousQuery: sb.previousQuery,
      foundItems
    });
    sb.emit("local::search searchbarSearch", sb, query, sb.previousQuery, foundItems);
    return sb;
  }
  init() {
    const sb = this;
    if (sb.expandable && sb.$el)
      sb.$el.addClass("searchbar-expandable");
    if (sb.inline && sb.$el)
      sb.$el.addClass("searchbar-inline");
    sb.attachEvents();
  }
  destroy() {
    const sb = this;
    sb.emit("local::beforeDestroy searchbarBeforeDestroy", sb);
    sb.$el.trigger("searchbar:beforedestroy");
    sb.detachEvents();
    if (sb.$el[0]) {
      sb.$el[0].f7Searchbar = null;
      delete sb.$el[0].f7Searchbar;
    }
    deleteProps(sb);
  }
};
var searchbar_class_default = Searchbar;

// node_modules/framework7/components/searchbar/searchbar.js
var searchbar_default = {
  name: "searchbar",
  static: {
    Searchbar: searchbar_class_default
  },
  create() {
    const app = this;
    app.searchbar = ConstructorMethods({
      defaultSelector: ".searchbar",
      constructor: searchbar_class_default,
      app,
      domProp: "f7Searchbar",
      addMethods: "clear enable disable toggle search".split(" ")
    });
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".searchbar-init").each((searchbarEl) => {
        const $searchbarEl = dom7_default(searchbarEl);
        app.searchbar.create(extend($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".searchbar-init").each((searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".searchbar-init").each((searchbarEl) => {
        const $searchbarEl = dom7_default(searchbarEl);
        app.searchbar.create(extend($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".searchbar-init").each((searchbarEl) => {
          const $searchbarEl = dom7_default(searchbarEl);
          app.searchbar.create(extend($searchbarEl.dataset(), {
            el: searchbarEl
          }));
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".searchbar-init").each((searchbarEl) => {
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".searchbar-init").each((searchbarEl) => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
      }
    }
  },
  clicks: {
    ".searchbar-clear": function clear($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.clear();
    },
    ".searchbar-enable": function enable2($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.enable(true);
    },
    ".searchbar-disable": function disable2($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.disable();
    },
    ".searchbar-toggle": function toggle2($clickedEl, data) {
      if (data === void 0) {
        data = {};
      }
      const app = this;
      const sb = app.searchbar.get(data.searchbar);
      if (sb)
        sb.toggle();
    }
  },
  vnode: {
    "searchbar-init": {
      insert(vnode) {
        const app = this;
        const searchbarEl = vnode.elm;
        const $searchbarEl = dom7_default(searchbarEl);
        app.searchbar.create(extend($searchbarEl.dataset(), {
          el: searchbarEl
        }));
      },
      destroy(vnode) {
        const searchbarEl = vnode.elm;
        if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
          searchbarEl.f7Searchbar.destroy();
        }
      }
    }
  }
};

// node_modules/framework7/components/messages/messages-class.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var Messages = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const m = this;
    const defaults = {
      autoLayout: true,
      messages: [],
      newMessagesFirst: false,
      scrollMessages: true,
      scrollMessagesOnEdge: true,
      firstMessageRule: void 0,
      lastMessageRule: void 0,
      tailMessageRule: void 0,
      sameNameMessageRule: void 0,
      sameHeaderMessageRule: void 0,
      sameFooterMessageRule: void 0,
      sameAvatarMessageRule: void 0,
      customClassMessageRule: void 0,
      renderMessage: void 0
    };
    m.useModulesParams(defaults);
    m.params = extend(defaults, params);
    const $el = dom7_default(params.el).eq(0);
    if ($el.length === 0)
      return m;
    if ($el[0].f7Messages)
      return $el[0].f7Messages;
    $el[0].f7Messages = m;
    const $pageContentEl = $el.closest(".page-content").eq(0);
    extend(m, {
      messages: m.params.messages,
      $el,
      el: $el[0],
      $pageContentEl,
      pageContentEl: $pageContentEl[0]
    });
    m.useModules();
    m.init();
    return m;
  }
  getMessageData(messageEl) {
    const $messageEl = dom7_default(messageEl);
    const data = {
      name: $messageEl.find(".message-name").html(),
      header: $messageEl.find(".message-header").html(),
      textHeader: $messageEl.find(".message-text-header").html(),
      textFooter: $messageEl.find(".message-text-footer").html(),
      footer: $messageEl.find(".message-footer").html(),
      isTitle: $messageEl.hasClass("messages-title"),
      type: $messageEl.hasClass("message-sent") ? "sent" : "received",
      text: $messageEl.find(".message-text").html(),
      image: $messageEl.find(".message-image").html(),
      imageSrc: $messageEl.find(".message-image img").attr("src"),
      typing: $messageEl.hasClass("message-typing")
    };
    if (data.isTitle) {
      data.text = $messageEl.html();
    }
    if (data.text && data.textHeader) {
      data.text = data.text.replace(`<div class="message-text-header">${data.textHeader}</div>`, "");
    }
    if (data.text && data.textFooter) {
      data.text = data.text.replace(`<div class="message-text-footer">${data.textFooter}</div>`, "");
    }
    let avatar = $messageEl.find(".message-avatar").css("background-image");
    if (avatar === "none" || avatar === "")
      avatar = void 0;
    if (avatar && typeof avatar === "string") {
      avatar = avatar.replace("url(", "").replace(")", "").replace(/"/g, "").replace(/'/g, "");
    } else {
      avatar = void 0;
    }
    data.avatar = avatar;
    return data;
  }
  getMessagesData() {
    const m = this;
    const data = [];
    m.$el.find(".message, .messages-title").each((messageEl) => {
      data.push(m.getMessageData(messageEl));
    });
    return data;
  }
  renderMessage(messageToRender) {
    const m = this;
    const message = extend({
      type: "sent",
      attrs: {}
    }, messageToRender);
    if (m.params.renderMessage) {
      return m.params.renderMessage.call(m, message);
    }
    if (message.isTitle) {
      return `<div class="messages-title">${message.text}</div>`;
    }
    return jsx_default2("div", _extends({
      class: `message message-${message.type} ${message.isTyping ? "message-typing" : ""} ${message.cssClass || ""}`
    }, message.attrs), message.avatar && jsx_default2("div", {
      class: "message-avatar",
      style: `background-image:url(${message.avatar})`
    }), jsx_default2("div", {
      class: "message-content"
    }, message.name && jsx_default2("div", {
      class: "message-name"
    }, message.name), message.header && jsx_default2("div", {
      class: "message-header"
    }, message.header), jsx_default2("div", {
      class: "message-bubble"
    }, message.textHeader && jsx_default2("div", {
      class: "message-text-header"
    }, message.textHeader), message.image && jsx_default2("div", {
      class: "message-image"
    }, message.image), message.imageSrc && !message.image && jsx_default2("div", {
      class: "message-image"
    }, jsx_default2("img", {
      src: message.imageSrc
    })), (message.text || message.isTyping) && jsx_default2("div", {
      class: "message-text"
    }, message.text || "", message.isTyping && jsx_default2("div", {
      class: "message-typing-indicator"
    }, jsx_default2("div", null), jsx_default2("div", null), jsx_default2("div", null))), message.textFooter && jsx_default2("div", {
      class: "message-text-footer"
    }, message.textFooter)), message.footer && jsx_default2("div", {
      class: "message-footer"
    }, message.footer)));
  }
  renderMessages(messagesToRender, method) {
    if (messagesToRender === void 0) {
      messagesToRender = this.messages;
    }
    if (method === void 0) {
      method = this.params.newMessagesFirst ? "prepend" : "append";
    }
    const m = this;
    const html2 = messagesToRender.map((message) => m.renderMessage(message)).join("");
    m.$el[method](html2);
  }
  isFirstMessage() {
    const m = this;
    if (m.params.firstMessageRule)
      return m.params.firstMessageRule(...arguments);
    return false;
  }
  isLastMessage() {
    const m = this;
    if (m.params.lastMessageRule)
      return m.params.lastMessageRule(...arguments);
    return false;
  }
  isTailMessage() {
    const m = this;
    if (m.params.tailMessageRule)
      return m.params.tailMessageRule(...arguments);
    return false;
  }
  isSameNameMessage() {
    const m = this;
    if (m.params.sameNameMessageRule)
      return m.params.sameNameMessageRule(...arguments);
    return false;
  }
  isSameHeaderMessage() {
    const m = this;
    if (m.params.sameHeaderMessageRule)
      return m.params.sameHeaderMessageRule(...arguments);
    return false;
  }
  isSameFooterMessage() {
    const m = this;
    if (m.params.sameFooterMessageRule)
      return m.params.sameFooterMessageRule(...arguments);
    return false;
  }
  isSameAvatarMessage() {
    const m = this;
    if (m.params.sameAvatarMessageRule)
      return m.params.sameAvatarMessageRule(...arguments);
    return false;
  }
  isCustomClassMessage() {
    const m = this;
    if (m.params.customClassMessageRule)
      return m.params.customClassMessageRule(...arguments);
    return void 0;
  }
  layout() {
    const m = this;
    m.$el.find(".message, .messages-title").each((messageEl, index2) => {
      const $messageEl = dom7_default(messageEl);
      if (!m.messages) {
        m.messages = m.getMessagesData();
      }
      const classes = [];
      const message = m.messages[index2];
      const previousMessage = m.messages[index2 - 1];
      const nextMessage = m.messages[index2 + 1];
      if (m.isFirstMessage(message, previousMessage, nextMessage)) {
        classes.push("message-first");
      }
      if (m.isLastMessage(message, previousMessage, nextMessage)) {
        classes.push("message-last");
      }
      if (m.isTailMessage(message, previousMessage, nextMessage)) {
        classes.push("message-tail");
      }
      if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-name");
      }
      if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-header");
      }
      if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-footer");
      }
      if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
        classes.push("message-same-avatar");
      }
      let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
      if (customMessageClasses && customMessageClasses.length) {
        if (typeof customMessageClasses === "string") {
          customMessageClasses = customMessageClasses.split(" ");
        }
        customMessageClasses.forEach((customClass) => {
          classes.push(customClass);
        });
      }
      $messageEl.removeClass("message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar");
      classes.forEach((className) => {
        $messageEl.addClass(className);
      });
    });
  }
  clear() {
    const m = this;
    m.messages = [];
    m.$el.html("");
  }
  removeMessage(messageToRemove, layout) {
    if (layout === void 0) {
      layout = true;
    }
    const m = this;
    let index2;
    let $el;
    if (typeof messageToRemove === "number") {
      index2 = messageToRemove;
      $el = m.$el.find(".message, .messages-title").eq(index2);
    } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
      index2 = m.messages.indexOf(messageToRemove);
      $el = m.$el.children().eq(index2);
    } else {
      $el = dom7_default(messageToRemove);
      index2 = $el.index();
    }
    if ($el.length === 0) {
      return m;
    }
    $el.remove();
    m.messages.splice(index2, 1);
    if (m.params.autoLayout && layout)
      m.layout();
    return m;
  }
  removeMessages(messagesToRemove, layout) {
    if (layout === void 0) {
      layout = true;
    }
    const m = this;
    if (Array.isArray(messagesToRemove)) {
      const messagesToRemoveEls = [];
      messagesToRemove.forEach((messageToRemoveIndex) => {
        messagesToRemoveEls.push(m.$el.find(".message, .messages-title").eq(messageToRemoveIndex));
      });
      messagesToRemoveEls.forEach((messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    } else {
      dom7_default(messagesToRemove).each((messageToRemove) => {
        m.removeMessage(messageToRemove, false);
      });
    }
    if (m.params.autoLayout && layout)
      m.layout();
    return m;
  }
  addMessage() {
    const m = this;
    let messageToAdd;
    let animate;
    let method;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[1] === "boolean") {
      [messageToAdd, animate, method] = args;
    } else {
      [messageToAdd, method, animate] = args;
    }
    if (typeof animate === "undefined") {
      animate = true;
    }
    if (typeof method === "undefined") {
      method = m.params.newMessagesFirst ? "prepend" : "append";
    }
    return m.addMessages([messageToAdd], animate, method);
  }
  setScrollData() {
    const m = this;
    const scrollHeightBefore = m.pageContentEl.scrollHeight;
    const heightBefore = m.pageContentEl.offsetHeight;
    const scrollBefore = m.pageContentEl.scrollTop;
    m.scrollData = {
      scrollHeightBefore,
      heightBefore,
      scrollBefore
    };
    return {
      scrollHeightBefore,
      heightBefore,
      scrollBefore
    };
  }
  addMessages() {
    const m = this;
    let messagesToAdd;
    let animate;
    let method;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[1] === "boolean") {
      [messagesToAdd, animate, method] = args;
    } else {
      [messagesToAdd, method, animate] = args;
    }
    if (typeof animate === "undefined") {
      animate = true;
    }
    if (typeof method === "undefined") {
      method = m.params.newMessagesFirst ? "prepend" : "append";
    }
    const {
      scrollHeightBefore,
      scrollBefore
    } = m.setScrollData();
    let messagesHTML = "";
    const typingMessage = m.messages.filter((el) => el.isTyping)[0];
    messagesToAdd.forEach((messageToAdd) => {
      if (typingMessage) {
        if (method === "append") {
          m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
        } else {
          m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
        }
      } else {
        m.messages[method === "append" ? "push" : "unshift"](messageToAdd);
      }
      messagesHTML += m.renderMessage(messageToAdd);
    });
    const $messagesEls = dom7_default(messagesHTML);
    if (animate) {
      if (method === "append" && !m.params.newMessagesFirst) {
        $messagesEls.addClass("message-appear-from-bottom");
      }
      if (method === "prepend" && m.params.newMessagesFirst) {
        $messagesEls.addClass("message-appear-from-top");
      }
    }
    if (typingMessage) {
      if (method === "append") {
        $messagesEls.insertBefore(m.$el.find(".message-typing"));
      } else {
        $messagesEls.insertAfter(m.$el.find(".message-typing"));
      }
    } else {
      m.$el[method]($messagesEls);
    }
    if (m.params.autoLayout)
      m.layout();
    if (method === "prepend" && !typingMessage) {
      m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
    }
    if (m.params.scrollMessages && (method === "append" && !m.params.newMessagesFirst || method === "prepend" && m.params.newMessagesFirst && !typingMessage)) {
      m.scrollWithEdgeCheck(animate);
    }
    return m;
  }
  showTyping(message) {
    if (message === void 0) {
      message = {};
    }
    const m = this;
    const typingMessage = m.messages.filter((el) => el.isTyping)[0];
    if (typingMessage) {
      m.removeMessage(m.messages.indexOf(typingMessage));
    }
    m.addMessage(extend({
      type: "received",
      isTyping: true
    }, message));
    return m;
  }
  hideTyping() {
    const m = this;
    let typingMessageIndex;
    let typingFound;
    m.messages.forEach((message, index2) => {
      if (message.isTyping)
        typingMessageIndex = index2;
    });
    if (typeof typingMessageIndex !== "undefined") {
      if (m.$el.find(".message").eq(typingMessageIndex).hasClass("message-typing")) {
        typingFound = true;
        m.removeMessage(typingMessageIndex);
      }
    }
    if (!typingFound) {
      const $typingMessageEl = m.$el.find(".message-typing");
      if ($typingMessageEl.length) {
        m.removeMessage($typingMessageEl);
      }
    }
    return m;
  }
  scrollWithEdgeCheck(animate) {
    const m = this;
    const {
      scrollBefore,
      scrollHeightBefore,
      heightBefore
    } = m.scrollData;
    if (m.params.scrollMessagesOnEdge) {
      let onEdge = false;
      if (m.params.newMessagesFirst && scrollBefore === 0) {
        onEdge = true;
      }
      if (!m.params.newMessagesFirst && scrollBefore - (scrollHeightBefore - heightBefore) >= -10) {
        onEdge = true;
      }
      if (onEdge)
        m.scroll(animate ? void 0 : 0);
    } else {
      m.scroll(animate ? void 0 : 0);
    }
  }
  scroll(duration, scrollTop) {
    if (duration === void 0) {
      duration = 300;
    }
    const m = this;
    const currentScroll = m.pageContentEl.scrollTop;
    let newScrollTop;
    if (typeof scrollTop !== "undefined")
      newScrollTop = scrollTop;
    else {
      newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
      if (newScrollTop === currentScroll)
        return m;
    }
    m.$pageContentEl.scrollTop(newScrollTop, duration);
    return m;
  }
  init() {
    const m = this;
    if (!m.messages || m.messages.length === 0) {
      m.messages = m.getMessagesData();
    }
    if (m.params.messages && m.params.messages.length) {
      m.renderMessages();
    }
    if (m.params.autoLayout)
      m.layout();
    if (m.params.scrollMessages)
      m.scroll(0);
  }
  destroy() {
    const m = this;
    m.emit("local::beforeDestroy messagesBeforeDestroy", m);
    m.$el.trigger("messages:beforedestroy");
    if (m.$el[0]) {
      m.$el[0].f7Messages = null;
      delete m.$el[0].f7Messages;
    }
    deleteProps(m);
  }
};
var messages_class_default = Messages;

// node_modules/framework7/components/messages/messages.js
var messages_default = {
  name: "messages",
  static: {
    Messages: messages_class_default
  },
  create() {
    const app = this;
    app.messages = ConstructorMethods({
      defaultSelector: ".messages",
      constructor: messages_class_default,
      app,
      domProp: "f7Messages",
      addMethods: "renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages".split(" ")
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messages-init").each((messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messages-init").each((messagesEl) => {
        app.messages.create({
          el: messagesEl
        });
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".messages-init").each((messagesEl) => {
        app.messages.destroy(messagesEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".messages-init").each((messagesEl) => {
        app.messages.create({
          el: messagesEl
        });
      });
    }
  },
  vnode: {
    "messages-init": {
      insert(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.create({
          el: messagesEl
        });
      },
      destroy(vnode) {
        const app = this;
        const messagesEl = vnode.elm;
        app.messages.destroy(messagesEl);
      }
    }
  }
};

// node_modules/framework7/components/messagebar/messagebar-class.js
var Messagebar = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const messagebar = this;
    const defaults = {
      top: false,
      topOffset: 0,
      bottomOffset: 0,
      attachments: [],
      renderAttachments: void 0,
      renderAttachment: void 0,
      maxHeight: null,
      resizePage: true
    };
    messagebar.useModulesParams(defaults);
    messagebar.params = extend(defaults, params);
    const $el = dom7_default(messagebar.params.el);
    if ($el.length === 0)
      return messagebar;
    if ($el[0].f7Messagebar)
      return $el[0].f7Messagebar;
    $el[0].f7Messagebar = messagebar;
    const $pageEl = $el.parents(".page").eq(0);
    const $pageContentEl = $pageEl.find(".page-content").eq(0);
    const $areaEl = $el.find(".messagebar-area");
    let $textareaEl;
    if (messagebar.params.textareaEl) {
      $textareaEl = dom7_default(messagebar.params.textareaEl);
    } else {
      $textareaEl = $el.find("textarea");
    }
    const $attachmentsEl = $el.find(".messagebar-attachments");
    const $sheetEl = $el.find(".messagebar-sheet");
    if (messagebar.params.top) {
      $el.addClass("messagebar-top");
    }
    extend(messagebar, {
      $el,
      el: $el[0],
      $areaEl,
      areaEl: $areaEl[0],
      $textareaEl,
      textareaEl: $textareaEl[0],
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0],
      attachmentsVisible: $attachmentsEl.hasClass("messagebar-attachments-visible"),
      $sheetEl,
      sheetEl: $sheetEl[0],
      sheetVisible: $sheetEl.hasClass("messagebar-sheet-visible"),
      $pageEl,
      pageEl: $pageEl[0],
      $pageContentEl,
      pageContentEl: $pageContentEl,
      top: $el.hasClass("messagebar-top") || messagebar.params.top,
      attachments: []
    });
    function onAppResize() {
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
    }
    function onSubmit(e) {
      e.preventDefault();
    }
    function onAttachmentClick(e) {
      const index2 = dom7_default(this).index();
      if (dom7_default(e.target).closest(".messagebar-attachment-delete").length) {
        dom7_default(this).trigger("messagebar:attachmentdelete", index2);
        messagebar.emit("local::attachmentDelete messagebarAttachmentDelete", messagebar, this, index2);
      } else {
        dom7_default(this).trigger("messagebar:attachmentclick", index2);
        messagebar.emit("local::attachmentClick messagebarAttachmentClick", messagebar, this, index2);
      }
    }
    function onTextareaChange() {
      messagebar.checkEmptyState();
      messagebar.$el.trigger("messagebar:change");
      messagebar.emit("local::change messagebarChange", messagebar);
    }
    function onTextareaFocus() {
      messagebar.sheetHide();
      messagebar.$el.addClass("messagebar-focused");
      messagebar.$el.trigger("messagebar:focus");
      messagebar.emit("local::focus messagebarFocus", messagebar);
    }
    function onTextareaBlur() {
      messagebar.$el.removeClass("messagebar-focused");
      messagebar.$el.trigger("messagebar:blur");
      messagebar.emit("local::blur messagebarBlur", messagebar);
    }
    messagebar.attachEvents = function attachEvents2() {
      $el.on("textarea:resize", onAppResize);
      $el.on("submit", onSubmit);
      $el.on("click", ".messagebar-attachment", onAttachmentClick);
      $textareaEl.on("change input", onTextareaChange);
      $textareaEl.on("focus", onTextareaFocus);
      $textareaEl.on("blur", onTextareaBlur);
      app.on("resize", onAppResize);
    };
    messagebar.detachEvents = function detachEvents2() {
      $el.off("textarea:resize", onAppResize);
      $el.off("submit", onSubmit);
      $el.off("click", ".messagebar-attachment", onAttachmentClick);
      $textareaEl.off("change input", onTextareaChange);
      $textareaEl.off("focus", onTextareaFocus);
      $textareaEl.off("blur", onTextareaBlur);
      app.off("resize", onAppResize);
    };
    messagebar.useModules();
    messagebar.init();
    return messagebar;
  }
  focus() {
    const messagebar = this;
    messagebar.$textareaEl.focus();
    return messagebar;
  }
  blur() {
    const messagebar = this;
    messagebar.$textareaEl.blur();
    return messagebar;
  }
  clear() {
    const messagebar = this;
    messagebar.$textareaEl.val("").trigger("change");
    return messagebar;
  }
  getValue() {
    const messagebar = this;
    return messagebar.$textareaEl.val().trim();
  }
  setValue(value) {
    const messagebar = this;
    messagebar.$textareaEl.val(value).trigger("change");
    return messagebar;
  }
  setPlaceholder(placeholder) {
    const messagebar = this;
    messagebar.$textareaEl.attr("placeholder", placeholder);
    return messagebar;
  }
  resizePage() {
    const messagebar = this;
    const {
      params,
      $el,
      top,
      $pageEl,
      $pageContentEl,
      $areaEl,
      $textareaEl,
      $sheetEl,
      $attachmentsEl
    } = messagebar;
    const elHeight = $el[0].offsetHeight;
    let maxHeight = params.maxHeight;
    if (top) {
    } else {
      const currentPaddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
      const requiredPaddingBottom = elHeight + params.bottomOffset;
      if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
        const currentPaddingTop = parseInt($pageContentEl.css("padding-top"), 10);
        const pageScrollHeight = $pageContentEl[0].scrollHeight;
        const pageOffsetHeight = $pageContentEl[0].offsetHeight;
        const pageScrollTop = $pageContentEl[0].scrollTop;
        const scrollOnBottom = pageScrollTop === pageScrollHeight - pageOffsetHeight;
        if (!maxHeight) {
          maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css("margin-top"), 10) - parseInt($areaEl.css("margin-bottom"), 10);
        }
        $textareaEl.css("max-height", `${maxHeight}px`);
        $pageContentEl.css("padding-bottom", `${requiredPaddingBottom}px`);
        if (scrollOnBottom) {
          $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
        }
        $el.trigger("messagebar:resizepage");
        messagebar.emit("local::resizePage messagebarResizePage", messagebar);
      }
    }
  }
  checkEmptyState() {
    const messagebar = this;
    const {
      $el,
      $textareaEl
    } = messagebar;
    const value = $textareaEl.val().trim();
    if (value && value.length) {
      $el.addClass("messagebar-with-value");
    } else {
      $el.removeClass("messagebar-with-value");
    }
  }
  attachmentsCreate(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    const $attachmentsEl = dom7_default(`<div class="messagebar-attachments">${innerHTML}</div>`);
    $attachmentsEl.insertBefore(messagebar.$textareaEl);
    extend(messagebar, {
      $attachmentsEl,
      attachmentsEl: $attachmentsEl[0]
    });
    return messagebar;
  }
  attachmentsShow(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    messagebar.$attachmentsEl = messagebar.$el.find(".messagebar-attachments");
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(innerHTML);
    }
    messagebar.$el.addClass("messagebar-attachments-visible");
    messagebar.attachmentsVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  attachmentsHide() {
    const messagebar = this;
    messagebar.$el.removeClass("messagebar-attachments-visible");
    messagebar.attachmentsVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  attachmentsToggle() {
    const messagebar = this;
    if (messagebar.attachmentsVisible) {
      messagebar.attachmentsHide();
    } else {
      messagebar.attachmentsShow();
    }
    return messagebar;
  }
  renderAttachment(attachment) {
    const messagebar = this;
    if (messagebar.params.renderAttachment) {
      return messagebar.params.renderAttachment.call(messagebar, attachment);
    }
    return `
      <div class="messagebar-attachment">
        <img src="${attachment}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `;
  }
  renderAttachments() {
    const messagebar = this;
    let html2;
    if (messagebar.params.renderAttachments) {
      html2 = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
    } else {
      html2 = `${messagebar.attachments.map((attachment) => messagebar.renderAttachment(attachment)).join("")}`;
    }
    if (messagebar.$attachmentsEl.length === 0) {
      messagebar.attachmentsCreate(html2);
    } else {
      messagebar.$attachmentsEl.html(html2);
    }
  }
  sheetCreate(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    const $sheetEl = dom7_default(`<div class="messagebar-sheet">${innerHTML}</div>`);
    messagebar.$el.append($sheetEl);
    extend(messagebar, {
      $sheetEl,
      sheetEl: $sheetEl[0]
    });
    return messagebar;
  }
  sheetShow(innerHTML) {
    if (innerHTML === void 0) {
      innerHTML = "";
    }
    const messagebar = this;
    messagebar.$sheetEl = messagebar.$el.find(".messagebar-sheet");
    if (messagebar.$sheetEl.length === 0) {
      messagebar.sheetCreate(innerHTML);
    }
    messagebar.$el.addClass("messagebar-sheet-visible");
    messagebar.sheetVisible = true;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  sheetHide() {
    const messagebar = this;
    messagebar.$el.removeClass("messagebar-sheet-visible");
    messagebar.sheetVisible = false;
    if (messagebar.params.resizePage) {
      messagebar.resizePage();
    }
    return messagebar;
  }
  sheetToggle() {
    const messagebar = this;
    if (messagebar.sheetVisible) {
      messagebar.sheetHide();
    } else {
      messagebar.sheetShow();
    }
    return messagebar;
  }
  init() {
    const messagebar = this;
    messagebar.attachEvents();
    messagebar.checkEmptyState();
    return messagebar;
  }
  destroy() {
    const messagebar = this;
    messagebar.emit("local::beforeDestroy messagebarBeforeDestroy", messagebar);
    messagebar.$el.trigger("messagebar:beforedestroy");
    messagebar.detachEvents();
    if (messagebar.$el[0]) {
      messagebar.$el[0].f7Messagebar = null;
      delete messagebar.$el[0].f7Messagebar;
    }
    deleteProps(messagebar);
  }
};
var messagebar_class_default = Messagebar;

// node_modules/framework7/components/messagebar/messagebar.js
var messagebar_default = {
  name: "messagebar",
  static: {
    Messagebar: messagebar_class_default
  },
  create() {
    const app = this;
    app.messagebar = ConstructorMethods({
      defaultSelector: ".messagebar",
      constructor: messagebar_class_default,
      app,
      domProp: "f7Messagebar",
      addMethods: "clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle".split(" ")
    });
  },
  on: {
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.create(extend({
          el: messagebarEl
        }, dom7_default(messagebarEl).dataset()));
      });
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.destroy(messagebarEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".messagebar-init").each((messagebarEl) => {
        app.messagebar.create(extend({
          el: messagebarEl
        }, dom7_default(messagebarEl).dataset()));
      });
    }
  },
  vnode: {
    "messagebar-init": {
      insert(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.create(extend({
          el: messagebarEl
        }, dom7_default(messagebarEl).dataset()));
      },
      destroy(vnode) {
        const app = this;
        const messagebarEl = vnode.elm;
        app.messagebar.destroy(messagebarEl);
      }
    }
  }
};

// node_modules/swiper/shared/dom.js
var Methods = {
  addClass,
  removeClass,
  hasClass,
  toggleClass,
  attr,
  removeAttr,
  transform,
  transition,
  on,
  off,
  trigger,
  transitionEnd,
  outerWidth,
  outerHeight,
  styles,
  offset,
  css,
  each,
  html,
  text,
  is,
  index,
  eq,
  append,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest,
  find,
  children,
  filter,
  remove
};
Object.keys(Methods).forEach((methodName) => {
  Object.defineProperty($.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
var dom_default = $;

// node_modules/swiper/shared/utils.js
function deleteProps2(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function nextTick2(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now2() {
  return Date.now();
}
function getComputedStyle2(el) {
  const window2 = getWindow();
  let style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate2(el, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle2(el, null);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a) => a.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function isNode(node) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend2() {
  const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend2(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend2(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window2 = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current, target) => {
    return dir === "next" && current >= target || dir === "prev" && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = "";
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}

// node_modules/swiper/shared/get-support.js
var support;
function calcSupport() {
  const window2 = getWindow();
  const document = getDocument();
  return {
    smoothScroll: document.documentElement && "scrollBehavior" in document.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document instanceof window2.DocumentTouch),
    passiveListener: function checkPassiveListener() {
      let supportsPassive = false;
      try {
        const opts = Object.defineProperty({}, "passive", {
          get() {
            supportsPassive = true;
          }
        });
        window2.addEventListener("testPassiveListener", null, opts);
      } catch (e) {
      }
      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return "ongesturestart" in window2;
    }()
  };
}
function getSupport2() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

// node_modules/swiper/shared/get-device.js
var deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support2 = getSupport2();
  const window2 = getWindow();
  const platform = window2.navigator.platform;
  const ua = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === "Win32";
  let macos = platform === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice2(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

// node_modules/swiper/shared/get-browser.js
var browser;
function calcBrowser() {
  const window2 = getWindow();
  function isSafari() {
    const ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  return {
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

// node_modules/swiper/core/modules/resize/resize.js
function Resize(_ref) {
  let {
    swiper,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach((_ref2) => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el)
            return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized)
      return;
    emit("orientationchange");
  };
  on2("init", () => {
    if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on2("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}

// node_modules/swiper/core/modules/observer/observer.js
function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const observers = [];
  const window2 = getWindow();
  const attach = function(target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: typeof options.childList === "undefined" ? true : options.childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer)
      return;
    if (swiper.params.observeParents) {
      const containerParents = swiper.$el.parents();
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    });
    attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on2("init", init);
  on2("destroy", destroy);
}

// node_modules/swiper/core/events-emitter.js
var events_emitter_default = {
  on(events2, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed)
      return self;
    if (typeof handler !== "function")
      return self;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event2) => {
      if (!self.eventsListeners[event2])
        self.eventsListeners[event2] = [];
      self.eventsListeners[event2][method](handler);
    });
    return self;
  },
  once(events2, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed)
      return self;
    if (typeof handler !== "function")
      return self;
    function onceHandler() {
      self.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed)
      return self;
    if (typeof handler !== "function")
      return self;
    const method = priority ? "unshift" : "push";
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed)
      return self;
    if (!self.eventsAnyListeners)
      return self;
    const index2 = self.eventsAnyListeners.indexOf(handler);
    if (index2 >= 0) {
      self.eventsAnyListeners.splice(index2, 1);
    }
    return self;
  },
  off(events2, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed)
      return self;
    if (!self.eventsListeners)
      return self;
    events2.split(" ").forEach((event2) => {
      if (typeof handler === "undefined") {
        self.eventsListeners[event2] = [];
      } else if (self.eventsListeners[event2]) {
        self.eventsListeners[event2].forEach((eventHandler, index2) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event2].splice(index2, 1);
          }
        });
      }
    });
    return self;
  },
  emit() {
    const self = this;
    if (!self.eventsListeners || self.destroyed)
      return self;
    if (!self.eventsListeners)
      return self;
    let events2;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event2) => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context, [event2, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event2]) {
        self.eventsListeners[event2].forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

// node_modules/swiper/core/update/updateSize.js
function updateSize() {
  const swiper = this;
  let width;
  let height;
  const $el = swiper.$el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }
  width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
  height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
  if (Number.isNaN(width))
    width = 0;
  if (Number.isNaN(height))
    height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

// node_modules/swiper/core/update/updateSlides.js
function updateSlides() {
  const swiper = this;
  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property];
  }
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    $wrapperEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index2 = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  }
  swiper.virtualSize = -spaceBetween;
  if (rtl)
    slides.css({
      marginLeft: "",
      marginBottom: "",
      marginTop: ""
    });
  else
    slides.css({
      marginRight: "",
      marginBottom: "",
      marginTop: ""
    });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    const slide = slides.eq(i);
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
    }
    if (slide.css("display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide[0]);
      const currentTransform = slide[0].style.transform;
      const currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        const width = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide[0];
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index2 % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index2 += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    $wrapperEl.css({
      width: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }
  if (params.setWrapperSize) {
    $wrapperEl.css({
      [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
    });
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (params.spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter((_, slideIndex) => {
      if (!params.cssMode)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).css({
      [key]: `${spaceBetween}px`
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap < 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map((v) => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow)
      swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded)
        swiper.$el.addClass(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.$el.removeClass(backFaceHiddenClass);
    }
  }
}

// node_modules/swiper/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = (index2) => {
    if (isVirtual) {
      return swiper.slides.filter((el) => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index2)[0];
    }
    return swiper.slides.eq(index2)[0];
  };
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || dom_default([])).each((slide) => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index2 = swiper.activeIndex + i;
        if (index2 > swiper.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index2));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== "undefined") {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper.$wrapperEl.css("height", `${newHeight}px`);
}

// node_modules/swiper/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

// node_modules/swiper/core/update/updateSlidesProgress.js
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl)
    offsetCenter = translate;
  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
      slides.eq(i).addClass(params.slideVisibleClass);
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
  swiper.visibleSlides = dom_default(swiper.visibleSlides);
}

// node_modules/swiper/core/update/updateProgress.js
function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === "undefined") {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  Object.assign(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}

// node_modules/swiper/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    $wrapperEl,
    activeIndex,
    realIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
  let activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
  } else {
    activeSlide = slides.eq(activeIndex);
  }
  activeSlide.addClass(params.slideActiveClass);
  if (params.loop) {
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
    }
  }
  let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}

// node_modules/swiper/core/update/updateActiveIndex.js
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    slidesGrid,
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  if (typeof activeIndex === "undefined") {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    return;
  }
  const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
  Object.assign(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (previousRealIndex !== realIndex) {
    swiper.emit("realIndexChange");
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit("slideChange");
  }
}

// node_modules/swiper/core/update/updateClickedSlide.js
function updateClickedSlide(e) {
  const swiper = this;
  const params = swiper.params;
  const slide = dom_default(e).closest(`.${params.slideClass}`)[0];
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

// node_modules/swiper/core/update/index.js
var update_default = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

// node_modules/swiper/core/translate/getTranslate.js
function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? "x" : "y";
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    $wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = getTranslate2($wrapperEl[0], axis);
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

// node_modules/swiper/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    $wrapperEl,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}

// node_modules/swiper/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}

// node_modules/swiper/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

// node_modules/swiper/core/translate/translateTo.js
function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper.minTranslate();
  const maxTranslate2 = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd3(e) {
          if (!swiper || swiper.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

// node_modules/swiper/core/translate/index.js
var translate_default = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

// node_modules/swiper/core/transition/setTransition.js
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }
  swiper.emit("setTransition", duration, byController);
}

// node_modules/swiper/core/transition/transitionEmit.js
function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === "next") {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

// node_modules/swiper/core/transition/transitionStart.js
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "Start"
  });
}

// node_modules/swiper/core/transition/transitionEnd.js
function transitionEnd2(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode)
    return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: "End"
  });
}

// node_modules/swiper/core/transition/index.js
var transition_default = {
  setTransition,
  transitionStart,
  transitionEnd: transitionEnd2
};

// node_modules/swiper/core/slide/slideTo.js
function slideTo(index2, speed, runCallbacks, internal, initial) {
  if (index2 === void 0) {
    index2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index2 !== "number" && typeof index2 !== "string") {
    throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index2}] given.`);
  }
  if (typeof index2 === "string") {
    const indexAsNumber = parseInt(index2, 10);
    const isValidNumber = isFinite(indexAsNumber);
    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
    }
    index2 = indexAsNumber;
  }
  const swiper = this;
  let slideIndex = index2;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  const translate = -snapGrid[snapIndex];
  swiper.updateProgress(translate);
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex)
        return false;
    }
  }
  let direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = "none";
        swiper._immediateVirtual = true;
      }
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = "";
          swiper._swiperImmediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t,
        behavior: "smooth"
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit("beforeTransitionStart", speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd3(e) {
        if (!swiper || swiper.destroyed)
          return;
        if (e.target !== this)
          return;
        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}

// node_modules/swiper/core/slide/slideToLoop.js
function slideToLoop(index2, speed, runCallbacks, internal) {
  if (index2 === void 0) {
    index2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index2 === "string") {
    const indexAsNumber = parseInt(index2, 10);
    const isValidNumber = isFinite(indexAsNumber);
    if (!isValidNumber) {
      throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index2}] given.`);
    }
    index2 = indexAsNumber;
  }
  const swiper = this;
  let newIndex = index2;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideNext.js
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    animating,
    enabled,
    params
  } = swiper;
  if (!enabled)
    return swiper;
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slidePrev.js
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    animating,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return swiper;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideReset.js
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideToClosest.js
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  let index2 = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
  const snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index2 += swiper.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index2 -= swiper.params.slidesPerGroup;
    }
  }
  index2 = Math.max(index2, 0);
  index2 = Math.min(index2, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index2, speed, runCallbacks, internal);
}

// node_modules/swiper/core/slide/slideToClickedSlide.js
function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    $wrapperEl
  } = swiper;
  const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt(dom_default(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
        nextTick2(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
      nextTick2(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

// node_modules/swiper/core/slide/index.js
var slide_default = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

// node_modules/swiper/core/loop/loopCreate.js
function loopCreate() {
  const swiper = this;
  const document = getDocument();
  const {
    params,
    $wrapperEl
  } = swiper;
  const $selector = $wrapperEl.children().length > 0 ? dom_default($wrapperEl.children()[0].parentNode) : $wrapperEl;
  $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
  let slides = $selector.children(`.${params.slideClass}`);
  if (params.loopFillGroupWithBlank) {
    const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (let i = 0; i < blankSlidesNum; i += 1) {
        const blankNode = dom_default(document.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
        $selector.append(blankNode);
      }
      slides = $selector.children(`.${params.slideClass}`);
    }
  }
  if (params.slidesPerView === "auto" && !params.loopedSlides)
    params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }
  const prependSlides = [];
  const appendSlides = [];
  slides.each((el, index2) => {
    const slide = dom_default(el);
    if (index2 < swiper.loopedSlides) {
      appendSlides.push(el);
    }
    if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }
    slide.attr("data-swiper-slide-index", index2);
  });
  for (let i = 0; i < appendSlides.length; i += 1) {
    $selector.append(dom_default(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
    $selector.prepend(dom_default(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

// node_modules/swiper/core/loop/loopFix.js
function loopFix() {
  const swiper = this;
  swiper.emit("beforeLoopFix");
  const {
    activeIndex,
    slides,
    loopedSlides,
    allowSlidePrev,
    allowSlideNext,
    snapGrid,
    rtlTranslate: rtl
  } = swiper;
  let newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  const snapTranslate = -snapGrid[activeIndex];
  const diff = snapTranslate - swiper.getTranslate();
  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    const slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit("loopFix");
}

// node_modules/swiper/core/loop/loopDestroy.js
function loopDestroy() {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    slides
  } = swiper;
  $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
  slides.removeAttr("data-swiper-slide-index");
}

// node_modules/swiper/core/loop/index.js
var loop_default = {
  loopCreate,
  loopFix,
  loopDestroy
};

// node_modules/swiper/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  const swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
  el.style.cursor = "move";
  el.style.cursor = moving ? "grabbing" : "grab";
}

// node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
}

// node_modules/swiper/core/grab-cursor/index.js
var grab_cursor_default = {
  setGrabCursor,
  unsetGrabCursor
};

// node_modules/swiper/core/events/onTouchStart.js
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow())
      return null;
    if (el.assignedSlot)
      el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function onTouchStart(event2) {
  const swiper = this;
  const document = getDocument();
  const window2 = getWindow();
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled)
    return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  let $targetEl = dom_default(e.target);
  if (params.touchEventsTarget === "wrapper") {
    if (!$targetEl.closest(swiper.wrapperEl).length)
      return;
  }
  data.isTouchEvent = e.type === "touchstart";
  if (!data.isTouchEvent && "which" in e && e.which === 3)
    return;
  if (!data.isTouchEvent && "button" in e && e.button > 0)
    return;
  if (data.isTouched && data.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  if (swipingClassHasValue && e.target && e.target.shadowRoot && event2.path && event2.path[0]) {
    $targetEl = dom_default(event2.path[0]);
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0])
      return;
  }
  touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event2.preventDefault();
    } else {
      return;
    }
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now2();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0)
    data.allowThresholdMove = false;
  if (e.type !== "touchstart") {
    let preventDefault = true;
    if ($targetEl.is(data.focusableElements)) {
      preventDefault = false;
      if ($targetEl[0].nodeName === "SELECT") {
        data.isTouched = false;
      }
    }
    if (document.activeElement && dom_default(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }
  if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit("touchStart", e);
}

// node_modules/swiper/core/events/onTouchMove.js
function onTouchMove(event2) {
  const document = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled)
    return;
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit("touchMoveOpposite", e);
    }
    return;
  }
  if (data.isTouchEvent && e.type !== "touchmove")
    return;
  const targetTouch = e.type === "touchmove" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  const pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
  const pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!dom_default(e.target).is(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now2();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && dom_default(e.target).is(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit("touchMove", e);
  }
  if (e.targetTouches && e.targetTouches.length > 1)
    return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold)
    return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit("touchMoveOpposite", e);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  if (!data.isMoved) {
    if (params.loop && !params.cssMode) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e);
  }
  swiper.emit("sliderMove", e);
  data.isMoved = true;
  let diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl)
    diff = -diff;
  swiper.swipeDirection = diff > 0 ? "prev" : "next";
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  swiper.updateProgress(data.currentTranslate);
  swiper.setTranslate(data.currentTranslate);
}

// node_modules/swiper/core/events/onTouchEnd.js
function onTouchEnd(event2) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled)
    return;
  let e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit("touchEnd", e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  const touchEndTime = now2();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
    swiper.emit("tap click", e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e);
    }
  }
  data.lastClickTime = now2();
  nextTick2(() => {
    if (!swiper.destroyed)
      swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (swiper.params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment2] !== "undefined") {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment2]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment2] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

// node_modules/swiper/core/events/onResize.js
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

// node_modules/swiper/core/events/onClick.js
function onClick(e) {
  const swiper = this;
  if (!swiper.enabled)
    return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks)
      e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

// node_modules/swiper/core/events/onScroll.js
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled)
    return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === 0)
    swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}

// node_modules/swiper/core/events/index.js
var dummyEventAttached = false;
function dummyEventListener() {
}
var events = (swiper, method) => {
  const document = getDocument();
  const {
    params,
    touchEvents,
    el,
    wrapperEl,
    device,
    support: support2
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  if (!support2.touch) {
    el[domMethod](touchEvents.start, swiper.onTouchStart, false);
    document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
    document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
  } else {
    const passiveListener = touchEvents.start === "touchstart" && support2.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
    el[domMethod](touchEvents.move, swiper.onTouchMove, support2.passiveListener ? {
      passive: false,
      capture
    } : capture);
    el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
    if (touchEvents.cancel) {
      el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
    }
  }
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper[swiperMethod]("observerUpdate", onResize, true);
  }
};
function attachEvents() {
  const swiper = this;
  const document = getDocument();
  const {
    params,
    support: support2
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  if (support2.touch && !dummyEventAttached) {
    document.addEventListener("touchstart", dummyEventListener);
    dummyEventAttached = true;
  }
  events(swiper, "on");
}
function detachEvents() {
  const swiper = this;
  events(swiper, "off");
}
var events_default = {
  attachEvents,
  detachEvents
};

// node_modules/swiper/core/breakpoints/setBreakpoint.js
var isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    activeIndex,
    initialized,
    loopedSlides = 0,
    params,
    $el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0)
    return;
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    $el.addClass(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      $el.addClass(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  ["navigation", "pagination", "scrollbar"].forEach((prop) => {
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend2(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit("_beforeBreakpoint", breakpointParams);
  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate();
    swiper.updateSlides();
    swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
  }
  swiper.emit("breakpoint", breakpointParams);
}

// node_modules/swiper/core/breakpoints/getBreakpoint.js
function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = "window";
  }
  if (!breakpoints || base === "container" && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === "window") {
      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}

// node_modules/swiper/core/breakpoints/index.js
var breakpoints_default = {
  setBreakpoint,
  getBreakpoint
};

// node_modules/swiper/core/classes/addClasses.js
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    $el,
    device,
    support: support2
  } = swiper;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "pointer-events": !support2.touch
  }, {
    "free-mode": swiper.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  $el.addClass([...classNames].join(" "));
  swiper.emitContainerClasses();
}

// node_modules/swiper/core/classes/removeClasses.js
function removeClasses() {
  const swiper = this;
  const {
    $el,
    classNames
  } = swiper;
  $el.removeClass(classNames.join(" "));
  swiper.emitContainerClasses();
}

// node_modules/swiper/core/classes/index.js
var classes_default = {
  addClasses,
  removeClasses
};

// node_modules/swiper/core/images/loadImage.js
function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  const window2 = getWindow();
  let image;
  function onReady() {
    if (callback)
      callback();
  }
  const isPicture = dom_default(imageEl).parent("picture")[0];
  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window2.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    onReady();
  }
}

// node_modules/swiper/core/images/preloadImages.js
function preloadImages() {
  const swiper = this;
  swiper.imagesToLoad = swiper.$el.find("img");
  function onReady() {
    if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed)
      return;
    if (swiper.imagesLoaded !== void 0)
      swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady)
        swiper.update();
      swiper.emit("imagesReady");
    }
  }
  for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
    const imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
  }
}

// node_modules/swiper/core/images/index.js
var images_default = {
  loadImage,
  preloadImages
};

// node_modules/swiper/core/check-overflow/index.js
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  }
}
var check_overflow_default = {
  checkOverflow
};

// node_modules/swiper/core/defaults.js
var defaults_default = {
  init: true,
  direction: "horizontal",
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  width: null,
  height: null,
  preventInteractionOnTransition: false,
  userAgent: null,
  url: null,
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  autoHeight: false,
  setWrapperSize: false,
  virtualTranslate: false,
  effect: "slide",
  breakpoints: void 0,
  breakpointsBase: "window",
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  slidesOffsetAfter: 0,
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  watchOverflow: true,
  roundLengths: false,
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  uniqueNavElements: true,
  resistance: true,
  resistanceRatio: 0.85,
  watchSlidesProgress: false,
  grabCursor: false,
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  preloadImages: true,
  updateOnImagesReady: true,
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  rewind: false,
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  containerModifierClass: "swiper-",
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-invisible-blank",
  slideActiveClass: "swiper-slide-active",
  slideDuplicateActiveClass: "swiper-slide-duplicate-active",
  slideVisibleClass: "swiper-slide-visible",
  slideDuplicateClass: "swiper-slide-duplicate",
  slideNextClass: "swiper-slide-next",
  slideDuplicateNextClass: "swiper-slide-duplicate-next",
  slidePrevClass: "swiper-slide-prev",
  slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
  wrapperClass: "swiper-wrapper",
  runCallbacksOnInit: true,
  _emitClasses: false
};

// node_modules/swiper/core/moduleExtendParams.js
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend2(allModulesParams, obj);
      return;
    }
    if (["navigation", "pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend2(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false
      };
    extend2(allModulesParams, obj);
  };
}

// node_modules/swiper/core/core.js
var prototypes = {
  eventsEmitter: events_emitter_default,
  update: update_default,
  translate: translate_default,
  transition: transition_default,
  slide: slide_default,
  loop: loop_default,
  grabCursor: grab_cursor_default,
  events: events_default,
  breakpoints: breakpoints_default,
  checkOverflow: check_overflow_default,
  classes: classes_default,
  images: images_default
};
var extendedDefaults = {};
var Swiper = class {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params)
      params = {};
    params = extend2({}, params);
    if (el && !params.el)
      params.el = el;
    if (params.el && dom_default(params.el).length > 1) {
      const swipers = [];
      dom_default(params.el).each((containerEl) => {
        const newParams = extend2({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport2();
    swiper.device = getDevice2({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach((mod) => {
      mod({
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });
    const swiperParams = extend2({}, defaults_default, allModulesParams);
    swiper.params = extend2({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend2({}, swiper.params);
    swiper.passedParams = extend2({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach((eventName) => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    swiper.$ = dom_default;
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      classNames: [],
      slides: dom_default(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical() {
        return swiper.params.direction === "vertical";
      },
      activeIndex: 0,
      realIndex: 0,
      isBeginning: true,
      isEnd: false,
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      touchEvents: function touchEvents() {
        const touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
        const desktop = ["pointerdown", "pointermove", "pointerup"];
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        focusableElements: swiper.params.focusableElements,
        lastClickTime: now2(),
        clickTimeout: void 0,
        velocities: [],
        allowMomentumBounce: void 0,
        isTouchEvent: void 0,
        startMoving: void 0
      },
      allowClick: true,
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  enable() {
    const swiper = this;
    if (swiper.enabled)
      return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit("enable");
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled)
      return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const cls = swiper.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed)
      return "";
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    const updates = [];
    swiper.slides.each((slideEl) => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit("_slideClass", slideEl, classNames);
    });
    swiper.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = "current";
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex].swiperSlideSize;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view === "current") {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    const {
      snapGrid,
      params
    } = swiper;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
      setTranslate2();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate)
      swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr")
      return;
    swiper.rtl = direction === "rtl";
    swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
    if (swiper.rtl) {
      swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = "rtl";
    } else {
      swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = "ltr";
    }
    swiper.update();
  }
  mount(el) {
    const swiper = this;
    if (swiper.mounted)
      return true;
    const $el = dom_default(el || swiper.params.el);
    el = $el[0];
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = dom_default(el.shadowRoot.querySelector(getWrapperSelector()));
        res.children = (options) => $el.children(options);
        return res;
      }
      if (!$el.children) {
        return dom_default($el).children(getWrapperSelector());
      }
      return $el.children(getWrapperSelector());
    };
    let $wrapperEl = getWrapper();
    if ($wrapperEl.length === 0 && swiper.params.createElements) {
      const document = getDocument();
      const wrapper = document.createElement("div");
      $wrapperEl = dom_default(wrapper);
      wrapper.className = swiper.params.wrapperClass;
      $el.append(wrapper);
      $el.children(`.${swiper.params.slideClass}`).each((slideEl) => {
        $wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
      wrongRTL: $wrapperEl.css("display") === "-webkit-box"
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized)
      return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false)
      return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    if (swiper.params.loop) {
      swiper.loopCreate();
    }
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }
    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }
    swiper.attachEvents();
    swiper.initialized = true;
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      $el,
      $wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr("style");
      $wrapperEl.removeAttr("style");
      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach((eventName) => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps2(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend2(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults_default;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__)
      Swiper.prototype.__modules__ = [];
    const modules2 = Swiper.prototype.__modules__;
    if (typeof mod === "function" && modules2.indexOf(mod) < 0) {
      modules2.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach((m) => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
};
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);
var core_default = Swiper;

// node_modules/swiper/modules/virtual/virtual.js
function Virtual(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  swiper.virtual = {
    cache: {},
    from: void 0,
    to: void 0,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  function renderSlide(slide, index2) {
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index2]) {
      return swiper.virtual.cache[index2];
    }
    const $slideEl = params.renderSlide ? dom_default(params.renderSlide.call(swiper, slide, index2)) : dom_default(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index2}">${slide}</div>`);
    if (!$slideEl.attr("data-swiper-slide-index"))
      $slideEl.attr("data-swiper-slide-index", index2);
    if (params.cache)
      swiper.virtual.cache[index2] = $slideEl;
    return $slideEl;
  }
  function update(force) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides
    } = swiper.params;
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;
    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }
    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate)
      offsetProp = "right";
    else
      offsetProp = swiper.isHorizontal() ? "left" : "top";
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = slidesPerGroup + addSlidesBefore;
    }
    const from = Math.max((activeIndex || 0) - slidesBefore, 0);
    const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
    const offset2 = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    Object.assign(swiper.virtual, {
      from,
      to,
      offset: offset2,
      slidesGrid: swiper.slidesGrid
    });
    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      if (swiper.lazy && swiper.params.lazy.enabled) {
        swiper.lazy.load();
      }
      emit("virtualUpdate");
    }
    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset2 !== previousOffset) {
        swiper.slides.css(offsetProp, `${offset2}px`);
      }
      swiper.updateProgress();
      emit("virtualUpdate");
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset: offset2,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()
      });
      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit("virtualUpdate");
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    if (force) {
      swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      if (i >= from && i <= to) {
        if (typeof previousTo === "undefined" || force) {
          appendIndexes.push(i);
        } else {
          if (i > previousTo)
            appendIndexes.push(i);
          if (i < previousFrom)
            prependIndexes.push(i);
        }
      }
    }
    appendIndexes.forEach((index2) => {
      swiper.$wrapperEl.append(renderSlide(slides[index2], index2));
    });
    prependIndexes.sort((a, b) => b - a).forEach((index2) => {
      swiper.$wrapperEl.prepend(renderSlide(slides[index2], index2));
    });
    swiper.$wrapperEl.children(".swiper-slide").css(offsetProp, `${offset2}px`);
    onRendered();
  }
  function appendSlide2(slides) {
    if (typeof slides === "object" && "length" in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    update(true);
  }
  function prependSlide2(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i])
          swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach((cachedIndex) => {
        const $cachedEl = cache[cachedIndex];
        const cachedElIndex = $cachedEl.attr("data-swiper-slide-index");
        if (cachedElIndex) {
          $cachedEl.attr("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }
  function removeSlide2(slidesIndexes) {
    if (typeof slidesIndexes === "undefined" || slidesIndexes === null)
      return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex)
          activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex)
        activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update(true);
    swiper.slideTo(activeIndex, 0);
  }
  function removeAllSlides2() {
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    update(true);
    swiper.slideTo(0, 0);
  }
  on2("beforeInit", () => {
    if (!swiper.params.virtual.enabled)
      return;
    swiper.virtual.slides = swiper.params.virtual.slides;
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
    if (!swiper.params.initialSlide) {
      update();
    }
  });
  on2("setTranslate", () => {
    if (!swiper.params.virtual.enabled)
      return;
    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on2("init update resize", () => {
    if (!swiper.params.virtual.enabled)
      return;
    if (swiper.params.cssMode) {
      setCSSProperty(swiper.wrapperEl, "--swiper-virtual-size", `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide: appendSlide2,
    prependSlide: prependSlide2,
    removeSlide: removeSlide2,
    removeAllSlides: removeAllSlides2,
    update
  });
}

// node_modules/swiper/modules/keyboard/keyboard.js
function Keyboard(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const document = getDocument();
  const window2 = getWindow();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle(event2) {
    if (!swiper.enabled)
      return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event2;
    if (e.originalEvent)
      e = e.originalEvent;
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return void 0;
    }
    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === "input" || document.activeElement.nodeName.toLowerCase() === "textarea")) {
      return void 0;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
        return void 0;
      }
      const $el = swiper.$el;
      const swiperWidth = $el[0].clientWidth;
      const swiperHeight = $el[0].clientHeight;
      const windowWidth = window2.innerWidth;
      const windowHeight = window2.innerHeight;
      const swiperOffset = swiper.$el.offset();
      if (rtl)
        swiperOffset.left -= swiper.$el[0].scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0)
            continue;
          inView = true;
        }
      }
      if (!inView)
        return void 0;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl)
        swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl)
        swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      }
      if (isPageDown || isArrowDown)
        swiper.slideNext();
      if (isPageUp || isArrowUp)
        swiper.slidePrev();
    }
    emit("keyPress", kc);
    return void 0;
  }
  function enable3() {
    if (swiper.keyboard.enabled)
      return;
    dom_default(document).on("keydown", handle);
    swiper.keyboard.enabled = true;
  }
  function disable3() {
    if (!swiper.keyboard.enabled)
      return;
    dom_default(document).off("keydown", handle);
    swiper.keyboard.enabled = false;
  }
  on2("init", () => {
    if (swiper.params.keyboard.enabled) {
      enable3();
    }
  });
  on2("destroy", () => {
    if (swiper.keyboard.enabled) {
      disable3();
    }
  });
  Object.assign(swiper.keyboard, {
    enable: enable3,
    disable: disable3
  });
}

// node_modules/swiper/modules/mousewheel/mousewheel.js
function Mousewheel(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: "container",
      thresholdDelta: null,
      thresholdTime: null
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = now2();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0;
    let pX = 0;
    let pY = 0;
    if ("detail" in e) {
      sY = e.detail;
    }
    if ("wheelDelta" in e) {
      sY = -e.wheelDelta / 120;
    }
    if ("wheelDeltaY" in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in e) {
      sX = -e.wheelDeltaX / 120;
    }
    if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ("deltaY" in e) {
      pY = e.deltaY;
    }
    if ("deltaX" in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled)
      return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled)
      return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && now2() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      return false;
    }
    if (newEvent.delta >= 6 && now2() - lastScrollTime < 60) {
      return true;
    }
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit("scroll", newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit("scroll", newEvent.raw);
    }
    lastScrollTime = new window2.Date().getTime();
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      return true;
    }
    return false;
  }
  function handle(event2) {
    let e = event2;
    let disableParentSwiper = true;
    if (!swiper.enabled)
      return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      target = dom_default(swiper.params.mousewheel.eventsTarget);
    }
    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges)
      return true;
    if (e.originalEvent)
      e = e.originalEvent;
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
          delta = -data.pixelX * rtlFactor;
        else
          return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
        delta = -data.pixelY;
      else
        return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0)
      return true;
    if (params.invert)
      delta = -delta;
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate())
      positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate())
      positions = swiper.maxTranslate();
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested)
      e.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      const newEvent = {
        time: now2(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event2
      };
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift();
      }
      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
      recentWheelEvents.push(newEvent);
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      const newEvent = {
        time: now2(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = void 0;
        if (swiper.params.loop) {
          swiper.loopFix();
        }
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate())
          position = swiper.minTranslate();
        if (position <= swiper.maxTranslate())
          position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.freeMode.sticky) {
          clearTimeout(timeout);
          timeout = void 0;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift();
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = nextTick2(() => {
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 0);
          }
          if (!timeout) {
            timeout = nextTick2(() => {
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 500);
          }
        }
        if (!ignoreWheelEvents)
          emit("scroll", e);
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)
          swiper.autoplay.stop();
        if (position === swiper.minTranslate() || position === swiper.maxTranslate())
          return true;
      }
    }
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
    return false;
  }
  function events2(method) {
    let target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      target = dom_default(swiper.params.mousewheel.eventsTarget);
    }
    target[method]("mouseenter", handleMouseEnter);
    target[method]("mouseleave", handleMouseLeave);
    target[method]("wheel", handle);
  }
  function enable3() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener("wheel", handle);
      return true;
    }
    if (swiper.mousewheel.enabled)
      return false;
    events2("on");
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable3() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper.mousewheel.enabled)
      return false;
    events2("off");
    swiper.mousewheel.enabled = false;
    return true;
  }
  on2("init", () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable3();
    }
    if (swiper.params.mousewheel.enabled)
      enable3();
  });
  on2("destroy", () => {
    if (swiper.params.cssMode) {
      enable3();
    }
    if (swiper.mousewheel.enabled)
      disable3();
  });
  Object.assign(swiper.mousewheel, {
    enable: enable3,
    disable: disable3
  });
}

// node_modules/swiper/shared/create-element-if-not-defined.js
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  const document = getDocument();
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach((key) => {
      if (!params[key] && params.auto === true) {
        let element = swiper.$el.children(`.${checkProps[key]}`)[0];
        if (!element) {
          element = document.createElement("div");
          element.className = checkProps[key];
          swiper.$el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}

// node_modules/swiper/modules/navigation/navigation.js
function Navigation(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: "swiper-button-disabled",
      hiddenClass: "swiper-button-hidden",
      lockClass: "swiper-button-lock",
      navigationDisabledClass: "swiper-navigation-disabled"
    }
  });
  swiper.navigation = {
    nextEl: null,
    $nextEl: null,
    prevEl: null,
    $prevEl: null
  };
  function getEl(el) {
    let $el;
    if (el) {
      $el = dom_default(el);
      if (swiper.params.uniqueNavElements && typeof el === "string" && $el.length > 1 && swiper.$el.find(el).length === 1) {
        $el = swiper.$el.find(el);
      }
    }
    return $el;
  }
  function toggleEl($el, disabled) {
    const params = swiper.params.navigation;
    if ($el && $el.length > 0) {
      $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
      if ($el[0] && $el[0].tagName === "BUTTON")
        $el[0].disabled = disabled;
      if (swiper.params.watchOverflow && swiper.enabled) {
        $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
      }
    }
  }
  function update() {
    if (swiper.params.loop)
      return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind)
      return;
    swiper.slidePrev();
    emit("navigationPrev");
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
      return;
    swiper.slideNext();
    emit("navigationNext");
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: "swiper-button-next",
      prevEl: "swiper-button-prev"
    });
    if (!(params.nextEl || params.prevEl))
      return;
    const $nextEl = getEl(params.nextEl);
    const $prevEl = getEl(params.prevEl);
    if ($nextEl && $nextEl.length > 0) {
      $nextEl.on("click", onNextClick);
    }
    if ($prevEl && $prevEl.length > 0) {
      $prevEl.on("click", onPrevClick);
    }
    Object.assign(swiper.navigation, {
      $nextEl,
      nextEl: $nextEl && $nextEl[0],
      $prevEl,
      prevEl: $prevEl && $prevEl[0]
    });
    if (!swiper.enabled) {
      if ($nextEl)
        $nextEl.addClass(params.lockClass);
      if ($prevEl)
        $prevEl.addClass(params.lockClass);
    }
  }
  function destroy() {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    if ($nextEl && $nextEl.length) {
      $nextEl.off("click", onNextClick);
      $nextEl.removeClass(swiper.params.navigation.disabledClass);
    }
    if ($prevEl && $prevEl.length) {
      $prevEl.off("click", onPrevClick);
      $prevEl.removeClass(swiper.params.navigation.disabledClass);
    }
  }
  on2("init", () => {
    if (swiper.params.navigation.enabled === false) {
      disable3();
    } else {
      init();
      update();
    }
  });
  on2("toEdge fromEdge lock unlock", () => {
    update();
  });
  on2("destroy", () => {
    destroy();
  });
  on2("enable disable", () => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    if ($nextEl) {
      $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
    }
    if ($prevEl) {
      $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
    }
  });
  on2("click", (_s, e) => {
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    const targetEl = e.target;
    if (swiper.params.navigation.hideOnClick && !dom_default(targetEl).is($prevEl) && !dom_default(targetEl).is($nextEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl)))
        return;
      let isHidden;
      if ($nextEl) {
        isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
      } else if ($prevEl) {
        isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit("navigationShow");
      } else {
        emit("navigationHide");
      }
      if ($nextEl) {
        $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
      if ($prevEl) {
        $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
      }
    }
  });
  const enable3 = () => {
    swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
    init();
    update();
  };
  const disable3 = () => {
    swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable: enable3,
    disable: disable3,
    update,
    init,
    destroy
  });
}

// node_modules/swiper/shared/classes-to-selector.js
function classesToSelector(classes) {
  if (classes === void 0) {
    classes = "";
  }
  return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
}

// node_modules/swiper/modules/pagination/pagination.js
function Pagination(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const pfx = "swiper-pagination";
  extendParams({
    pagination: {
      el: null,
      bulletElement: "span",
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: "bullets",
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: (number) => number,
      formatFractionTotal: (number) => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    $el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;
  }
  function setSideBullets($bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
  }
  function update() {
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let current;
    const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
      if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
        current -= slidesLength - swiper.loopedSlides * 2;
      }
      if (current > total - 1)
        current -= total;
      if (current < 0 && swiper.params.paginationType !== "bullets")
        current = total + current;
    } else if (typeof swiper.snapIndex !== "undefined") {
      current = swiper.snapIndex;
    } else {
      current = swiper.activeIndex || 0;
    }
    if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
        $el.css(swiper.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
        if (params.dynamicMainBullets > 1 && swiper.previousIndex !== void 0) {
          dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`).join(" "));
      if ($el.length > 1) {
        bullets.each((bullet) => {
          const $bullet = dom_default(bullet);
          const bulletIndex = $bullet.index();
          if (bulletIndex === current) {
            $bullet.addClass(params.bulletActiveClass);
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              $bullet.addClass(`${params.bulletActiveClass}-main`);
            }
            if (bulletIndex === firstIndex) {
              setSideBullets($bullet, "prev");
            }
            if (bulletIndex === lastIndex) {
              setSideBullets($bullet, "next");
            }
          }
        });
      } else {
        const $bullet = bullets.eq(current);
        const bulletIndex = $bullet.index();
        $bullet.addClass(params.bulletActiveClass);
        if (params.dynamicBullets) {
          const $firstDisplayedBullet = bullets.eq(firstIndex);
          const $lastDisplayedBullet = bullets.eq(lastIndex);
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
          }
          if (swiper.params.loop) {
            if (bulletIndex >= bullets.length) {
              for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
              }
              bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
            } else {
              setSideBullets($firstDisplayedBullet, "prev");
              setSideBullets($lastDisplayedBullet, "next");
            }
          } else {
            setSideBullets($firstDisplayedBullet, "prev");
            setSideBullets($lastDisplayedBullet, "next");
          }
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? "right" : "left";
        bullets.css(swiper.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
      }
    }
    if (params.type === "fraction") {
      $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
      $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
    }
    if (params.type === "progressbar") {
      let progressbarDirection;
      if (params.progressbarOpposite) {
        progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
      } else {
        progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
      }
      const scale = (current + 1) / total;
      let scaleX = 1;
      let scaleY = 1;
      if (progressbarDirection === "horizontal") {
        scaleX = scale;
      } else {
        scaleY = scale;
      }
      $el.find(classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
    }
    if (params.type === "custom" && params.renderCustom) {
      $el.html(params.renderCustom(swiper, current + 1, total));
      emit("paginationRender", $el[0]);
    } else {
      emit("paginationUpdate", $el[0]);
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
    }
  }
  function render() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const $el = swiper.pagination.$el;
    let paginationHTML = "";
    if (params.type === "bullets") {
      let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
      $el.html(paginationHTML);
      swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
    }
    if (params.type === "fraction") {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type === "progressbar") {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
      $el.html(paginationHTML);
    }
    if (params.type !== "custom") {
      emit("paginationRender", swiper.pagination.$el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: "swiper-pagination"
    });
    const params = swiper.params.pagination;
    if (!params.el)
      return;
    let $el = dom_default(params.el);
    if ($el.length === 0)
      return;
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1) {
      $el = swiper.$el.find(params.el);
      if ($el.length > 1) {
        $el = $el.filter((el) => {
          if (dom_default(el).parents(".swiper")[0] !== swiper.el)
            return false;
          return true;
        });
      }
    }
    if (params.type === "bullets" && params.clickable) {
      $el.addClass(params.clickableClass);
    }
    $el.addClass(params.modifierClass + params.type);
    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    if (params.type === "bullets" && params.dynamicBullets) {
      $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
      dynamicBulletIndex = 0;
      if (params.dynamicMainBullets < 1) {
        params.dynamicMainBullets = 1;
      }
    }
    if (params.type === "progressbar" && params.progressbarOpposite) {
      $el.addClass(params.progressbarOppositeClass);
    }
    if (params.clickable) {
      $el.on("click", classesToSelector(params.bulletClass), function onClick4(e) {
        e.preventDefault();
        let index2 = dom_default(this).index() * swiper.params.slidesPerGroup;
        if (swiper.params.loop)
          index2 += swiper.loopedSlides;
        swiper.slideTo(index2);
      });
    }
    Object.assign(swiper.pagination, {
      $el,
      el: $el[0]
    });
    if (!swiper.enabled) {
      $el.addClass(params.lockClass);
    }
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled())
      return;
    const $el = swiper.pagination.$el;
    $el.removeClass(params.hiddenClass);
    $el.removeClass(params.modifierClass + params.type);
    $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass)
      swiper.pagination.bullets.removeClass(params.bulletActiveClass);
    if (params.clickable) {
      $el.off("click", classesToSelector(params.bulletClass));
    }
  }
  on2("init", () => {
    if (swiper.params.pagination.enabled === false) {
      disable3();
    } else {
      init();
      render();
      update();
    }
  });
  on2("activeIndexChange", () => {
    if (swiper.params.loop) {
      update();
    } else if (typeof swiper.snapIndex === "undefined") {
      update();
    }
  });
  on2("snapIndexChange", () => {
    if (!swiper.params.loop) {
      update();
    }
  });
  on2("slidesLengthChange", () => {
    if (swiper.params.loop) {
      render();
      update();
    }
  });
  on2("snapGridLengthChange", () => {
    if (!swiper.params.loop) {
      render();
      update();
    }
  });
  on2("destroy", () => {
    destroy();
  });
  on2("enable disable", () => {
    const {
      $el
    } = swiper.pagination;
    if ($el) {
      $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
    }
  });
  on2("lock unlock", () => {
    update();
  });
  on2("click", (_s, e) => {
    const targetEl = e.target;
    const {
      $el
    } = swiper.pagination;
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !dom_default(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl))
        return;
      const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit("paginationShow");
      } else {
        emit("paginationHide");
      }
      $el.toggleClass(swiper.params.pagination.hiddenClass);
    }
  });
  const enable3 = () => {
    swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
    if (swiper.pagination.$el) {
      swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
    }
    init();
    render();
    update();
  };
  const disable3 = () => {
    swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);
    if (swiper.pagination.$el) {
      swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable: enable3,
    disable: disable3,
    render,
    update,
    init,
    destroy
  });
}

// node_modules/swiper/modules/scrollbar/scrollbar.js
function Scrollbar(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const document = getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: "auto",
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: "swiper-scrollbar-lock",
      dragClass: "swiper-scrollbar-drag",
      scrollbarDisabledClass: "swiper-scrollbar-disabled",
      horizontalClass: `swiper-scrollbar-horizontal`,
      verticalClass: `swiper-scrollbar-vertical`
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null,
    $el: null,
    $dragEl: null
  };
  function setTranslate2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    const {
      scrollbar,
      rtlTranslate: rtl,
      progress
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
      $dragEl[0].style.width = `${newSize}px`;
    } else {
      $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
      $dragEl[0].style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      $el[0].style.opacity = 1;
      timeout = setTimeout(() => {
        $el[0].style.opacity = 0;
        $el.transition(400);
      }, 1e3);
    }
  }
  function setTransition2(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    swiper.scrollbar.$dragEl.transition(duration);
  }
  function updateSize2() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    const {
      scrollbar
    } = swiper;
    const {
      $dragEl,
      $el
    } = scrollbar;
    $dragEl[0].style.width = "";
    $dragEl[0].style.height = "";
    trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === "auto") {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      $dragEl[0].style.width = `${dragSize}px`;
    } else {
      $dragEl[0].style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      $el[0].style.display = "none";
    } else {
      $el[0].style.display = "";
    }
    if (swiper.params.scrollbar.hide) {
      $el[0].style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.$el[swiper.isLocked ? "addClass" : "removeClass"](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e) {
    if (swiper.isHorizontal()) {
      return e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientX : e.clientX;
    }
    return e.type === "touchstart" || e.type === "touchmove" ? e.targetTouches[0].clientY : e.clientY;
  }
  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      $el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
    e.preventDefault();
    e.stopPropagation();
    $wrapperEl.transition(100);
    $dragEl.transition(100);
    setDragPosition(e);
    clearTimeout(dragTimeout);
    $el.transition(0);
    if (params.hide) {
      $el.css("opacity", 1);
    }
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css("scroll-snap-type", "none");
    }
    emit("scrollbarDragStart", e);
  }
  function onDragMove(e) {
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el,
      $dragEl
    } = scrollbar;
    if (!isTouched)
      return;
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
    setDragPosition(e);
    $wrapperEl.transition(0);
    $el.transition(0);
    $dragEl.transition(0);
    emit("scrollbarDragMove", e);
  }
  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      $wrapperEl
    } = swiper;
    const {
      $el
    } = scrollbar;
    if (!isTouched)
      return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.$wrapperEl.css("scroll-snap-type", "");
      $wrapperEl.transition("");
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = nextTick2(() => {
        $el.css("opacity", 0);
        $el.transition(400);
      }, 1e3);
    }
    emit("scrollbarDragEnd", e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events2(method) {
    const {
      scrollbar,
      touchEventsTouch,
      touchEventsDesktop,
      params,
      support: support2
    } = swiper;
    const $el = scrollbar.$el;
    if (!$el)
      return;
    const target = $el[0];
    const activeListener = support2.passiveListener && params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = support2.passiveListener && params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target)
      return;
    const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
    if (!support2.touch) {
      target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);
      document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);
      document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);
    } else {
      target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);
      target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);
      target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);
    }
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    events2("on");
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el)
      return;
    events2("off");
  }
  function init() {
    const {
      scrollbar,
      $el: $swiperEl
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: "swiper-scrollbar"
    });
    const params = swiper.params.scrollbar;
    if (!params.el)
      return;
    let $el = dom_default(params.el);
    if (swiper.params.uniqueNavElements && typeof params.el === "string" && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
      $el = $swiperEl.find(params.el);
    }
    $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
    if ($dragEl.length === 0) {
      $dragEl = dom_default(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
      $el.append($dragEl);
    }
    Object.assign(scrollbar, {
      $el,
      el: $el[0],
      $dragEl,
      dragEl: $dragEl[0]
    });
    if (params.draggable) {
      enableDraggable();
    }
    if ($el) {
      $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
    }
  }
  function destroy() {
    const params = swiper.params.scrollbar;
    const $el = swiper.scrollbar.$el;
    if ($el) {
      $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    }
    disableDraggable();
  }
  on2("init", () => {
    if (swiper.params.scrollbar.enabled === false) {
      disable3();
    } else {
      init();
      updateSize2();
      setTranslate2();
    }
  });
  on2("update resize observerUpdate lock unlock", () => {
    updateSize2();
  });
  on2("setTranslate", () => {
    setTranslate2();
  });
  on2("setTransition", (_s, duration) => {
    setTransition2(duration);
  });
  on2("enable disable", () => {
    const {
      $el
    } = swiper.scrollbar;
    if ($el) {
      $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.scrollbar.lockClass);
    }
  });
  on2("destroy", () => {
    destroy();
  });
  const enable3 = () => {
    swiper.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
    if (swiper.scrollbar.$el) {
      swiper.scrollbar.$el.removeClass(swiper.params.scrollbar.scrollbarDisabledClass);
    }
    init();
    updateSize2();
    setTranslate2();
  };
  const disable3 = () => {
    swiper.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
    if (swiper.scrollbar.$el) {
      swiper.scrollbar.$el.addClass(swiper.params.scrollbar.scrollbarDisabledClass);
    }
    destroy();
  };
  Object.assign(swiper.scrollbar, {
    enable: enable3,
    disable: disable3,
    updateSize: updateSize2,
    setTranslate: setTranslate2,
    init,
    destroy
  });
}

// node_modules/swiper/modules/parallax/parallax.js
function Parallax(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    parallax: {
      enabled: false
    }
  });
  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const $el = dom_default(el);
    const rtlFactor = rtl ? -1 : 1;
    const p = $el.attr("data-swiper-parallax") || "0";
    let x = $el.attr("data-swiper-parallax-x");
    let y = $el.attr("data-swiper-parallax-y");
    const scale = $el.attr("data-swiper-parallax-scale");
    const opacity = $el.attr("data-swiper-parallax-opacity");
    if (x || y) {
      x = x || "0";
      y = y || "0";
    } else if (swiper.isHorizontal()) {
      x = p;
      y = "0";
    } else {
      y = p;
      x = "0";
    }
    if (x.indexOf("%") >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if (y.indexOf("%") >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }
    if (typeof opacity !== "undefined" && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      $el[0].style.opacity = currentOpacity;
    }
    if (typeof scale === "undefined" || scale === null) {
      $el.transform(`translate3d(${x}, ${y}, 0px)`);
    } else {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
    }
  };
  const setTranslate2 = () => {
    const {
      $el,
      slides,
      progress,
      snapGrid
    } = swiper;
    $el.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((el) => {
      setTransform(el, progress);
    });
    slides.each((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      dom_default(slideEl).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((el) => {
        setTransform(el, slideProgress);
      });
    });
  };
  const setTransition2 = function(duration) {
    if (duration === void 0) {
      duration = swiper.params.speed;
    }
    const {
      $el
    } = swiper;
    $el.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((parallaxEl) => {
      const $parallaxEl = dom_default(parallaxEl);
      let parallaxDuration = parseInt($parallaxEl.attr("data-swiper-parallax-duration"), 10) || duration;
      if (duration === 0)
        parallaxDuration = 0;
      $parallaxEl.transition(parallaxDuration);
    });
  };
  on2("beforeInit", () => {
    if (!swiper.params.parallax.enabled)
      return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on2("init", () => {
    if (!swiper.params.parallax.enabled)
      return;
    setTranslate2();
  });
  on2("setTranslate", () => {
    if (!swiper.params.parallax.enabled)
      return;
    setTranslate2();
  });
  on2("setTransition", (_swiper, duration) => {
    if (!swiper.params.parallax.enabled)
      return;
    setTransition2(duration);
  });
}

// node_modules/swiper/modules/zoom/zoom.js
function Zoom(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  extendParams({
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: "swiper-zoom-container",
      zoomedSlideClass: "swiper-slide-zoomed"
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let gesturesEnabled;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const gesture = {
    $slideEl: void 0,
    slideWidth: void 0,
    slideHeight: void 0,
    $imageEl: void 0,
    $imageWrapEl: void 0,
    maxRatio: 3
  };
  const image = {
    isTouched: void 0,
    isMoved: void 0,
    currentX: void 0,
    currentY: void 0,
    minX: void 0,
    minY: void 0,
    maxX: void 0,
    maxY: void 0,
    width: void 0,
    height: void 0,
    startX: void 0,
    startY: void 0,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: void 0,
    y: void 0,
    prevPositionX: void 0,
    prevPositionY: void 0,
    prevTime: void 0
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, "scale", {
    get() {
      return scale;
    },
    set(value) {
      if (scale !== value) {
        const imageEl = gesture.$imageEl ? gesture.$imageEl[0] : void 0;
        const slideEl = gesture.$slideEl ? gesture.$slideEl[0] : void 0;
        emit("zoomChange", value, imageEl, slideEl);
      }
      scale = value;
    }
  });
  function getDistanceBetweenTouches(e) {
    if (e.targetTouches.length < 2)
      return 1;
    const x1 = e.targetTouches[0].pageX;
    const y1 = e.targetTouches[0].pageY;
    const x2 = e.targetTouches[1].pageX;
    const y2 = e.targetTouches[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function onGestureStart(e) {
    const support2 = swiper.support;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!support2.gestures) {
      if (e.type !== "touchstart" || e.type === "touchstart" && e.targetTouches.length < 2) {
        return;
      }
      fakeGestureTouched = true;
      gesture.scaleStart = getDistanceBetweenTouches(e);
    }
    if (!gesture.$slideEl || !gesture.$slideEl.length) {
      gesture.$slideEl = dom_default(e.target).closest(`.${swiper.params.slideClass}`);
      if (gesture.$slideEl.length === 0)
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      gesture.maxRatio = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
      if (gesture.$imageWrapEl.length === 0) {
        gesture.$imageEl = void 0;
        return;
      }
    }
    if (gesture.$imageEl) {
      gesture.$imageEl.transition(0);
    }
    isScaling = true;
  }
  function onGestureChange(e) {
    const support2 = swiper.support;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    if (!support2.gestures) {
      if (e.type !== "touchmove" || e.type === "touchmove" && e.targetTouches.length < 2) {
        return;
      }
      fakeGestureMoved = true;
      gesture.scaleMove = getDistanceBetweenTouches(e);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
      if (e.type === "gesturechange")
        onGestureStart(e);
      return;
    }
    if (support2.gestures) {
      zoom.scale = e.scale * currentScale;
    } else {
      zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    }
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }
    gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  }
  function onGestureEnd(e) {
    const device = swiper.device;
    const support2 = swiper.support;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    if (!support2.gestures) {
      if (!fakeGestureTouched || !fakeGestureMoved) {
        return;
      }
      if (e.type !== "touchend" || e.type === "touchend" && e.changedTouches.length < 2 && !device.android) {
        return;
      }
      fakeGestureTouched = false;
      fakeGestureMoved = false;
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0)
      return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale === 1)
      gesture.$slideEl = void 0;
  }
  function onTouchStart2(e) {
    const device = swiper.device;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0)
      return;
    if (image.isTouched)
      return;
    if (device.android && e.cancelable)
      e.preventDefault();
    image.isTouched = true;
    image.touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    image.touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
  }
  function onTouchMove2(e) {
    const zoom = swiper.zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0)
      return;
    swiper.allowClick = false;
    if (!image.isTouched || !gesture.$slideEl)
      return;
    if (!image.isMoved) {
      image.width = gesture.$imageEl[0].offsetWidth;
      image.height = gesture.$imageEl[0].offsetHeight;
      image.startX = getTranslate2(gesture.$imageWrapEl[0], "x") || 0;
      image.startY = getTranslate2(gesture.$imageWrapEl[0], "y") || 0;
      gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
      gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
      gesture.$imageWrapEl.transition(0);
    }
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight)
      return;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    image.touchesCurrent.y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();
    image.isMoved = true;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }
    if (!velocity.prevPositionX)
      velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY)
      velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime)
      velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)
      velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)
      velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  }
  function onTouchEnd2() {
    const zoom = swiper.zoom;
    if (!gesture.$imageEl || gesture.$imageEl.length === 0)
      return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;
    if (velocity.x !== 0)
      momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0)
      momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
  }
  function onTransitionEnd() {
    const zoom = swiper.zoom;
    if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
      if (gesture.$imageEl) {
        gesture.$imageEl.transform("translate3d(0,0,0) scale(1)");
      }
      if (gesture.$imageWrapEl) {
        gesture.$imageWrapEl.transform("translate3d(0,0,0)");
      }
      zoom.scale = 1;
      currentScale = 1;
      gesture.$slideEl = void 0;
      gesture.$imageEl = void 0;
      gesture.$imageWrapEl = void 0;
    }
  }
  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.$slideEl) {
      if (e && e.target) {
        gesture.$slideEl = dom_default(e.target).closest(`.${swiper.params.slideClass}`);
      }
      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }
      }
      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0)
      return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = "hidden";
      swiper.wrapperEl.style.touchAction = "none";
    }
    gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === "undefined" && e) {
      touchX = e.type === "touchend" ? e.changedTouches[0].pageX : e.pageX;
      touchY = e.type === "touchend" ? e.changedTouches[0].pageY : e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    zoom.scale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
    currentScale = gesture.$imageWrapEl.attr("data-swiper-zoom") || params.maxRatio;
    if (e) {
      slideWidth = gesture.$slideEl[0].offsetWidth;
      slideHeight = gesture.$slideEl[0].offsetHeight;
      offsetX = gesture.$slideEl.offset().left + window2.scrollX;
      offsetY = gesture.$slideEl.offset().top + window2.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.$imageEl[0].offsetWidth;
      imageHeight = gesture.$imageEl[0].offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
    gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
  }
  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.$slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
      } else {
        gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
      }
      gesture.$imageEl = gesture.$slideEl.find(`.${params.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0);
      gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
    }
    if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0)
      return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = "";
      swiper.wrapperEl.style.touchAction = "";
    }
    zoom.scale = 1;
    currentScale = 1;
    gesture.$imageWrapEl.transition(300).transform("translate3d(0,0,0)");
    gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)");
    gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
    gesture.$slideEl = void 0;
  }
  function zoomToggle(e) {
    const zoom = swiper.zoom;
    if (zoom.scale && zoom.scale !== 1) {
      zoomOut();
    } else {
      zoomIn(e);
    }
  }
  function getListeners() {
    const support2 = swiper.support;
    const passiveListener = swiper.touchEvents.start === "touchstart" && support2.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = support2.passiveListener ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }
  function getSlideSelector() {
    return `.${swiper.params.slideClass}`;
  }
  function toggleGestures(method) {
    const {
      passiveListener
    } = getListeners();
    const slideSelector = getSlideSelector();
    swiper.$wrapperEl[method]("gesturestart", slideSelector, onGestureStart, passiveListener);
    swiper.$wrapperEl[method]("gesturechange", slideSelector, onGestureChange, passiveListener);
    swiper.$wrapperEl[method]("gestureend", slideSelector, onGestureEnd, passiveListener);
  }
  function enableGestures() {
    if (gesturesEnabled)
      return;
    gesturesEnabled = true;
    toggleGestures("on");
  }
  function disableGestures() {
    if (!gesturesEnabled)
      return;
    gesturesEnabled = false;
    toggleGestures("off");
  }
  function enable3() {
    const zoom = swiper.zoom;
    if (zoom.enabled)
      return;
    zoom.enabled = true;
    const support2 = swiper.support;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    const slideSelector = getSlideSelector();
    if (support2.gestures) {
      swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === "touchstart") {
      swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
      }
    }
    swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove2, activeListenerWithCapture);
  }
  function disable3() {
    const zoom = swiper.zoom;
    if (!zoom.enabled)
      return;
    const support2 = swiper.support;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();
    const slideSelector = getSlideSelector();
    if (support2.gestures) {
      swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);
    } else if (swiper.touchEvents.start === "touchstart") {
      swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);
      swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);
      swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);
      if (swiper.touchEvents.cancel) {
        swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);
      }
    }
    swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, onTouchMove2, activeListenerWithCapture);
  }
  on2("init", () => {
    if (swiper.params.zoom.enabled) {
      enable3();
    }
  });
  on2("destroy", () => {
    disable3();
  });
  on2("touchStart", (_s, e) => {
    if (!swiper.zoom.enabled)
      return;
    onTouchStart2(e);
  });
  on2("touchEnd", (_s, e) => {
    if (!swiper.zoom.enabled)
      return;
    onTouchEnd2(e);
  });
  on2("doubleTap", (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on2("transitionEnd", () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on2("slideChange", () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable: enable3,
    disable: disable3,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}

// node_modules/swiper/modules/lazy/lazy.js
function Lazy2(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  extendParams({
    lazy: {
      checkInView: false,
      enabled: false,
      loadPrevNext: false,
      loadPrevNextAmount: 1,
      loadOnTransitionStart: false,
      scrollingElement: "",
      elementClass: "swiper-lazy",
      loadingClass: "swiper-lazy-loading",
      loadedClass: "swiper-lazy-loaded",
      preloaderClass: "swiper-lazy-preloader"
    }
  });
  swiper.lazy = {};
  let scrollHandlerAttached = false;
  let initialImageLoaded = false;
  function loadInSlide(index2, loadInDuplicate) {
    if (loadInDuplicate === void 0) {
      loadInDuplicate = true;
    }
    const params = swiper.params.lazy;
    if (typeof index2 === "undefined")
      return;
    if (swiper.slides.length === 0)
      return;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const $slideEl = isVirtual ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index2}"]`) : swiper.slides.eq(index2);
    const $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
    if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
      $images.push($slideEl[0]);
    }
    if ($images.length === 0)
      return;
    $images.each((imageEl) => {
      const $imageEl = dom_default(imageEl);
      $imageEl.addClass(params.loadingClass);
      const background = $imageEl.attr("data-background");
      const src = $imageEl.attr("data-src");
      const srcset = $imageEl.attr("data-srcset");
      const sizes = $imageEl.attr("data-sizes");
      const $pictureEl = $imageEl.parent("picture");
      swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, () => {
        if (typeof swiper === "undefined" || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed)
          return;
        if (background) {
          $imageEl.css("background-image", `url("${background}")`);
          $imageEl.removeAttr("data-background");
        } else {
          if (srcset) {
            $imageEl.attr("srcset", srcset);
            $imageEl.removeAttr("data-srcset");
          }
          if (sizes) {
            $imageEl.attr("sizes", sizes);
            $imageEl.removeAttr("data-sizes");
          }
          if ($pictureEl.length) {
            $pictureEl.children("source").each((sourceEl) => {
              const $source = dom_default(sourceEl);
              if ($source.attr("data-srcset")) {
                $source.attr("srcset", $source.attr("data-srcset"));
                $source.removeAttr("data-srcset");
              }
            });
          }
          if (src) {
            $imageEl.attr("src", src);
            $imageEl.removeAttr("data-src");
          }
        }
        $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
        $slideEl.find(`.${params.preloaderClass}`).remove();
        if (swiper.params.loop && loadInDuplicate) {
          const slideOriginalIndex = $slideEl.attr("data-swiper-slide-index");
          if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
            const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
            loadInSlide(originalSlide.index(), false);
          } else {
            const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
            loadInSlide(duplicatedSlide.index(), false);
          }
        }
        emit("lazyImageReady", $slideEl[0], $imageEl[0]);
        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      });
      emit("lazyImageLoad", $slideEl[0], $imageEl[0]);
    });
  }
  function load() {
    const {
      $wrapperEl,
      params: swiperParams,
      slides,
      activeIndex
    } = swiper;
    const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
    const params = swiperParams.lazy;
    let slidesPerView = swiperParams.slidesPerView;
    if (slidesPerView === "auto") {
      slidesPerView = 0;
    }
    function slideExist(index2) {
      if (isVirtual) {
        if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index2}"]`).length) {
          return true;
        }
      } else if (slides[index2])
        return true;
      return false;
    }
    function slideIndex(slideEl) {
      if (isVirtual) {
        return dom_default(slideEl).attr("data-swiper-slide-index");
      }
      return dom_default(slideEl).index();
    }
    if (!initialImageLoaded)
      initialImageLoaded = true;
    if (swiper.params.watchSlidesProgress) {
      $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((slideEl) => {
        const index2 = isVirtual ? dom_default(slideEl).attr("data-swiper-slide-index") : dom_default(slideEl).index();
        loadInSlide(index2);
      });
    } else if (slidesPerView > 1) {
      for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
        if (slideExist(i))
          loadInSlide(i);
      }
    } else {
      loadInSlide(activeIndex);
    }
    if (params.loadPrevNext) {
      if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
        const amount = params.loadPrevNextAmount;
        const spv = Math.ceil(slidesPerView);
        const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
        const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
        for (let i = activeIndex + spv; i < maxIndex; i += 1) {
          if (slideExist(i))
            loadInSlide(i);
        }
        for (let i = minIndex; i < activeIndex; i += 1) {
          if (slideExist(i))
            loadInSlide(i);
        }
      } else {
        const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
        if (nextSlide.length > 0)
          loadInSlide(slideIndex(nextSlide));
        const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
        if (prevSlide.length > 0)
          loadInSlide(slideIndex(prevSlide));
      }
    }
  }
  function checkInViewOnLoad() {
    const window2 = getWindow();
    if (!swiper || swiper.destroyed)
      return;
    const $scrollElement = swiper.params.lazy.scrollingElement ? dom_default(swiper.params.lazy.scrollingElement) : dom_default(window2);
    const isWindow = $scrollElement[0] === window2;
    const scrollElementWidth = isWindow ? window2.innerWidth : $scrollElement[0].offsetWidth;
    const scrollElementHeight = isWindow ? window2.innerHeight : $scrollElement[0].offsetHeight;
    const swiperOffset = swiper.$el.offset();
    const {
      rtlTranslate: rtl
    } = swiper;
    let inView = false;
    if (rtl)
      swiperOffset.left -= swiper.$el[0].scrollLeft;
    const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];
    for (let i = 0; i < swiperCoord.length; i += 1) {
      const point = swiperCoord[i];
      if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {
        if (point[0] === 0 && point[1] === 0)
          continue;
        inView = true;
      }
    }
    const passiveListener = swiper.touchEvents.start === "touchstart" && swiper.support.passiveListener && swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (inView) {
      load();
      $scrollElement.off("scroll", checkInViewOnLoad, passiveListener);
    } else if (!scrollHandlerAttached) {
      scrollHandlerAttached = true;
      $scrollElement.on("scroll", checkInViewOnLoad, passiveListener);
    }
  }
  on2("beforeInit", () => {
    if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
      swiper.params.preloadImages = false;
    }
  });
  on2("init", () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on2("scroll", () => {
    if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {
      load();
    }
  });
  on2("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on2("transitionStart", () => {
    if (swiper.params.lazy.enabled) {
      if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {
        if (swiper.params.lazy.checkInView) {
          checkInViewOnLoad();
        } else {
          load();
        }
      }
    }
  });
  on2("transitionEnd", () => {
    if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
      if (swiper.params.lazy.checkInView) {
        checkInViewOnLoad();
      } else {
        load();
      }
    }
  });
  on2("slideChange", () => {
    const {
      lazy,
      cssMode,
      watchSlidesProgress,
      touchReleaseOnEdges,
      resistanceRatio
    } = swiper.params;
    if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {
      load();
    }
  });
  on2("destroy", () => {
    if (!swiper.$el)
      return;
    swiper.$el.find(`.${swiper.params.lazy.loadingClass}`).removeClass(swiper.params.lazy.loadingClass);
  });
  Object.assign(swiper.lazy, {
    load,
    loadInSlide
  });
}

// node_modules/swiper/modules/controller/controller.js
function Controller(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    controller: {
      control: void 0,
      inverse: false,
      by: "slide"
    }
  });
  swiper.controller = {
    control: void 0
  };
  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }();
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    let i1;
    let i3;
    this.interpolate = function interpolate(x2) {
      if (!x2)
        return 0;
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;
      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };
    return this;
  }
  function getInterpolateFunction(c) {
    if (!swiper.controller.spline) {
      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
    }
  }
  function setTranslate2(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper2 = swiper.constructor;
    function setControlledTranslate(c) {
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === "slide") {
        getInterpolateFunction(c);
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }
      if (!controlledTranslate || swiper.params.controller.by === "container") {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }
      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper2 && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }
  function setTransition2(duration, byController) {
    const Swiper2 = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          nextTick2(() => {
            c.updateAutoHeight();
          });
        }
        c.$wrapperEl.transitionEnd(() => {
          if (!controlled)
            return;
          if (c.params.loop && swiper.params.controller.by === "slide") {
            c.loopFix();
          }
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper2) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper2 && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
  function removeSpline() {
    if (!swiper.controller.control)
      return;
    if (swiper.controller.spline) {
      swiper.controller.spline = void 0;
      delete swiper.controller.spline;
    }
  }
  on2("beforeInit", () => {
    swiper.controller.control = swiper.params.controller.control;
  });
  on2("update", () => {
    removeSpline();
  });
  on2("resize", () => {
    removeSpline();
  });
  on2("observerUpdate", () => {
    removeSpline();
  });
  on2("setTranslate", (_s, translate, byController) => {
    if (!swiper.controller.control)
      return;
    swiper.controller.setTranslate(translate, byController);
  });
  on2("setTransition", (_s, duration, byController) => {
    if (!swiper.controller.control)
      return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate: setTranslate2,
    setTransition: setTransition2
  });
}

// node_modules/swiper/modules/a11y/a11y.js
function A11y(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: "swiper-notification",
      prevSlideMessage: "Previous slide",
      nextSlideMessage: "Next slide",
      firstSlideMessage: "This is the first slide",
      lastSlideMessage: "This is the last slide",
      paginationBulletMessage: "Go to slide {{index}}",
      slideLabelMessage: "{{index}} / {{slidesLength}}",
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: "group",
      id: null
    }
  });
  let liveRegion = null;
  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0)
      return;
    notification.html("");
    notification.html(message);
  }
  function getRandomNumber(size) {
    if (size === void 0) {
      size = 16;
    }
    const randomChar = () => Math.round(16 * Math.random()).toString(16);
    return "x".repeat(size).replace(/x/g, randomChar);
  }
  function makeElFocusable($el) {
    $el.attr("tabIndex", "0");
  }
  function makeElNotFocusable($el) {
    $el.attr("tabIndex", "-1");
  }
  function addElRole($el, role) {
    $el.attr("role", role);
  }
  function addElRoleDescription($el, description) {
    $el.attr("aria-roledescription", description);
  }
  function addElControls($el, controls) {
    $el.attr("aria-controls", controls);
  }
  function addElLabel($el, label) {
    $el.attr("aria-label", label);
  }
  function addElId($el, id2) {
    $el.attr("id", id2);
  }
  function addElLive($el, live) {
    $el.attr("aria-live", live);
  }
  function disableEl($el) {
    $el.attr("aria-disabled", true);
  }
  function enableEl($el) {
    $el.attr("aria-disabled", false);
  }
  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32)
      return;
    const params = swiper.params.a11y;
    const $targetEl = dom_default(e.target);
    if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        notify(params.lastSlideMessage);
      } else {
        notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        notify(params.firstSlideMessage);
      } else {
        notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {
      $targetEl[0].click();
    }
  }
  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation)
      return;
    const {
      $nextEl,
      $prevEl
    } = swiper.navigation;
    if ($prevEl && $prevEl.length > 0) {
      if (swiper.isBeginning) {
        disableEl($prevEl);
        makeElNotFocusable($prevEl);
      } else {
        enableEl($prevEl);
        makeElFocusable($prevEl);
      }
    }
    if ($nextEl && $nextEl.length > 0) {
      if (swiper.isEnd) {
        disableEl($nextEl);
        makeElNotFocusable($nextEl);
      } else {
        enableEl($nextEl);
        makeElFocusable($nextEl);
      }
    }
  }
  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }
  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }
  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination())
      return;
    swiper.pagination.bullets.each((bulletEl) => {
      const $bulletEl = dom_default(bulletEl);
      if (swiper.params.pagination.clickable) {
        makeElFocusable($bulletEl);
        if (!swiper.params.pagination.renderBullet) {
          addElRole($bulletEl, "button");
          addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        }
      }
      if ($bulletEl.is(`.${swiper.params.pagination.bulletActiveClass}`)) {
        $bulletEl.attr("aria-current", "true");
      } else {
        $bulletEl.removeAttr("aria-current");
      }
    });
  }
  const initNavEl = ($el, wrapperId, message) => {
    makeElFocusable($el);
    if ($el[0].tagName !== "BUTTON") {
      addElRole($el, "button");
      $el.on("keydown", onEnterOrSpaceKey);
    }
    addElLabel($el, message);
    addElControls($el, wrapperId);
  };
  const handleFocus = (e) => {
    const slideEl = e.target.closest(`.${swiper.params.slideClass}`);
    if (!slideEl || !swiper.slides.includes(slideEl))
      return;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible)
      return;
    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
  };
  const initSlides = () => {
    const params = swiper.params.a11y;
    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription(dom_default(swiper.slides), params.itemRoleDescriptionMessage);
    }
    if (params.slideRole) {
      addElRole(dom_default(swiper.slides), params.slideRole);
    }
    const slidesLength = swiper.params.loop ? swiper.slides.filter((el) => !el.classList.contains(swiper.params.slideDuplicateClass)).length : swiper.slides.length;
    if (params.slideLabelMessage) {
      swiper.slides.each((slideEl, index2) => {
        const $slideEl = dom_default(slideEl);
        const slideIndex = swiper.params.loop ? parseInt($slideEl.attr("data-swiper-slide-index"), 10) : index2;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel($slideEl, ariaLabelMessage);
      });
    }
  };
  const init = () => {
    const params = swiper.params.a11y;
    swiper.$el.append(liveRegion);
    const $containerEl = swiper.$el;
    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);
    }
    if (params.containerMessage) {
      addElLabel($containerEl, params.containerMessage);
    }
    const $wrapperEl = swiper.$wrapperEl;
    const wrapperId = params.id || $wrapperEl.attr("id") || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
    addElId($wrapperEl, wrapperId);
    addElLive($wrapperEl, live);
    initSlides();
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl && $nextEl.length) {
      initNavEl($nextEl, wrapperId, params.nextSlideMessage);
    }
    if ($prevEl && $prevEl.length) {
      initNavEl($prevEl, wrapperId, params.prevSlideMessage);
    }
    if (hasClickablePagination()) {
      swiper.pagination.$el.on("keydown", classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    }
    swiper.$el.on("focus", handleFocus, true);
  };
  function destroy() {
    if (liveRegion && liveRegion.length > 0)
      liveRegion.remove();
    let $nextEl;
    let $prevEl;
    if (swiper.navigation && swiper.navigation.$nextEl) {
      $nextEl = swiper.navigation.$nextEl;
    }
    if (swiper.navigation && swiper.navigation.$prevEl) {
      $prevEl = swiper.navigation.$prevEl;
    }
    if ($nextEl) {
      $nextEl.off("keydown", onEnterOrSpaceKey);
    }
    if ($prevEl) {
      $prevEl.off("keydown", onEnterOrSpaceKey);
    }
    if (hasClickablePagination()) {
      swiper.pagination.$el.off("keydown", classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);
    }
    swiper.$el.off("focus", handleFocus, true);
  }
  on2("beforeInit", () => {
    liveRegion = dom_default(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`);
  });
  on2("afterInit", () => {
    if (!swiper.params.a11y.enabled)
      return;
    init();
  });
  on2("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
    if (!swiper.params.a11y.enabled)
      return;
    initSlides();
  });
  on2("fromEdge toEdge afterInit lock unlock", () => {
    if (!swiper.params.a11y.enabled)
      return;
    updateNavigation();
  });
  on2("paginationUpdate", () => {
    if (!swiper.params.a11y.enabled)
      return;
    updatePagination();
  });
  on2("destroy", () => {
    if (!swiper.params.a11y.enabled)
      return;
    destroy();
  });
}

// node_modules/swiper/modules/history/history.js
function History(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    history: {
      enabled: false,
      root: "",
      replaceState: false,
      key: "slides",
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};
  const slugify = (text2) => {
    return text2.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
  };
  const getPathValues = (urlOverride) => {
    const window2 = getWindow();
    let location;
    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window2.location;
    }
    const pathArray = location.pathname.slice(1).split("/").filter((part) => part !== "");
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };
  const setHistory = (key, index2) => {
    const window2 = getWindow();
    if (!initialized || !swiper.params.history.enabled)
      return;
    let location;
    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window2.location;
    }
    const slide = swiper.slides.eq(index2);
    let value = slugify(slide.attr("data-history"));
    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === "/")
        root = root.slice(0, root.length - 1);
      value = `${root}/${key}/${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key}/${value}`;
    }
    if (swiper.params.history.keepQuery) {
      value += location.search;
    }
    const currentState = window2.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      window2.history.replaceState({
        value
      }, null, value);
    } else {
      window2.history.pushState({
        value
      }, null, value);
    }
  };
  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHistory = slugify(slide.attr("data-history"));
        if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index2 = slide.index();
          swiper.slideTo(index2, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };
  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };
  const init = () => {
    const window2 = getWindow();
    if (!swiper.params.history)
      return;
    if (!window2.history || !window2.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value)
      return;
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      window2.addEventListener("popstate", setHistoryPopState);
    }
  };
  const destroy = () => {
    const window2 = getWindow();
    if (!swiper.params.history.replaceState) {
      window2.removeEventListener("popstate", setHistoryPopState);
    }
  };
  on2("init", () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on2("destroy", () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on2("transitionEnd _freeModeNoMomentumRelease", () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on2("slideChange", () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}

// node_modules/swiper/modules/hash-navigation/hash-navigation.js
function HashNavigation(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    on: on2
  } = _ref;
  let initialized = false;
  const document = getDocument();
  const window2 = getWindow();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false
    }
  });
  const onHashChange = () => {
    emit("hashChange");
    const newHash = document.location.hash.replace("#", "");
    const activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr("data-hash");
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-hash="${newHash}"]`).index();
      if (typeof newIndex === "undefined")
        return;
      swiper.slideTo(newIndex);
    }
  };
  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled)
      return;
    if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
      window2.history.replaceState(null, null, `#${swiper.slides.eq(swiper.activeIndex).attr("data-hash")}` || "");
      emit("hashSet");
    } else {
      const slide = swiper.slides.eq(swiper.activeIndex);
      const hash = slide.attr("data-hash") || slide.attr("data-history");
      document.location.hash = hash || "";
      emit("hashSet");
    }
  };
  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled)
      return;
    initialized = true;
    const hash = document.location.hash.replace("#", "");
    if (hash) {
      const speed = 0;
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides.eq(i);
        const slideHash = slide.attr("data-hash") || slide.attr("data-history");
        if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
          const index2 = slide.index();
          swiper.slideTo(index2, speed, swiper.params.runCallbacksOnInit, true);
        }
      }
    }
    if (swiper.params.hashNavigation.watchState) {
      dom_default(window2).on("hashchange", onHashChange);
    }
  };
  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      dom_default(window2).off("hashchange", onHashChange);
    }
  };
  on2("init", () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on2("destroy", () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on2("transitionEnd _freeModeNoMomentumRelease", () => {
    if (initialized) {
      setHash();
    }
  });
  on2("slideChange", () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}

// node_modules/swiper/modules/autoplay/autoplay.js
function Autoplay(_ref) {
  let {
    swiper,
    extendParams,
    on: on2,
    emit
  } = _ref;
  let timeout;
  swiper.autoplay = {
    running: false,
    paused: false
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3e3,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  function run() {
    const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
    let delay = swiper.params.autoplay.delay;
    if ($activeSlideEl.attr("data-swiper-autoplay")) {
      delay = $activeSlideEl.attr("data-swiper-autoplay") || swiper.params.autoplay.delay;
    }
    clearTimeout(timeout);
    timeout = nextTick2(() => {
      let autoplayResult;
      if (swiper.params.autoplay.reverseDirection) {
        if (swiper.params.loop) {
          swiper.loopFix();
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper.isBeginning) {
          autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);
          emit("autoplay");
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
          emit("autoplay");
        } else {
          stop();
        }
      } else if (swiper.params.loop) {
        swiper.loopFix();
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit("autoplay");
      } else if (!swiper.isEnd) {
        autoplayResult = swiper.slideNext(swiper.params.speed, true, true);
        emit("autoplay");
      } else if (!swiper.params.autoplay.stopOnLastSlide) {
        autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);
        emit("autoplay");
      } else {
        stop();
      }
      if (swiper.params.cssMode && swiper.autoplay.running)
        run();
      else if (autoplayResult === false) {
        run();
      }
    }, delay);
  }
  function start() {
    if (typeof timeout !== "undefined")
      return false;
    if (swiper.autoplay.running)
      return false;
    swiper.autoplay.running = true;
    emit("autoplayStart");
    run();
    return true;
  }
  function stop() {
    if (!swiper.autoplay.running)
      return false;
    if (typeof timeout === "undefined")
      return false;
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
    swiper.autoplay.running = false;
    emit("autoplayStop");
    return true;
  }
  function pause(speed) {
    if (!swiper.autoplay.running)
      return;
    if (swiper.autoplay.paused)
      return;
    if (timeout)
      clearTimeout(timeout);
    swiper.autoplay.paused = true;
    if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
      swiper.autoplay.paused = false;
      run();
    } else {
      ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
        swiper.$wrapperEl[0].addEventListener(event2, onTransitionEnd);
      });
    }
  }
  function onVisibilityChange() {
    const document = getDocument();
    if (document.visibilityState === "hidden" && swiper.autoplay.running) {
      pause();
    }
    if (document.visibilityState === "visible" && swiper.autoplay.paused) {
      run();
      swiper.autoplay.paused = false;
    }
  }
  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.$wrapperEl)
      return;
    if (e.target !== swiper.$wrapperEl[0])
      return;
    ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
      swiper.$wrapperEl[0].removeEventListener(event2, onTransitionEnd);
    });
    swiper.autoplay.paused = false;
    if (!swiper.autoplay.running) {
      stop();
    } else {
      run();
    }
  }
  function onMouseEnter() {
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
    } else {
      emit("autoplayPause");
      pause();
    }
    ["transitionend", "webkitTransitionEnd"].forEach((event2) => {
      swiper.$wrapperEl[0].removeEventListener(event2, onTransitionEnd);
    });
  }
  function onMouseLeave() {
    if (swiper.params.autoplay.disableOnInteraction) {
      return;
    }
    swiper.autoplay.paused = false;
    emit("autoplayResume");
    run();
  }
  function attachMouseEvents() {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.$el.on("mouseenter", onMouseEnter);
      swiper.$el.on("mouseleave", onMouseLeave);
    }
  }
  function detachMouseEvents() {
    swiper.$el.off("mouseenter", onMouseEnter);
    swiper.$el.off("mouseleave", onMouseLeave);
  }
  on2("init", () => {
    if (swiper.params.autoplay.enabled) {
      start();
      const document = getDocument();
      document.addEventListener("visibilitychange", onVisibilityChange);
      attachMouseEvents();
    }
  });
  on2("beforeTransitionStart", (_s, speed, internal) => {
    if (swiper.autoplay.running) {
      if (internal || !swiper.params.autoplay.disableOnInteraction) {
        swiper.autoplay.pause(speed);
      } else {
        stop();
      }
    }
  });
  on2("sliderFirstMove", () => {
    if (swiper.autoplay.running) {
      if (swiper.params.autoplay.disableOnInteraction) {
        stop();
      } else {
        pause();
      }
    }
  });
  on2("touchEnd", () => {
    if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
      run();
    }
  });
  on2("destroy", () => {
    detachMouseEvents();
    if (swiper.autoplay.running) {
      stop();
    }
    const document = getDocument();
    document.removeEventListener("visibilitychange", onVisibilityChange);
  });
  Object.assign(swiper.autoplay, {
    pause,
    run,
    start,
    stop
  });
}

// node_modules/swiper/modules/thumbs/thumbs.js
function Thumb(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: "swiper-slide-thumb-active",
      thumbsContainerClass: "swiper-thumbs"
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed)
      return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && dom_default(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass))
      return;
    if (typeof clickedIndex === "undefined" || clickedIndex === null)
      return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(dom_default(thumbsSwiper.clickedSlide).attr("data-swiper-slide-index"), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      let currentIndex = swiper.activeIndex;
      if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
        swiper.loopFix();
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
        currentIndex = swiper.activeIndex;
      }
      const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
      if (typeof prevIndex === "undefined")
        slideToIndex = nextIndex;
      else if (typeof nextIndex === "undefined")
        slideToIndex = prevIndex;
      else if (nextIndex - currentIndex < currentIndex - prevIndex)
        slideToIndex = nextIndex;
      else
        slideToIndex = prevIndex;
    }
    swiper.slideTo(slideToIndex);
  }
  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized)
      return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
    } else if (isObject(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on("tap", onThumbClick);
    return true;
  }
  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed)
      return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.removeClass(thumbActiveClass);
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
      }
    }
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      let currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
          thumbsSwiper.loopFix();
          thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
          currentThumbsIndex = thumbsSwiper.activeIndex;
        }
        const prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        const nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0).index();
        if (typeof prevThumbsIndex === "undefined") {
          newThumbsIndex = nextThumbsIndex;
        } else if (typeof nextThumbsIndex === "undefined") {
          newThumbsIndex = prevThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;
        } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
          newThumbsIndex = nextThumbsIndex;
        } else {
          newThumbsIndex = prevThumbsIndex;
        }
        direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
      }
      if (useOffset) {
        newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
      }
    }
  }
  on2("beforeInit", () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper)
      return;
    init();
    update(true);
  });
  on2("slideChange update resize observerUpdate", () => {
    update();
  });
  on2("setTransition", (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed)
      return;
    thumbsSwiper.setTransition(duration);
  });
  on2("beforeDestroy", () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed)
      return;
    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}

// node_modules/swiper/modules/free-mode/free-mode.js
function freeMode(_ref) {
  let {
    swiper,
    extendParams,
    emit,
    once
  } = _ref;
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });
  function onTouchStart2() {
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }
  function onTouchMove2() {
    const {
      touchEventsData: data,
      touches
    } = swiper;
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? "startX" : "startY"],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
      time: now2()
    });
  }
  function onTouchEnd2(_ref2) {
    let {
      currentPos
    } = _ref2;
    const {
      params,
      $wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper;
    const touchEndTime = now2();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        }
        if (time > 150 || now2() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1e3 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl)
        newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides)
          needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides)
          needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        once("transitionEnd", () => {
          swiper.loopFix();
        });
      }
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeMode.sticky) {
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(() => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce)
            return;
          emit("momentumBounce");
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed)
                return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit("_freeModeNoMomentumRelease");
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed)
              return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit("_freeModeNoMomentumRelease");
    }
    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }
  Object.assign(swiper, {
    freeMode: {
      onTouchStart: onTouchStart2,
      onTouchMove: onTouchMove2,
      onTouchEnd: onTouchEnd2
    }
  });
}

// node_modules/swiper/modules/grid/grid.js
function Grid2(_ref) {
  let {
    swiper,
    extendParams
  } = _ref;
  extendParams({
    grid: {
      rows: 1,
      fill: "column"
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;
  const initSlides = (slidesLength) => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    slidesPerRow = slidesNumberEvenToRows / rows;
    numFullColumns = Math.floor(slidesLength / rows);
    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }
    if (slidesPerView !== "auto" && fill === "row") {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
  };
  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
    const {
      slidesPerGroup,
      spaceBetween
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    let newSlideOrderIndex;
    let column;
    let row;
    if (fill === "row" && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.css({
        "-webkit-order": newSlideOrderIndex,
        order: newSlideOrderIndex
      });
    } else if (fill === "column") {
      column = Math.floor(i / rows);
      row = i - column * rows;
      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;
        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }
    slide.css(getDirectionLabel("margin-top"), row !== 0 ? spaceBetween && `${spaceBetween}px` : "");
  };
  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
    const {
      spaceBetween,
      centeredSlides,
      roundLengths
    } = swiper.params;
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    swiper.$wrapperEl.css({
      [getDirectionLabel("width")]: `${swiper.virtualSize + spaceBetween}px`
    });
    if (centeredSlides) {
      snapGrid.splice(0, snapGrid.length);
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths)
          slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0])
          newSlidesGrid.push(slidesGridItem);
      }
      snapGrid.push(...newSlidesGrid);
    }
  };
  swiper.grid = {
    initSlides,
    updateSlide,
    updateWrapperSize
  };
}

// node_modules/swiper/modules/manipulation/methods/appendSlide.js
function appendSlide(slides) {
  const swiper = this;
  const {
    $wrapperEl,
    params
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === "object" && "length" in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i])
        $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer) {
    swiper.update();
  }
}

// node_modules/swiper/modules/manipulation/methods/prependSlide.js
function prependSlide(slides) {
  const swiper = this;
  const {
    params,
    $wrapperEl,
    activeIndex
  } = swiper;
  if (params.loop) {
    swiper.loopDestroy();
  }
  let newActiveIndex = activeIndex + 1;
  if (typeof slides === "object" && "length" in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i])
        $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

// node_modules/swiper/modules/manipulation/methods/addSlide.js
function addSlide(index2, slides) {
  const swiper = this;
  const {
    $wrapperEl,
    params,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  const baseLength = swiper.slides.length;
  if (index2 <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index2 >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  let newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + 1 : activeIndexBuffer;
  const slidesBuffer = [];
  for (let i = baseLength - 1; i >= index2; i -= 1) {
    const currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === "object" && "length" in slides) {
    for (let i = 0; i < slides.length; i += 1) {
      if (slides[i])
        $wrapperEl.append(slides[i]);
    }
    newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }
  for (let i = 0; i < slidesBuffer.length; i += 1) {
    $wrapperEl.append(slidesBuffer[i]);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

// node_modules/swiper/modules/manipulation/methods/removeSlide.js
function removeSlide(slidesIndexes) {
  const swiper = this;
  const {
    params,
    $wrapperEl,
    activeIndex
  } = swiper;
  let activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
  }
  let newActiveIndex = activeIndexBuffer;
  let indexToRemove;
  if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
    for (let i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove])
        swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex)
        newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove])
      swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex)
      newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!params.observer) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

// node_modules/swiper/modules/manipulation/methods/removeAllSlides.js
function removeAllSlides() {
  const swiper = this;
  const slidesIndexes = [];
  for (let i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

// node_modules/swiper/modules/manipulation/manipulation.js
function Manipulation(_ref) {
  let {
    swiper
  } = _ref;
  Object.assign(swiper, {
    appendSlide: appendSlide.bind(swiper),
    prependSlide: prependSlide.bind(swiper),
    addSlide: addSlide.bind(swiper),
    removeSlide: removeSlide.bind(swiper),
    removeAllSlides: removeAllSlides.bind(swiper)
  });
}

// node_modules/swiper/shared/effect-init.js
function effectInit(params) {
  const {
    effect,
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on2("beforeInit", () => {
    if (swiper.params.effect !== effect)
      return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on2("setTranslate", () => {
    if (swiper.params.effect !== effect)
      return;
    setTranslate2();
  });
  on2("setTransition", (_s, duration) => {
    if (swiper.params.effect !== effect)
      return;
    setTransition2(duration);
  });
  on2("transitionEnd", () => {
    if (swiper.params.effect !== effect)
      return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows)
        return;
      swiper.slides.each((slideEl) => {
        const $slideEl = swiper.$(slideEl);
        $slideEl.find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove();
      });
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on2("virtualUpdate", () => {
    if (swiper.params.effect !== effect)
      return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate2();
        requireUpdateOnVirtual = false;
      }
    });
  });
}

// node_modules/swiper/shared/effect-target.js
function effectTarget(effectParams, $slideEl) {
  if (effectParams.transformEl) {
    return $slideEl.find(effectParams.transformEl).css({
      "backface-visibility": "hidden",
      "-webkit-backface-visibility": "hidden"
    });
  }
  return $slideEl;
}

// node_modules/swiper/shared/effect-virtual-transition-end.js
function effectVirtualTransitionEnd(_ref) {
  let {
    swiper,
    duration,
    transformEl,
    allSlides
  } = _ref;
  const {
    slides,
    activeIndex,
    $wrapperEl
  } = swiper;
  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let $transitionEndTarget;
    if (allSlides) {
      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;
    } else {
      $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
    }
    $transitionEndTarget.transitionEnd(() => {
      if (eventTriggered)
        return;
      if (!swiper || swiper.destroyed)
        return;
      eventTriggered = true;
      swiper.animating = false;
      const triggerEvents = ["webkitTransitionEnd", "transitionend"];
      for (let i = 0; i < triggerEvents.length; i += 1) {
        $wrapperEl.trigger(triggerEvents[i]);
      }
    });
  }
}

// node_modules/swiper/modules/effect-fade/effect-fade.js
function EffectFade(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    fadeEffect: {
      crossFade: false,
      transformEl: null
    }
  });
  const setTranslate2 = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = swiper.slides.eq(i);
      const offset2 = $slideEl[0].swiperSlideOffset;
      let tx = -offset2;
      if (!swiper.params.virtualTranslate)
        tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
      const $targetEl = effectTarget(params, $slideEl);
      $targetEl.css({
        opacity: slideOpacity
      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
    }
  };
  const setTransition2 = (duration) => {
    const {
      transformEl
    } = swiper.params.fadeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration);
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };
  effectInit({
    effect: "fade",
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

// node_modules/swiper/modules/effect-cube/effect-cube.js
function EffectCube(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const createSlideShadows = ($slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
    let shadowAfter = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
    if (shadowBefore.length === 0) {
      shadowBefore = dom_default(`<div class="swiper-slide-shadow-${isHorizontal ? "left" : "top"}"></div>`);
      $slideEl.append(shadowBefore);
    }
    if (shadowAfter.length === 0) {
      shadowAfter = dom_default(`<div class="swiper-slide-shadow-${isHorizontal ? "right" : "bottom"}"></div>`);
      $slideEl.append(shadowAfter);
    }
    if (shadowBefore.length)
      shadowBefore[0].style.opacity = Math.max(-progress, 0);
    if (shadowAfter.length)
      shadowAfter[0].style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.each((slideEl) => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(dom_default(slideEl), progress, isHorizontal);
    });
  };
  const setTranslate2 = () => {
    const {
      $el,
      $wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser: browser2
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let $cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl = $wrapperEl.find(".swiper-cube-shadow");
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = dom_default('<div class="swiper-cube-shadow"></div>');
          $wrapperEl.append($cubeShadowEl);
        }
        $cubeShadowEl.css({
          height: `${swiperWidth}px`
        });
      } else {
        $cubeShadowEl = $el.find(".swiper-cube-shadow");
        if ($cubeShadowEl.length === 0) {
          $cubeShadowEl = dom_default('<div class="swiper-cube-shadow"></div>');
          $el.append($cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt($slideEl.attr("data-swiper-slide-index"), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform2 = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl)
          wrapperRotate = -slideIndex * 90 - progress * 90;
      }
      $slideEl.transform(transform2);
      if (params.slideShadows) {
        createSlideShadows($slideEl, progress, isHorizontal);
      }
    }
    $wrapperEl.css({
      "-webkit-transform-origin": `50% 50% -${swiperSize / 2}px`,
      "transform-origin": `50% 50% -${swiperSize / 2}px`
    });
    if (params.shadow) {
      if (isHorizontal) {
        $cubeShadowEl.transform(`translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset2 = params.shadowOffset;
        $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset2}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
      }
    }
    const zFactor = browser2.isSafari || browser2.isWebView ? -swiperSize / 2 : 0;
    $wrapperEl.transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
    $wrapperEl[0].style.setProperty("--swiper-cube-translate-z", `${zFactor}px`);
  };
  const setTransition2 = (duration) => {
    const {
      $el,
      slides
    } = swiper;
    slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      $el.find(".swiper-cube-shadow").transition(duration);
    }
  };
  effectInit({
    effect: "cube",
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}

// node_modules/swiper/shared/create-shadow.js
function createShadow(params, $slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}`;
  const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
  let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
  if (!$shadowEl.length) {
    $shadowEl = dom_default(`<div class="swiper-slide-shadow${side ? `-${side}` : ""}"></div>`);
    $shadowContainer.append($shadowEl);
  }
  return $shadowEl;
}

// node_modules/swiper/modules/effect-flip/effect-flip.js
function EffectFlip(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true,
      transformEl: null
    }
  });
  const createSlideShadows = ($slideEl, progress, params) => {
    let shadowBefore = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
    let shadowAfter = swiper.isHorizontal() ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
    if (shadowBefore.length === 0) {
      shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? "left" : "top");
    }
    if (shadowAfter.length === 0) {
      shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? "right" : "bottom");
    }
    if (shadowBefore.length)
      shadowBefore[0].style.opacity = Math.max(-progress, 0);
    if (shadowAfter.length)
      shadowAfter[0].style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    const params = swiper.params.flipEffect;
    swiper.slides.each((slideEl) => {
      const $slideEl = dom_default(slideEl);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      createSlideShadows($slideEl, progress, params);
    });
  };
  const setTranslate2 = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      let progress = $slideEl[0].progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
      }
      const offset2 = $slideEl[0].swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset2 - swiper.translate : -offset2;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }
      $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
      if (params.slideShadows) {
        createSlideShadows($slideEl, progress, params);
      }
      const transform2 = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      const $targetEl = effectTarget(params, $slideEl);
      $targetEl.transform(transform2);
    }
  };
  const setTransition2 = (duration) => {
    const {
      transformEl
    } = swiper.params.flipEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformEl
    });
  };
  effectInit({
    effect: "flip",
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

// node_modules/swiper/modules/effect-coverflow/effect-coverflow.js
function EffectCoverflow(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true,
      transformEl: null
    }
  });
  const setTranslate2 = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform2 = swiper.translate;
    const center = isHorizontal ? -transform2 + swiperWidth / 2 : -transform2 + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideSize = slidesSizesGrid[i];
      const slideOffset = $slideEl[0].swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === "function" ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch;
      if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }
      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
      if (Math.abs(translateX) < 1e-3)
        translateX = 0;
      if (Math.abs(translateY) < 1e-3)
        translateY = 0;
      if (Math.abs(translateZ) < 1e-3)
        translateZ = 0;
      if (Math.abs(rotateY) < 1e-3)
        rotateY = 0;
      if (Math.abs(rotateX) < 1e-3)
        rotateX = 0;
      if (Math.abs(scale) < 1e-3)
        scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
      const $targetEl = effectTarget(params, $slideEl);
      $targetEl.transform(slideTransform);
      $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        let $shadowBeforeEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-left") : $slideEl.find(".swiper-slide-shadow-top");
        let $shadowAfterEl = isHorizontal ? $slideEl.find(".swiper-slide-shadow-right") : $slideEl.find(".swiper-slide-shadow-bottom");
        if ($shadowBeforeEl.length === 0) {
          $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? "left" : "top");
        }
        if ($shadowAfterEl.length === 0) {
          $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? "right" : "bottom");
        }
        if ($shadowBeforeEl.length)
          $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if ($shadowAfterEl.length)
          $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };
  const setTransition2 = (duration) => {
    const {
      transformEl
    } = swiper.params.coverflowEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration);
  };
  effectInit({
    effect: "coverflow",
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}

// node_modules/swiper/modules/effect-creative/effect-creative.js
function EffectCreative(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    creativeEffect: {
      transformEl: null,
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const getTranslateValue = (value) => {
    if (typeof value === "string")
      return value;
    return `${value}px`;
  };
  const setTranslate2 = () => {
    const {
      slides,
      $wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;
    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
    }
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideProgress = $slideEl[0].progress;
      const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;
      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
      }
      const offset2 = $slideEl[0].swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset2 - swiper.translate : -offset2, 0, 0];
      const r = [0, 0, 0];
      let custom = false;
      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }
      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };
      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      }
      t.forEach((value, index2) => {
        t[index2] = `calc(${value}px + (${getTranslateValue(data.translate[index2])} * ${Math.abs(progress * multiplier)}))`;
      });
      r.forEach((value, index2) => {
        r[index2] = data.rotate[index2] * Math.abs(progress * multiplier);
      });
      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(", ");
      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform2 = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
      if (custom && data.shadow || !custom) {
        let $shadowEl = $slideEl.children(".swiper-slide-shadow");
        if ($shadowEl.length === 0 && data.shadow) {
          $shadowEl = createShadow(params, $slideEl);
        }
        if ($shadowEl.length) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }
      const $targetEl = effectTarget(params, $slideEl);
      $targetEl.transform(transform2).css({
        opacity: opacityString
      });
      if (data.origin) {
        $targetEl.css("transform-origin", data.origin);
      }
    }
  };
  const setTransition2 = (duration) => {
    const {
      transformEl
    } = swiper.params.creativeEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find(".swiper-slide-shadow").transition(duration);
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformEl,
      allSlides: true
    });
  };
  effectInit({
    effect: "creative",
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

// node_modules/swiper/modules/effect-cards/effect-cards.js
function EffectCards(_ref) {
  let {
    swiper,
    extendParams,
    on: on2
  } = _ref;
  extendParams({
    cardsEffect: {
      slideShadows: true,
      transformEl: null,
      rotate: true
    }
  });
  const setTranslate2 = () => {
    const {
      slides,
      activeIndex
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = swiper.translate;
    for (let i = 0; i < slides.length; i += 1) {
      const $slideEl = slides.eq(i);
      const slideProgress = $slideEl[0].progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset2 = $slideEl[0].swiperSlideOffset;
      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.$wrapperEl.transform(`translateX(${swiper.minTranslate()}px)`);
      }
      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset2 -= slides[0].swiperSlideOffset;
      }
      let tX = swiper.params.cssMode ? -offset2 - swiper.translate : -offset2;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -2 * progress;
      let tXAdd = 8 - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }
      if (progress < 0) {
        tX = `calc(${tX}px + (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        tX = `calc(${tX}px + (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }
      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }
      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
      const transform2 = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rotate : 0}deg)
        scale(${scaleString})
      `;
      if (params.slideShadows) {
        let $shadowEl = $slideEl.find(".swiper-slide-shadow");
        if ($shadowEl.length === 0) {
          $shadowEl = createShadow(params, $slideEl);
        }
        if ($shadowEl.length)
          $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }
      $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const $targetEl = effectTarget(params, $slideEl);
      $targetEl.transform(transform2);
    }
  };
  const setTransition2 = (duration) => {
    const {
      transformEl
    } = swiper.params.cardsEffect;
    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
    $transitionElements.transition(duration).find(".swiper-slide-shadow").transition(duration);
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformEl
    });
  };
  effectInit({
    effect: "cards",
    swiper,
    on: on2,
    setTranslate: setTranslate2,
    setTransition: setTransition2,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}

// node_modules/swiper/swiper-bundle.esm.js
var modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy2, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid2, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
core_default.use(modules);

// node_modules/framework7/components/swiper/swiper.js
function initSwiper(swiperEl) {
  const app = this;
  const $swiperEl = dom7_default(swiperEl);
  if ($swiperEl.length === 0)
    return;
  if ($swiperEl[0].swiper)
    return;
  let initialSlide;
  let params = {};
  let isTabs;
  let isRoutableTabs;
  if ($swiperEl.hasClass("tabs-swipeable-wrap")) {
    $swiperEl.addClass("swiper").children(".tabs").addClass("swiper-wrapper").children(".tab").addClass("swiper-slide");
    initialSlide = $swiperEl.children(".tabs").children(".tab-active").index();
    isTabs = true;
    isRoutableTabs = $swiperEl.find(".tabs-routable").length > 0;
  }
  if ($swiperEl.attr("data-swiper")) {
    params = JSON.parse($swiperEl.attr("data-swiper"));
  } else if ($swiperEl[0].f7SwiperParams) {
    params = $swiperEl[0].f7SwiperParams;
  } else {
    params = $swiperEl.dataset();
    Object.keys(params).forEach((key) => {
      const value = params[key];
      if (typeof value === "string" && value.indexOf("{") === 0 && value.indexOf("}") > 0) {
        try {
          params[key] = JSON.parse(value);
        } catch (e) {
        }
      }
    });
  }
  if (typeof params.initialSlide === "undefined" && typeof initialSlide !== "undefined") {
    params.initialSlide = initialSlide;
  }
  const swiper = app.swiper.create($swiperEl[0], params);
  function updateSwiper() {
    swiper.update();
  }
  const $tabEl = $swiperEl.parents(".tab").filter((tabEl) => {
    return dom7_default(tabEl).parent(".tabs").parent(".tabs-animated-wrap, .tabs-swipeable-wrap").length === 0;
  }).eq(0);
  $swiperEl.parents(".popup, .login-screen, .sheet-modal, .popover").on("modal:open", updateSwiper);
  $swiperEl.parents(".panel").on("panel:open", updateSwiper);
  if ($tabEl && $tabEl.length) {
    $tabEl.on("tab:show", updateSwiper);
  }
  swiper.on("beforeDestroy", () => {
    $swiperEl.parents(".popup, .login-screen, .sheet-modal, .popover").off("modal:open", updateSwiper);
    $swiperEl.parents(".panel").off("panel:open", updateSwiper);
    if ($tabEl && $tabEl.length) {
      $tabEl.off("tab:show", updateSwiper);
    }
  });
  if (isTabs) {
    swiper.on("slideChange", () => {
      if (isRoutableTabs) {
        let view = app.views.get($swiperEl.parents(".view"));
        if (!view)
          view = app.views.main;
        const router = view.router;
        const tabRouteUrl = router.findTabRouteUrl(swiper.slides.eq(swiper.activeIndex)[0]);
        if (tabRouteUrl) {
          setTimeout(() => {
            router.navigate(tabRouteUrl);
          }, 0);
        }
      } else {
        app.tab.show({
          tabEl: swiper.slides.eq(swiper.activeIndex)
        });
      }
    });
  }
}
var swiper_default = {
  name: "swiper",
  static: {
    Swiper: core_default
  },
  create() {
    const app = this;
    app.swiper = ConstructorMethods({
      defaultSelector: ".swiper",
      constructor: core_default,
      domProp: "swiper"
    });
  },
  on: {
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    },
    pageMounted(page) {
      const app = this;
      page.$el.find(".tabs-swipeable-wrap").each((swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    pageReinit(page) {
      const app = this;
      page.$el.find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update)
          swiper.update();
      });
    },
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        initSwiper.call(app, swiperEl);
      });
    },
    tabShow(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        const swiper = app.swiper.get(swiperEl);
        if (swiper && swiper.update)
          swiper.update();
      });
    },
    tabBeforeRemove(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".swiper-init, .tabs-swipeable-wrap").each((swiperEl) => {
        app.swiper.destroy(swiperEl);
      });
    }
  },
  vnode: {
    "swiper-init": {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },
      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      }
    },
    "tabs-swipeable-wrap": {
      insert(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        initSwiper.call(app, swiperEl);
      },
      destroy(vnode) {
        const app = this;
        const swiperEl = vnode.elm;
        app.swiper.destroy(swiperEl);
      }
    }
  }
};

// node_modules/framework7/components/photo-browser/photo-browser-class.js
var PhotoBrowser = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const pb = this;
    pb.app = app;
    const defaults = extend({
      on: {}
    }, app.params.photoBrowser);
    pb.useModulesParams(defaults);
    pb.params = extend(defaults, params);
    extend(pb, {
      exposed: false,
      opened: false,
      activeIndex: pb.params.swiper.initialSlide,
      url: pb.params.url,
      swipeToClose: {
        allow: true,
        isTouched: false,
        diff: void 0,
        start: void 0,
        current: void 0,
        started: false,
        activeSlide: void 0,
        timeStart: void 0
      }
    });
    pb.useModules();
    pb.init();
  }
  get view() {
    const {
      params,
      app
    } = this;
    return params.view || app.views.main;
  }
  onSlideChange(swiper) {
    const pb = this;
    pb.activeIndex = swiper.activeIndex;
    let current = swiper.activeIndex + 1;
    let total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
    if (swiper.params.loop) {
      total -= 2;
      current -= swiper.loopedSlides;
      if (current < 1)
        current = total + current;
      if (current > total)
        current -= total;
    }
    const $activeSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides.eq(swiper.activeIndex);
    const $previousSlideEl = pb.params.virtualSlides ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.previousIndex}"]`) : swiper.slides.eq(swiper.previousIndex);
    let $currentEl = pb.$el.find(".photo-browser-current");
    let $totalEl = pb.$el.find(".photo-browser-total");
    let navbarEl;
    if (pb.params.type === "page" && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === "ios") {
      navbarEl = pb.app.navbar.getElByPage(pb.$el);
      if (navbarEl) {
        $currentEl = dom7_default(navbarEl).find(".photo-browser-current");
        $totalEl = dom7_default(navbarEl).find(".photo-browser-total");
      }
    }
    if ($currentEl.length && $totalEl.length) {
      $currentEl.text(current);
      $totalEl.text(total);
      if (!navbarEl)
        navbarEl = $currentEl.parents(".navbar")[0];
      if (navbarEl) {
        pb.app.navbar.size(navbarEl);
      }
    }
    if (pb.captions.length > 0) {
      const captionIndex = swiper.params.loop ? $activeSlideEl.attr("data-swiper-slide-index") : pb.activeIndex;
      pb.$captionsContainerEl.find(".photo-browser-caption-active").removeClass("photo-browser-caption-active");
      pb.$captionsContainerEl.find(`[data-caption-index="${captionIndex}"]`).addClass("photo-browser-caption-active");
    }
    const previousSlideVideo = $previousSlideEl.find("video");
    if (previousSlideVideo.length > 0) {
      if ("pause" in previousSlideVideo[0])
        previousSlideVideo[0].pause();
    }
  }
  onTouchStart() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.allow)
      return;
    swipeToClose.isTouched = true;
  }
  onTouchMove(e) {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    if (!swipeToClose.isTouched)
      return;
    if (!swipeToClose.started) {
      swipeToClose.started = true;
      swipeToClose.start = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (pb.params.virtualSlides) {
        swipeToClose.activeSlide = pb.swiper.$wrapperEl.children(".swiper-slide-active");
      } else {
        swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
      }
      swipeToClose.timeStart = now();
    }
    e.preventDefault();
    swipeToClose.current = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    swipeToClose.diff = swipeToClose.start - swipeToClose.current;
    pb.$el.transition(0).transform(`translate3d(0,${-swipeToClose.diff}px,0)`);
  }
  onTouchEnd() {
    const pb = this;
    const swipeToClose = pb.swipeToClose;
    swipeToClose.isTouched = false;
    if (!swipeToClose.started) {
      swipeToClose.started = false;
      return;
    }
    swipeToClose.started = false;
    swipeToClose.allow = false;
    const diff = Math.abs(swipeToClose.diff);
    const timeDiff = new Date().getTime() - swipeToClose.timeStart;
    if (timeDiff < 300 && diff > 20 || timeDiff >= 300 && diff > 100) {
      nextTick(() => {
        if (pb.$el) {
          if (swipeToClose.diff < 0)
            pb.$el.addClass("swipe-close-to-bottom");
          else
            pb.$el.addClass("swipe-close-to-top");
        }
        pb.emit("local::swipeToClose", pb);
        pb.$el.transform("").transition("");
        pb.close();
        swipeToClose.allow = true;
      });
      return;
    }
    if (diff !== 0) {
      pb.$el.addClass("photo-browser-transitioning").transitionEnd(() => {
        swipeToClose.allow = true;
        pb.$el.removeClass("photo-browser-transitioning");
      });
    } else {
      swipeToClose.allow = true;
    }
    nextTick(() => {
      pb.$el.transform("").transition("");
    });
  }
  renderNavbar() {
    const pb = this;
    if (pb.params.renderNavbar)
      return pb.params.renderNavbar.call(pb);
    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === "dark")
      iconsColor = "white";
    const pageBackLinkText = (pb.app.theme === "ios" || pb.app.theme === "aurora") && pb.params.pageBackLinkText ? pb.params.pageBackLinkText : "";
    const renderNavbarCount = typeof pb.params.navbarShowCount === "undefined" ? pb.params.photos.length > 1 : pb.params.navbarShowCount;
    const isPopup = pb.params.type !== "page";
    return jsx_default2("div", {
      class: `navbar navbar-photo-browser ${pb.params.theme === "dark" ? "navbar-photo-browser-dark" : ""}`
    }, jsx_default2("div", {
      class: "navbar-bg"
    }), jsx_default2("div", {
      class: "navbar-inner navbar-inner-centered-title sliding"
    }, !isPopup && jsx_default2("div", {
      class: "left"
    }, jsx_default2("a", {
      class: `link ${!pageBackLinkText ? "icon-only" : ""} back`
    }, jsx_default2("i", {
      class: `icon icon-back ${iconsColor ? `color-${iconsColor}` : ""}`
    }), pageBackLinkText && jsx_default2("span", null, pageBackLinkText))), renderNavbarCount && jsx_default2("div", {
      class: "title"
    }, jsx_default2("span", {
      class: "photo-browser-current"
    }), jsx_default2("span", {
      class: "photo-browser-of"
    }, pb.params.navbarOfText), jsx_default2("span", {
      class: "photo-browser-total"
    })), isPopup && jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link popup-close",
      "data-popup": ".photo-browser-popup"
    }, jsx_default2("span", null, pb.params.popupCloseLinkText)))));
  }
  renderToolbar() {
    const pb = this;
    if (pb.params.renderToolbar)
      return pb.params.renderToolbar.call(pb);
    let iconsColor = pb.params.iconsColor;
    if (!pb.params.iconsColor && pb.params.theme === "dark")
      iconsColor = "white";
    return jsx_default2("div", {
      class: "toolbar toolbar-bottom tabbar"
    }, jsx_default2("div", {
      class: "toolbar-inner"
    }, jsx_default2("a", {
      class: "link photo-browser-prev"
    }, jsx_default2("i", {
      class: `icon icon-back ${iconsColor ? `color-${iconsColor}` : ""}`
    })), jsx_default2("a", {
      class: "link photo-browser-next"
    }, jsx_default2("i", {
      class: `icon icon-forward ${iconsColor ? `color-${iconsColor}` : ""}`
    }))));
  }
  renderCaption(caption, index2) {
    const pb = this;
    if (pb.params.renderCaption)
      return pb.params.renderCaption.call(pb, caption, index2);
    return jsx_default2("div", {
      class: "photo-browser-caption",
      "data-caption-index": index2
    }, caption);
  }
  renderObject(photo, index2) {
    const pb = this;
    if (pb.params.renderObject)
      return pb.params.renderObject.call(pb, photo, index2);
    return jsx_default2("div", {
      class: "photo-browser-slide photo-browser-object-slide swiper-slide",
      "data-swiper-slide-index": index2
    }, photo.html ? photo.html : photo);
  }
  renderLazyPhoto(photo, index2) {
    const pb = this;
    if (pb.params.renderLazyPhoto)
      return pb.params.renderLazyPhoto.call(pb, photo, index2);
    return jsx_default2("div", {
      class: "photo-browser-slide photo-browser-slide-lazy swiper-slide",
      "data-swiper-slide-index": index2
    }, jsx_default2("div", {
      class: "swiper-lazy-preloader"
    }), jsx_default2("span", {
      class: "swiper-zoom-container"
    }, jsx_default2("img", {
      "data-src": photo.url ? photo.url : photo,
      class: "swiper-lazy"
    })));
  }
  renderPhoto(photo, index2) {
    const pb = this;
    if (pb.params.renderPhoto)
      return pb.params.renderPhoto.call(pb, photo, index2);
    return jsx_default2("div", {
      class: "photo-browser-slide swiper-slide",
      "data-swiper-slide-index": index2
    }, jsx_default2("span", {
      class: "swiper-zoom-container"
    }, jsx_default2("img", {
      src: photo.url ? photo.url : photo
    })));
  }
  render() {
    const pb = this;
    if (pb.params.render)
      return pb.params.render.call(pb, pb.params);
    return jsx_default2("div", {
      class: `photo-browser photo-browser-${pb.params.theme}`
    }, jsx_default2("div", {
      class: "view"
    }, jsx_default2("div", {
      class: `page photo-browser-page photo-browser-page-${pb.params.theme} no-toolbar ${!pb.params.navbar ? "no-navbar" : ""}`,
      "data-name": "photo-browser-page"
    }, pb.params.navbar && pb.renderNavbar(), pb.params.toolbar && pb.renderToolbar(), jsx_default2("div", {
      class: `photo-browser-captions photo-browser-captions-${pb.params.captionsTheme || pb.params.theme}`
    }, pb.params.photos.map((photo, index2) => {
      if (photo.caption)
        return pb.renderCaption(photo.caption, index2);
      return "";
    })), jsx_default2("div", {
      class: "photo-browser-swiper-container swiper"
    }, jsx_default2("div", {
      class: "photo-browser-swiper-wrapper swiper-wrapper"
    }, !pb.params.virtualSlides && pb.params.photos.map((photo, index2) => {
      if (photo.html || (typeof photo === "string" || photo instanceof String) && photo.indexOf("<") >= 0 && photo.indexOf(">") >= 0) {
        return pb.renderObject(photo, index2);
      }
      if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
        return pb.renderLazyPhoto(photo, index2);
      }
      return pb.renderPhoto(photo, index2);
    }))))));
  }
  renderStandalone() {
    const pb = this;
    if (pb.params.renderStandalone)
      return pb.params.renderStandalone.call(pb);
    const standaloneHtml = `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${pb.render()}</div>`;
    return standaloneHtml;
  }
  renderPage() {
    const pb = this;
    if (pb.params.renderPage)
      return pb.params.renderPage.call(pb);
    const pageHtml = pb.render();
    return pageHtml;
  }
  renderPopup() {
    const pb = this;
    if (pb.params.renderPopup)
      return pb.params.renderPopup.call(pb);
    const popupHtml = `<div class="popup photo-browser-popup">${pb.render()}</div>`;
    return popupHtml;
  }
  onOpen(type, el) {
    const pb = this;
    const app = pb.app;
    const $el = dom7_default(el);
    $el[0].f7PhotoBrowser = pb;
    pb.$el = $el;
    pb.el = $el[0];
    pb.openedIn = type;
    pb.opened = true;
    pb.$swiperContainerEl = pb.$el.find(".photo-browser-swiper-container");
    pb.$swiperWrapperEl = pb.$el.find(".photo-browser-swiper-wrapper");
    pb.slides = pb.$el.find(".photo-browser-slide");
    pb.$captionsContainerEl = pb.$el.find(".photo-browser-captions");
    pb.captions = pb.$el.find(".photo-browser-caption");
    let clickTimeout;
    const swiperParams = extend({}, pb.params.swiper, {
      initialSlide: pb.activeIndex,
      cssMode: typeof pb.params.swiper.cssMode === "undefined" && (app.device.ios || app.device.android) ? true : pb.params.swiper.cssMode,
      on: {
        click(e) {
          clearTimeout(clickTimeout);
          if (pb.params.exposition) {
            clickTimeout = setTimeout(() => {
              pb.expositionToggle();
            }, 350);
          }
          pb.emit("local::tap", e);
          pb.emit("local::click", e);
        },
        doubleClick(e) {
          clearTimeout(clickTimeout);
          pb.emit("local::doubleTap", e);
          pb.emit("local::doubleClick", e);
        },
        slideChange() {
          const swiper = this;
          pb.onSlideChange(swiper);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          pb.emit("local::slideChange", ...args);
        },
        transitionStart() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          pb.emit("local::transitionStart", ...args);
        },
        transitionEnd() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          pb.emit("local::transitionEnd", ...args);
        },
        slideChangeTransitionStart() {
          const swiper = this;
          pb.onSlideChange(swiper);
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          pb.emit("local::slideChangeTransitionStart", ...args);
        },
        slideChangeTransitionEnd() {
          for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            args[_key5] = arguments[_key5];
          }
          pb.emit("local::slideChangeTransitionEnd", ...args);
        },
        lazyImageLoad() {
          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
            args[_key6] = arguments[_key6];
          }
          pb.emit("local::lazyImageLoad", ...args);
        },
        lazyImageReady() {
          for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
            args[_key7] = arguments[_key7];
          }
          const slideEl = args[0];
          dom7_default(slideEl).removeClass("photo-browser-slide-lazy");
          pb.emit("local::lazyImageReady", ...args);
        }
      }
    });
    if (pb.params.swipeToClose && pb.params.type !== "page") {
      extend(swiperParams.on, {
        touchStart(swiper, e) {
          pb.onTouchStart(e);
          pb.emit("local::touchStart", e);
        },
        touchMoveOpposite(swiper, e) {
          pb.onTouchMove(e);
          pb.emit("local::touchMoveOpposite", e);
        },
        touchEnd(swiper, e) {
          pb.onTouchEnd(e);
          pb.emit("local::touchEnd", e);
        }
      });
    }
    if (pb.params.virtualSlides) {
      extend(swiperParams, {
        virtual: {
          slides: pb.params.photos,
          renderSlide(photo, index2) {
            if (photo.html || (typeof photo === "string" || photo instanceof String) && photo.indexOf("<") >= 0 && photo.indexOf(">") >= 0) {
              return pb.renderObject(photo, index2);
            }
            if (pb.params.swiper.lazy === true || pb.params.swiper.lazy && pb.params.swiper.lazy.enabled) {
              return pb.renderLazyPhoto(photo, index2);
            }
            return pb.renderPhoto(photo, index2);
          }
        }
      });
    }
    const window2 = getWindow();
    pb.swiper = app.swiper ? app.swiper.create(pb.$swiperContainerEl, swiperParams) : new window2.Swiper(pb.$swiperContainerEl, swiperParams);
    if (pb.activeIndex === 0) {
      pb.onSlideChange(pb.swiper);
    }
    if (pb.$el) {
      pb.$el.trigger("photobrowser:open");
    }
    pb.emit("local::open photoBrowserOpen", pb);
  }
  onOpened() {
    const pb = this;
    if (pb.$el && pb.params.type === "standalone") {
      pb.$el.css("animation", "none");
    }
    if (pb.$el) {
      pb.$el.trigger("photobrowser:opened");
    }
    pb.emit("local::opened photoBrowserOpened", pb);
  }
  onClose() {
    const pb = this;
    if (pb.destroyed)
      return;
    if (pb.swiper && pb.swiper.destroy) {
      pb.swiper.destroy(true, false);
      pb.swiper = null;
      delete pb.swiper;
    }
    if (pb.$el) {
      pb.$el.trigger("photobrowser:close");
    }
    pb.emit("local::close photoBrowserClose", pb);
  }
  onClosed() {
    const pb = this;
    if (pb.destroyed)
      return;
    pb.opened = false;
    pb.$el = null;
    pb.el = null;
    delete pb.$el;
    delete pb.el;
    if (pb.$el) {
      pb.$el.trigger("photobrowser:closed");
    }
    pb.emit("local::closed photoBrowserClosed", pb);
  }
  openPage() {
    const pb = this;
    if (pb.opened)
      return pb;
    const pageHtml = pb.renderPage();
    pb.view.router.navigate({
      url: pb.url,
      route: {
        content: pageHtml,
        path: pb.url,
        on: {
          pageBeforeIn(e, page) {
            pb.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${pb.params.theme}`);
            pb.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            pb.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            pb.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${pb.params.theme}`);
            pb.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            pb.onClosed("page", page.el);
          }
        }
      }
    });
    return pb;
  }
  openStandalone() {
    const pb = this;
    if (pb.opened)
      return pb;
    const standaloneHtml = pb.renderStandalone();
    const popupParams = {
      backdrop: false,
      content: standaloneHtml,
      on: {
        popupOpen(popup) {
          pb.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          pb.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          pb.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          pb.onClosed("popup", popup.el);
        }
      }
    };
    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams
        }
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }
  openPopup() {
    const pb = this;
    if (pb.opened)
      return pb;
    const popupHtml = pb.renderPopup();
    const popupParams = {
      content: popupHtml,
      push: pb.params.popupPush,
      on: {
        popupOpen(popup) {
          pb.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          pb.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          pb.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          pb.onClosed("popup", popup.el);
        }
      }
    };
    if (pb.params.routableModals && pb.view) {
      pb.view.router.navigate({
        url: pb.url,
        route: {
          path: pb.url,
          popup: popupParams
        }
      });
    } else {
      pb.modal = pb.app.popup.create(popupParams).open();
    }
    return pb;
  }
  expositionEnable() {
    const pb = this;
    if (pb.params.type === "page") {
      pb.view.$el.addClass("with-photo-browser-page-exposed");
    }
    if (pb.$el)
      pb.$el.addClass("photo-browser-exposed");
    if (pb.params.expositionHideCaptions)
      pb.$captionsContainerEl.addClass("photo-browser-captions-exposed");
    pb.exposed = true;
    return pb;
  }
  expositionDisable() {
    const pb = this;
    if (pb.params.type === "page") {
      pb.view.$el.removeClass("with-photo-browser-page-exposed");
    }
    if (pb.$el)
      pb.$el.removeClass("photo-browser-exposed");
    if (pb.params.expositionHideCaptions)
      pb.$captionsContainerEl.removeClass("photo-browser-captions-exposed");
    pb.exposed = false;
    return pb;
  }
  expositionToggle() {
    const pb = this;
    if (pb.params.type === "page") {
      pb.view.$el.toggleClass("with-photo-browser-page-exposed");
    }
    if (pb.$el)
      pb.$el.toggleClass("photo-browser-exposed");
    if (pb.params.expositionHideCaptions)
      pb.$captionsContainerEl.toggleClass("photo-browser-captions-exposed");
    pb.exposed = !pb.exposed;
    return pb;
  }
  open(index2) {
    const pb = this;
    const type = pb.params.type;
    if (pb.opened) {
      if (pb.swiper && typeof index2 !== "undefined") {
        pb.swiper.slideTo(parseInt(index2, 10));
      }
      return pb;
    }
    if (typeof index2 !== "undefined") {
      pb.activeIndex = index2;
    }
    if (type === "standalone") {
      pb.openStandalone();
    }
    if (type === "page") {
      pb.openPage();
    }
    if (type === "popup") {
      pb.openPopup();
    }
    return pb;
  }
  close() {
    const pb = this;
    if (!pb.opened)
      return pb;
    if (pb.params.routableModals && pb.view || pb.openedIn === "page") {
      pb.view.router.back();
    } else {
      pb.modal.once("modalClosed", () => {
        nextTick(() => {
          if (pb.destroyed)
            return;
          pb.modal.destroy();
          delete pb.modal;
        });
      });
      pb.modal.close();
    }
    return pb;
  }
  init() {
  }
  destroy() {
    let pb = this;
    pb.emit("local::beforeDestroy photoBrowserBeforeDestroy", pb);
    if (pb.$el) {
      pb.$el.trigger("photobrowser:beforedestroy");
      pb.$el[0].f7PhotoBrowser = null;
      delete pb.$el[0].f7PhotoBrowser;
    }
    deleteProps(pb);
    pb.destroyed = true;
    pb = null;
  }
};
var photo_browser_class_default = PhotoBrowser;

// node_modules/framework7/components/photo-browser/photo-browser.js
var photo_browser_default = {
  name: "photoBrowser",
  params: {
    photoBrowser: {
      photos: [],
      exposition: true,
      expositionHideCaptions: false,
      type: "standalone",
      navbar: true,
      toolbar: true,
      theme: "light",
      captionsTheme: void 0,
      iconsColor: void 0,
      popupPush: false,
      swipeToClose: true,
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      navbarOfText: "of",
      navbarShowCount: void 0,
      view: void 0,
      url: "photos/",
      routableModals: false,
      virtualSlides: true,
      renderNavbar: void 0,
      renderToolbar: void 0,
      renderCaption: void 0,
      renderObject: void 0,
      renderLazyPhoto: void 0,
      renderPhoto: void 0,
      renderPage: void 0,
      renderPopup: void 0,
      renderStandalone: void 0,
      swiper: {
        initialSlide: 0,
        spaceBetween: 20,
        speed: 300,
        loop: false,
        preloadImages: true,
        keyboard: {
          enabled: true
        },
        navigation: {
          nextEl: ".photo-browser-next",
          prevEl: ".photo-browser-prev"
        },
        zoom: {
          enabled: true,
          maxRatio: 3,
          minRatio: 1
        },
        lazy: {
          enabled: true
        }
      }
    }
  },
  create() {
    const app = this;
    app.photoBrowser = ConstructorMethods({
      defaultSelector: ".photo-browser-popup, .photo-browser-page",
      constructor: photo_browser_class_default,
      app,
      domProp: "f7PhotoBrowser"
    });
  },
  static: {
    PhotoBrowser: photo_browser_class_default
  }
};

// node_modules/framework7/components/notification/notification-class.js
var Notification = class extends modal_class_default {
  constructor(app, params) {
    const extendedParams = extend({
      on: {}
    }, app.params.notification, params);
    super(app, extendedParams);
    const notification = this;
    notification.app = app;
    notification.params = extendedParams;
    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text: text2,
      closeButton,
      closeTimeout,
      cssClass,
      closeOnClick
    } = notification.params;
    let $el;
    if (!notification.params.el) {
      const notificationHtml = notification.render({
        icon,
        title,
        titleRightText,
        subtitle,
        text: text2,
        closeButton,
        cssClass
      });
      $el = dom7_default(notificationHtml);
    } else {
      $el = dom7_default(notification.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal;
    }
    if ($el.length === 0) {
      return notification.destroy();
    }
    extend(notification, {
      $el,
      el: $el[0],
      type: "notification"
    });
    $el[0].f7Modal = notification;
    if (closeButton) {
      $el.find(".notification-close-button").on("click", () => {
        notification.close();
      });
    }
    $el.on("click", (e) => {
      if (closeButton && dom7_default(e.target).closest(".notification-close-button").length) {
        return;
      }
      notification.emit("local::click notificationClick", notification);
      if (closeOnClick)
        notification.close();
    });
    notification.on("beforeDestroy", () => {
      $el.off("click");
    });
    let isTouched;
    let isMoved;
    let isScrolling;
    let touchesDiff;
    let touchStartTime;
    let notificationHeight;
    const touchesStart = {};
    function handleTouchStart(e) {
      if (isTouched)
        return;
      isTouched = true;
      isMoved = false;
      isScrolling = void 0;
      touchStartTime = now();
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === "undefined") {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      e.preventDefault();
      if (!isMoved) {
        notification.$el.removeClass("notification-transitioning");
        notification.$el.transition(0);
        notificationHeight = notification.$el[0].offsetHeight / 2;
      }
      isMoved = true;
      touchesDiff = pageY - touchesStart.y;
      let newTranslate = touchesDiff;
      if (touchesDiff > 0) {
        newTranslate = touchesDiff ** 0.8;
      }
      notification.$el.transform(`translate3d(0, ${newTranslate}px, 0)`);
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      if (touchesDiff === 0) {
        return;
      }
      const timeDiff = now() - touchStartTime;
      notification.$el.transition("");
      notification.$el.addClass("notification-transitioning");
      notification.$el.transform("");
      if (touchesDiff < -10 && timeDiff < 300 || -touchesDiff >= notificationHeight / 1) {
        notification.close();
      }
    }
    function attachTouchEvents() {
      notification.$el.on(app.touchEvents.start, handleTouchStart, {
        passive: true
      });
      app.on("touchmove:active", handleTouchMove);
      app.on("touchend:passive", handleTouchEnd);
    }
    function detachTouchEvents() {
      notification.$el.off(app.touchEvents.start, handleTouchStart, {
        passive: true
      });
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
    }
    let timeoutId;
    function closeOnTimeout() {
      timeoutId = nextTick(() => {
        if (isTouched && isMoved) {
          closeOnTimeout();
          return;
        }
        notification.close();
      }, closeTimeout);
    }
    notification.on("open", () => {
      if (notification.params.swipeToClose) {
        attachTouchEvents();
      }
      dom7_default(".notification.modal-in").each((openedEl) => {
        const notificationInstance = app.notification.get(openedEl);
        if (openedEl !== notification.el && notificationInstance) {
          notificationInstance.close();
        }
      });
      if (closeTimeout) {
        closeOnTimeout();
      }
    });
    notification.on("close beforeDestroy", () => {
      if (notification.params.swipeToClose) {
        detachTouchEvents();
      }
      clearTimeout(timeoutId);
    });
    return notification;
  }
  render() {
    const notification = this;
    if (notification.params.render)
      return notification.params.render.call(notification, notification);
    const {
      icon,
      title,
      titleRightText,
      subtitle,
      text: text2,
      closeButton,
      cssClass
    } = notification.params;
    return jsx_default2("div", {
      class: `notification ${cssClass || ""}`
    }, jsx_default2("div", {
      class: "notification-header"
    }, icon && jsx_default2("div", {
      class: "notification-icon"
    }, icon), title && jsx_default2("div", {
      class: "notification-title"
    }, title), titleRightText && jsx_default2("div", {
      class: "notification-title-right-text"
    }, titleRightText), closeButton && jsx_default2("span", {
      class: "notification-close-button"
    })), jsx_default2("div", {
      class: "notification-content"
    }, subtitle && jsx_default2("div", {
      class: "notification-subtitle"
    }, subtitle), text2 && jsx_default2("div", {
      class: "notification-text"
    }, text2)));
  }
};
var notification_class_default = Notification;

// node_modules/framework7/components/notification/notification.js
var notification_default = {
  name: "notification",
  static: {
    Notification: notification_class_default
  },
  create() {
    const app = this;
    app.notification = extend({}, ModalMethods({
      app,
      constructor: notification_class_default,
      defaultSelector: ".notification.modal-in"
    }));
  },
  params: {
    notification: {
      icon: null,
      title: null,
      titleRightText: null,
      subtitle: null,
      text: null,
      closeButton: false,
      closeTimeout: null,
      closeOnClick: false,
      swipeToClose: true,
      cssClass: null,
      render: null,
      containerEl: null
    }
  }
};

// node_modules/framework7/components/autocomplete/autocomplete-class.js
var Autocomplete = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const ac = this;
    ac.app = app;
    const device = getDevice();
    const defaults = extend({
      on: {}
    }, app.params.autocomplete);
    if (typeof defaults.searchbarDisableButton === "undefined") {
      defaults.searchbarDisableButton = app.theme !== "aurora";
    }
    ac.useModulesParams(defaults);
    ac.params = extend(defaults, params);
    let $openerEl;
    if (ac.params.openerEl) {
      $openerEl = dom7_default(ac.params.openerEl);
      if ($openerEl.length)
        $openerEl[0].f7Autocomplete = ac;
    }
    let $inputEl;
    if (ac.params.inputEl) {
      $inputEl = dom7_default(ac.params.inputEl);
      if ($inputEl.length)
        $inputEl[0].f7Autocomplete = ac;
    }
    const uniqueId = id();
    let url = params.url;
    if (!url && $openerEl && $openerEl.length) {
      if ($openerEl.attr("href"))
        url = $openerEl.attr("href");
      else if ($openerEl.find("a").length > 0) {
        url = $openerEl.find("a").attr("href");
      }
    }
    if (!url || url === "#" || url === "")
      url = ac.params.url;
    const inputType = ac.params.multiple ? "checkbox" : "radio";
    extend(ac, {
      $openerEl,
      openerEl: $openerEl && $openerEl[0],
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      id: uniqueId,
      url,
      value: ac.params.value || [],
      inputType,
      inputName: `${inputType}-${uniqueId}`,
      $modalEl: void 0,
      $dropdownEl: void 0
    });
    let previousQuery = "";
    function onInputChange() {
      let query = ac.$inputEl.val().trim();
      if (!ac.params.source)
        return;
      ac.params.source.call(ac, query, (items) => {
        let itemsHTML = "";
        const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
        ac.items = items;
        let regExp;
        if (ac.params.highlightMatches) {
          query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
          regExp = new RegExp(`(${query})`, "i");
        }
        let firstValue;
        let firstItem;
        for (let i = 0; i < limit; i += 1) {
          const itemValue = typeof items[i] === "object" ? items[i][ac.params.valueProperty] : items[i];
          const itemText = typeof items[i] === "object" ? items[i][ac.params.textProperty] : items[i];
          if (i === 0) {
            firstValue = itemValue;
            firstItem = ac.items[i];
          }
          itemsHTML += ac.renderItem({
            value: itemValue,
            text: ac.params.highlightMatches ? itemText.replace(regExp, "<b>$1</b>") : itemText
          }, i);
        }
        if (itemsHTML === "" && query === "" && ac.params.dropdownPlaceholderText) {
          itemsHTML += ac.renderItem({
            placeholder: true,
            text: ac.params.dropdownPlaceholderText
          });
        }
        ac.$dropdownEl.find("ul").html(itemsHTML);
        if (ac.params.typeahead) {
          if (!firstValue || !firstItem) {
            return;
          }
          if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
            return;
          }
          if (previousQuery.toLowerCase() === query.toLowerCase()) {
            ac.value = [];
            return;
          }
          if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
            previousQuery = query;
            ac.value = [];
            return;
          }
          $inputEl.val(firstValue);
          $inputEl[0].setSelectionRange(query.length, firstValue.length);
          const previousValue = typeof ac.value[0] === "object" ? ac.value[0][ac.params.valueProperty] : ac.value[0];
          if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
            ac.value = [firstItem];
            ac.emit("local::change autocompleteChange", [firstItem]);
          }
        }
        previousQuery = query;
      });
    }
    function onPageInputChange() {
      const inputEl = this;
      const value = inputEl.value;
      const isValues = dom7_default(inputEl).parents(".autocomplete-values").length > 0;
      let item;
      let itemValue;
      let aValue;
      if (isValues) {
        if (ac.inputType === "checkbox" && !inputEl.checked) {
          for (let i = 0; i < ac.value.length; i += 1) {
            aValue = typeof ac.value[i] === "string" ? ac.value[i] : ac.value[i][ac.params.valueProperty];
            if (aValue === value || aValue * 1 === value * 1) {
              ac.value.splice(i, 1);
            }
          }
          ac.updateValues();
          ac.emit("local::change autocompleteChange", ac.value);
        }
        return;
      }
      for (let i = 0; i < ac.items.length; i += 1) {
        itemValue = typeof ac.items[i] === "object" ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        if (itemValue === value || itemValue * 1 === value * 1)
          item = ac.items[i];
      }
      if (ac.inputType === "radio") {
        ac.value = [item];
      } else if (inputEl.checked) {
        ac.value.push(item);
      } else {
        for (let i = 0; i < ac.value.length; i += 1) {
          aValue = typeof ac.value[i] === "object" ? ac.value[i][ac.params.valueProperty] : ac.value[i];
          if (aValue === value || aValue * 1 === value * 1) {
            ac.value.splice(i, 1);
          }
        }
      }
      ac.updateValues();
      if (ac.inputType === "radio" && inputEl.checked || ac.inputType === "checkbox") {
        ac.emit("local::change autocompleteChange", ac.value);
      }
    }
    function onHtmlClick(e) {
      const $targetEl = dom7_default(e.target);
      if ($targetEl.is(ac.$inputEl[0]) || ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length)
        return;
      ac.close();
    }
    function onOpenerClick() {
      ac.open();
    }
    function onInputFocus() {
      ac.open();
    }
    function onInputBlur() {
      if (ac.$dropdownEl.find("label.active-state").length > 0)
        return;
      setTimeout(() => {
        ac.close();
      }, 0);
    }
    function onResize2() {
      ac.positionDropdown();
    }
    function onKeyDown(e) {
      if (!ac.opened)
        return;
      if (e.keyCode === 27) {
        e.preventDefault();
        ac.$inputEl.blur();
        return;
      }
      if (e.keyCode === 13) {
        const $selectedItemLabel = ac.$dropdownEl.find(".autocomplete-dropdown-selected label");
        if ($selectedItemLabel.length) {
          e.preventDefault();
          $selectedItemLabel.trigger("click");
          ac.$inputEl.blur();
          return;
        }
        if (ac.params.typeahead) {
          e.preventDefault();
          ac.$inputEl.blur();
        }
        return;
      }
      if (e.keyCode !== 40 && e.keyCode !== 38)
        return;
      e.preventDefault();
      const $selectedItem = ac.$dropdownEl.find(".autocomplete-dropdown-selected");
      let $newItem;
      if ($selectedItem.length) {
        $newItem = $selectedItem[e.keyCode === 40 ? "next" : "prev"]("li");
        if (!$newItem.length) {
          $newItem = ac.$dropdownEl.find("li").eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find("li").length - 1);
        }
      } else {
        $newItem = ac.$dropdownEl.find("li").eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find("li").length - 1);
      }
      if ($newItem.hasClass("autocomplete-dropdown-placeholder"))
        return;
      $selectedItem.removeClass("autocomplete-dropdown-selected");
      $newItem.addClass("autocomplete-dropdown-selected");
    }
    function onDropdownClick() {
      const $clickedEl = dom7_default(this);
      let clickedItem;
      for (let i = 0; i < ac.items.length; i += 1) {
        const itemValue = typeof ac.items[i] === "object" ? ac.items[i][ac.params.valueProperty] : ac.items[i];
        const value = $clickedEl.attr("data-value");
        if (itemValue === value || itemValue * 1 === value * 1) {
          clickedItem = ac.items[i];
        }
      }
      if (ac.params.updateInputValueOnSelect) {
        ac.$inputEl.val(typeof clickedItem === "object" ? clickedItem[ac.params.valueProperty] : clickedItem);
        ac.$inputEl.trigger("input change");
      }
      ac.value = [clickedItem];
      ac.emit("local::change autocompleteChange", [clickedItem]);
      ac.close();
    }
    ac.attachEvents = function attachEvents2() {
      if (ac.params.openIn !== "dropdown" && ac.$openerEl) {
        ac.$openerEl.on("click", onOpenerClick);
      }
      if (ac.params.openIn === "dropdown" && ac.$inputEl) {
        ac.$inputEl.on("focus", onInputFocus);
        ac.$inputEl.on(ac.params.inputEvents, onInputChange);
        if (device.android) {
          dom7_default("html").on("click", onHtmlClick);
        } else {
          ac.$inputEl.on("blur", onInputBlur);
        }
        ac.$inputEl.on("keydown", onKeyDown);
      }
    };
    ac.detachEvents = function attachEvents2() {
      if (ac.params.openIn !== "dropdown" && ac.$openerEl) {
        ac.$openerEl.off("click", onOpenerClick);
      }
      if (ac.params.openIn === "dropdown" && ac.$inputEl) {
        ac.$inputEl.off("focus", onInputFocus);
        ac.$inputEl.off(ac.params.inputEvents, onInputChange);
        if (device.android) {
          dom7_default("html").off("click", onHtmlClick);
        } else {
          ac.$inputEl.off("blur", onInputBlur);
        }
        ac.$inputEl.off("keydown", onKeyDown);
      }
    };
    ac.attachDropdownEvents = function attachDropdownEvents() {
      ac.$dropdownEl.on("click", "label", onDropdownClick);
      app.on("resize", onResize2);
    };
    ac.detachDropdownEvents = function detachDropdownEvents() {
      ac.$dropdownEl.off("click", "label", onDropdownClick);
      app.off("resize", onResize2);
    };
    ac.attachPageEvents = function attachPageEvents() {
      ac.$el.on("change", 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
      if (ac.params.closeOnSelect && !ac.params.multiple) {
        ac.$el.once("click", ".list label", () => {
          nextTick(() => {
            ac.close();
          });
        });
      }
    };
    ac.detachPageEvents = function detachPageEvents() {
      ac.$el.off("change", 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
    };
    ac.useModules();
    ac.init();
    return ac;
  }
  get view() {
    const ac = this;
    const {
      $openerEl,
      $inputEl,
      app
    } = ac;
    let view;
    if (ac.params.view) {
      view = ac.params.view;
    } else if ($openerEl || $inputEl) {
      const $el = $openerEl || $inputEl;
      view = $el.closest(".view").length && $el.closest(".view")[0].f7View;
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  positionDropdown() {
    const ac = this;
    const {
      $inputEl,
      app,
      $dropdownEl
    } = ac;
    const $pageContentEl = $inputEl.parents(".page-content");
    if ($pageContentEl.length === 0)
      return;
    const inputOffset = $inputEl.offset();
    const inputOffsetWidth = $inputEl[0].offsetWidth;
    const inputOffsetHeight = $inputEl[0].offsetHeight;
    const $listEl = $inputEl.parents(".list");
    let $listParent;
    $listEl.parents().each((parentEl) => {
      if ($listParent)
        return;
      const $parentEl = dom7_default(parentEl);
      if ($parentEl.parent($pageContentEl).length)
        $listParent = $parentEl;
    });
    const listOffset = $listEl.offset();
    const paddingBottom = parseInt($pageContentEl.css("padding-bottom"), 10);
    const listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
    const inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
    const inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);
    const maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;
    const paddingProp = app.rtl ? "padding-right" : "padding-left";
    let paddingValue;
    if ($listEl.length && !ac.params.expandInput) {
      paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === "md" ? 16 : 15);
    }
    $dropdownEl.css({
      left: `${$listEl.length > 0 ? listOffsetLeft : inputOffsetLeft}px`,
      top: `${inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight}px`,
      width: `${$listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth}px`
    });
    $dropdownEl.children(".autocomplete-dropdown-inner").css({
      maxHeight: `${maxHeight}px`,
      [paddingProp]: $listEl.length > 0 && !ac.params.expandInput ? `${paddingValue}px` : ""
    });
  }
  focus() {
    const ac = this;
    ac.$el.find("input[type=search]").focus();
  }
  source(query) {
    const ac = this;
    if (!ac.params.source)
      return;
    const {
      $el
    } = ac;
    ac.params.source.call(ac, query, (items) => {
      let itemsHTML = "";
      const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
      ac.items = items;
      for (let i = 0; i < limit; i += 1) {
        let selected = false;
        const itemValue = typeof items[i] === "object" ? items[i][ac.params.valueProperty] : items[i];
        for (let j = 0; j < ac.value.length; j += 1) {
          const aValue = typeof ac.value[j] === "object" ? ac.value[j][ac.params.valueProperty] : ac.value[j];
          if (aValue === itemValue || aValue * 1 === itemValue * 1)
            selected = true;
        }
        itemsHTML += ac.renderItem({
          value: itemValue,
          text: typeof items[i] === "object" ? items[i][ac.params.textProperty] : items[i],
          inputType: ac.inputType,
          id: ac.id,
          inputName: ac.inputName,
          selected
        }, i);
      }
      $el.find(".autocomplete-found ul").html(itemsHTML);
      if (items.length === 0) {
        if (query.length !== 0) {
          $el.find(".autocomplete-not-found").show();
          $el.find(".autocomplete-found, .autocomplete-values").hide();
        } else {
          $el.find(".autocomplete-values").show();
          $el.find(".autocomplete-found, .autocomplete-not-found").hide();
        }
      } else {
        $el.find(".autocomplete-found").show();
        $el.find(".autocomplete-not-found, .autocomplete-values").hide();
      }
    });
  }
  updateValues() {
    const ac = this;
    let valuesHTML = "";
    for (let i = 0; i < ac.value.length; i += 1) {
      valuesHTML += ac.renderItem({
        value: typeof ac.value[i] === "object" ? ac.value[i][ac.params.valueProperty] : ac.value[i],
        text: typeof ac.value[i] === "object" ? ac.value[i][ac.params.textProperty] : ac.value[i],
        inputType: ac.inputType,
        id: ac.id,
        inputName: `${ac.inputName}-checked}`,
        selected: true
      }, i);
    }
    ac.$el.find(".autocomplete-values ul").html(valuesHTML);
  }
  preloaderHide() {
    const ac = this;
    if (ac.params.openIn === "dropdown" && ac.$dropdownEl) {
      ac.$dropdownEl.find(".autocomplete-preloader").removeClass("autocomplete-preloader-visible");
    } else {
      dom7_default(".autocomplete-preloader").removeClass("autocomplete-preloader-visible");
    }
  }
  preloaderShow() {
    const ac = this;
    if (ac.params.openIn === "dropdown" && ac.$dropdownEl) {
      ac.$dropdownEl.find(".autocomplete-preloader").addClass("autocomplete-preloader-visible");
    } else {
      dom7_default(".autocomplete-preloader").addClass("autocomplete-preloader-visible");
    }
  }
  renderPreloader() {
    const ac = this;
    const preloaders = {
      iosPreloaderContent,
      mdPreloaderContent,
      auroraPreloaderContent
    };
    return jsx_default2("div", {
      class: `autocomplete-preloader preloader ${ac.params.preloaderColor ? `color-${ac.params.preloaderColor}` : ""}`
    }, preloaders[`${ac.app.theme}PreloaderContent`] || "");
  }
  renderSearchbar() {
    const ac = this;
    if (ac.params.renderSearchbar)
      return ac.params.renderSearchbar.call(ac);
    return jsx_default2("form", {
      class: "searchbar"
    }, jsx_default2("div", {
      class: "searchbar-inner"
    }, jsx_default2("div", {
      class: "searchbar-input-wrap"
    }, jsx_default2("input", {
      type: "search",
      spellcheck: ac.params.searchbarSpellcheck || "false",
      placeholder: ac.params.searchbarPlaceholder
    }), jsx_default2("i", {
      class: "searchbar-icon"
    }), jsx_default2("span", {
      class: "input-clear-button"
    })), ac.params.searchbarDisableButton && jsx_default2("span", {
      class: "searchbar-disable-button"
    }, ac.params.searchbarDisableText)));
  }
  renderItem(item, index2) {
    const ac = this;
    if (ac.params.renderItem)
      return ac.params.renderItem.call(ac, item, index2);
    const itemValue = item.value && typeof item.value === "string" ? item.value.replace(/"/g, "&quot;") : item.value;
    if (ac.params.openIn !== "dropdown") {
      return jsx_default2("li", null, jsx_default2("label", {
        class: `item-${item.inputType} item-content`
      }, jsx_default2("input", {
        type: item.inputType,
        name: item.inputName,
        value: itemValue,
        _checked: item.selected
      }), jsx_default2("i", {
        class: `icon icon-${item.inputType}`
      }), jsx_default2("div", {
        class: "item-inner"
      }, jsx_default2("div", {
        class: "item-title"
      }, item.text))));
    }
    if (!item.placeholder) {
      return jsx_default2("li", null, jsx_default2("label", {
        class: "item-radio item-content",
        "data-value": itemValue
      }, jsx_default2("div", {
        class: "item-inner"
      }, jsx_default2("div", {
        class: "item-title"
      }, item.text))));
    }
    return jsx_default2("li", {
      class: "autocomplete-dropdown-placeholder"
    }, jsx_default2("label", {
      class: "item-content"
    }, jsx_default2("div", {
      class: "item-inner"
    }, jsx_default2("div", {
      class: "item-title"
    }, item.text))));
  }
  renderNavbar() {
    const ac = this;
    if (ac.params.renderNavbar)
      return ac.params.renderNavbar.call(ac);
    let pageTitle = ac.params.pageTitle;
    if (typeof pageTitle === "undefined" && ac.$openerEl && ac.$openerEl.length) {
      pageTitle = ac.$openerEl.find(".item-title").text().trim();
    }
    const inPopup = ac.params.openIn === "popup";
    const navbarLeft = inPopup ? ac.params.preloader && jsx_default2("div", {
      class: "left"
    }, ac.renderPreloader()) : jsx_default2("div", {
      class: "left sliding"
    }, jsx_default2("a", {
      class: "link back"
    }, jsx_default2("i", {
      class: "icon icon-back"
    }), jsx_default2("span", {
      class: "if-not-md"
    }, ac.params.pageBackLinkText)));
    const navbarRight = inPopup ? jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link popup-close",
      "data-popup": ".autocomplete-popup"
    }, ac.params.popupCloseLinkText)) : ac.params.preloader && jsx_default2("div", {
      class: "right"
    }, ac.renderPreloader());
    return jsx_default2("div", {
      class: `navbar ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ""}`
    }, jsx_default2("div", {
      class: "navbar-bg"
    }), jsx_default2("div", {
      class: `navbar-inner ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ""}`
    }, navbarLeft, pageTitle && jsx_default2("div", {
      class: "title sliding"
    }, pageTitle), navbarRight, jsx_default2("div", {
      class: "subnavbar sliding"
    }, ac.renderSearchbar())));
  }
  renderDropdown() {
    const ac = this;
    if (ac.params.renderDropdown)
      return ac.params.renderDropdown.call(ac, ac.items);
    return jsx_default2("div", {
      class: "autocomplete-dropdown"
    }, jsx_default2("div", {
      class: "autocomplete-dropdown-inner"
    }, jsx_default2("div", {
      class: `list ${!ac.params.expandInput ? "no-safe-areas" : ""}`
    }, jsx_default2("ul", null))), ac.params.preloader && ac.renderPreloader());
  }
  renderPage(inPopup) {
    const ac = this;
    if (ac.params.renderPage)
      return ac.params.renderPage.call(ac, ac.items);
    return jsx_default2("div", {
      class: "page page-with-subnavbar autocomplete-page",
      "data-name": "autocomplete-page"
    }, ac.renderNavbar(inPopup), jsx_default2("div", {
      class: "searchbar-backdrop"
    }), jsx_default2("div", {
      class: "page-content"
    }, jsx_default2("div", {
      class: `list autocomplete-list autocomplete-found autocomplete-list-${ac.id} ${ac.params.formColorTheme ? `color-${ac.params.formColorTheme}` : ""}`
    }, jsx_default2("ul", null)), jsx_default2("div", {
      class: "list autocomplete-not-found"
    }, jsx_default2("ul", null, jsx_default2("li", {
      class: "item-content"
    }, jsx_default2("div", {
      class: "item-inner"
    }, jsx_default2("div", {
      class: "item-title"
    }, ac.params.notFoundText))))), jsx_default2("div", {
      class: "list autocomplete-values"
    }, jsx_default2("ul", null))));
  }
  renderPopup() {
    const ac = this;
    if (ac.params.renderPopup)
      return ac.params.renderPopup.call(ac, ac.items);
    return jsx_default2("div", {
      class: "popup autocomplete-popup"
    }, jsx_default2("div", {
      class: "view"
    }, ac.renderPage(true), ";"));
  }
  onOpen(type, el) {
    const ac = this;
    const app = ac.app;
    const $el = dom7_default(el);
    ac.$el = $el;
    ac.el = $el[0];
    ac.openedIn = type;
    ac.opened = true;
    if (ac.params.openIn === "dropdown") {
      ac.attachDropdownEvents();
      ac.$dropdownEl.addClass("autocomplete-dropdown-in");
      ac.$inputEl.trigger("input");
    } else {
      let $searchbarEl = $el.find(".searchbar");
      if (ac.params.openIn === "page" && app.theme === "ios" && $searchbarEl.length === 0) {
        $searchbarEl = dom7_default(app.navbar.getElByPage($el)).find(".searchbar");
      }
      ac.searchbar = app.searchbar.create({
        el: $searchbarEl,
        backdropEl: $el.find(".searchbar-backdrop"),
        customSearch: true,
        on: {
          search(sb, query) {
            if (query.length === 0 && ac.searchbar.enabled) {
              ac.searchbar.backdropShow();
            } else {
              ac.searchbar.backdropHide();
            }
            ac.source(query);
          }
        }
      });
      ac.attachPageEvents();
      ac.updateValues();
      if (ac.params.requestSourceOnOpen)
        ac.source("");
    }
    ac.emit("local::open autocompleteOpen", ac);
  }
  autoFocus() {
    const ac = this;
    if (ac.searchbar && ac.searchbar.$inputEl) {
      ac.searchbar.$inputEl.focus();
    }
    return ac;
  }
  onOpened() {
    const ac = this;
    if (ac.params.openIn !== "dropdown" && ac.params.autoFocus) {
      ac.autoFocus();
    }
    ac.emit("local::opened autocompleteOpened", ac);
  }
  onClose() {
    const ac = this;
    if (ac.destroyed)
      return;
    if (ac.searchbar && ac.searchbar.destroy) {
      ac.searchbar.destroy();
      ac.searchbar = null;
      delete ac.searchbar;
    }
    if (ac.params.openIn === "dropdown") {
      ac.detachDropdownEvents();
      ac.$dropdownEl.removeClass("autocomplete-dropdown-in").remove();
      ac.$inputEl.parents(".item-content-dropdown-expanded").removeClass("item-content-dropdown-expanded");
    } else {
      ac.detachPageEvents();
    }
    ac.emit("local::close autocompleteClose", ac);
  }
  onClosed() {
    const ac = this;
    if (ac.destroyed)
      return;
    ac.opened = false;
    ac.$el = null;
    ac.el = null;
    delete ac.$el;
    delete ac.el;
    ac.emit("local::closed autocompleteClosed", ac);
  }
  openPage() {
    const ac = this;
    if (ac.opened)
      return ac;
    const pageHtml = ac.renderPage();
    ac.view.router.navigate({
      url: ac.url,
      route: {
        content: pageHtml,
        path: ac.url,
        on: {
          pageBeforeIn(e, page) {
            ac.onOpen("page", page.el);
          },
          pageAfterIn(e, page) {
            ac.onOpened("page", page.el);
          },
          pageBeforeOut(e, page) {
            ac.onClose("page", page.el);
          },
          pageAfterOut(e, page) {
            ac.onClosed("page", page.el);
          }
        },
        options: {
          animate: ac.params.animate
        }
      }
    });
    return ac;
  }
  openPopup() {
    const ac = this;
    if (ac.opened)
      return ac;
    const popupHtml = ac.renderPopup();
    const popupParams = {
      content: popupHtml,
      animate: ac.params.animate,
      push: ac.params.popupPush,
      swipeToClose: ac.params.popupSwipeToClose,
      on: {
        popupOpen(popup) {
          ac.onOpen("popup", popup.el);
        },
        popupOpened(popup) {
          ac.onOpened("popup", popup.el);
        },
        popupClose(popup) {
          ac.onClose("popup", popup.el);
        },
        popupClosed(popup) {
          ac.onClosed("popup", popup.el);
        }
      }
    };
    if (ac.params.routableModals && ac.view) {
      ac.view.router.navigate({
        url: ac.url,
        route: {
          path: ac.url,
          popup: popupParams
        }
      });
    } else {
      ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
    }
    return ac;
  }
  openDropdown() {
    const ac = this;
    if (!ac.$dropdownEl) {
      ac.$dropdownEl = dom7_default(ac.renderDropdown());
    }
    const $listEl = ac.$inputEl.parents(".list");
    if ($listEl.length && ac.$inputEl.parents(".item-content").length > 0 && ac.params.expandInput) {
      ac.$inputEl.parents(".item-content").addClass("item-content-dropdown-expanded");
    }
    const $pageContentEl = ac.$inputEl.parents(".page-content");
    if (ac.params.dropdownContainerEl) {
      dom7_default(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
    } else if ($pageContentEl.length === 0) {
      ac.$dropdownEl.insertAfter(ac.$inputEl);
    } else {
      ac.positionDropdown();
      $pageContentEl.append(ac.$dropdownEl);
    }
    ac.onOpen("dropdown", ac.$dropdownEl);
    ac.onOpened("dropdown", ac.$dropdownEl);
  }
  open() {
    const ac = this;
    if (ac.opened)
      return ac;
    const openIn = ac.params.openIn;
    ac[`open${openIn.split("").map((el, index2) => {
      if (index2 === 0)
        return el.toUpperCase();
      return el;
    }).join("")}`]();
    return ac;
  }
  close() {
    const ac = this;
    if (!ac.opened)
      return ac;
    if (ac.params.openIn === "dropdown") {
      ac.onClose();
      ac.onClosed();
    } else if (ac.params.routableModals && ac.view || ac.openedIn === "page") {
      ac.view.router.back({
        animate: ac.params.animate
      });
    } else {
      ac.modal.once("modalClosed", () => {
        nextTick(() => {
          if (ac.destroyed)
            return;
          ac.modal.destroy();
          delete ac.modal;
        });
      });
      ac.modal.close();
    }
    return ac;
  }
  init() {
    const ac = this;
    ac.attachEvents();
  }
  destroy() {
    const ac = this;
    ac.emit("local::beforeDestroy autocompleteBeforeDestroy", ac);
    ac.detachEvents();
    if (ac.$inputEl && ac.$inputEl[0]) {
      delete ac.$inputEl[0].f7Autocomplete;
    }
    if (ac.$openerEl && ac.$openerEl[0]) {
      delete ac.$openerEl[0].f7Autocomplete;
    }
    deleteProps(ac);
    ac.destroyed = true;
  }
};
var autocomplete_class_default = Autocomplete;

// node_modules/framework7/components/autocomplete/autocomplete.js
var autocomplete_default = {
  name: "autocomplete",
  params: {
    autocomplete: {
      openerEl: void 0,
      inputEl: void 0,
      view: void 0,
      dropdownContainerEl: void 0,
      dropdownPlaceholderText: void 0,
      typeahead: false,
      highlightMatches: true,
      expandInput: false,
      updateInputValueOnSelect: true,
      inputEvents: "input",
      value: void 0,
      multiple: false,
      source: void 0,
      limit: void 0,
      valueProperty: "id",
      textProperty: "text",
      openIn: "page",
      pageBackLinkText: "Back",
      popupCloseLinkText: "Close",
      pageTitle: void 0,
      searchbarPlaceholder: "Search...",
      searchbarDisableText: "Cancel",
      searchbarDisableButton: void 0,
      searchbarSpellcheck: false,
      popupPush: false,
      popupSwipeToClose: void 0,
      animate: true,
      autoFocus: false,
      closeOnSelect: false,
      notFoundText: "Nothing found",
      requestSourceOnOpen: false,
      preloaderColor: void 0,
      preloader: false,
      formColorTheme: void 0,
      navbarColorTheme: void 0,
      routableModals: false,
      url: "select/",
      renderDropdown: void 0,
      renderPage: void 0,
      renderPopup: void 0,
      renderItem: void 0,
      renderSearchbar: void 0,
      renderNavbar: void 0
    }
  },
  static: {
    Autocomplete: autocomplete_class_default
  },
  create() {
    const app = this;
    app.autocomplete = extend(ConstructorMethods({
      defaultSelector: void 0,
      constructor: autocomplete_class_default,
      app,
      domProp: "f7Autocomplete"
    }), {
      open(autocompleteEl) {
        const ac = app.autocomplete.get(autocompleteEl);
        if (ac && ac.open)
          return ac.open();
        return void 0;
      },
      close(autocompleteEl) {
        const ac = app.autocomplete.get(autocompleteEl);
        if (ac && ac.close)
          return ac.close();
        return void 0;
      }
    });
  }
};

// node_modules/framework7/components/tooltip/tooltip-class.js
var Tooltip = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const tooltip = this;
    const support2 = getSupport();
    const defaults = extend({}, app.params.tooltip);
    const document = getDocument();
    tooltip.useModulesParams(defaults);
    tooltip.params = extend(defaults, params);
    if (typeof params.offset === "undefined" && support2.touch && tooltip.params.trigger === "hover") {
      tooltip.params.offset = 10;
    }
    const {
      targetEl,
      containerEl
    } = tooltip.params;
    if (!targetEl && !tooltip.params.delegated)
      return tooltip;
    const $targetEl = dom7_default(targetEl);
    if ($targetEl.length === 0 && !tooltip.params.delegated)
      return tooltip;
    if ($targetEl[0] && $targetEl[0].f7Tooltip && !tooltip.params.delegated)
      return $targetEl[0].f7Tooltip;
    let $containerEl = dom7_default(containerEl || app.$el).eq(0);
    if ($containerEl.length === 0) {
      $containerEl = app.$el;
    }
    const $el = dom7_default(tooltip.render()).eq(0);
    extend(tooltip, {
      app,
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      $el,
      el: $el && $el[0],
      text: tooltip.params.text || "",
      visible: false,
      opened: false
    });
    if ($targetEl[0])
      $targetEl[0].f7Tooltip = tooltip;
    const touchesStart = {};
    let isTouched;
    function handleClick() {
      if (tooltip.opened)
        tooltip.hide();
      else
        tooltip.show(this);
    }
    function handleClickOut(e) {
      if (tooltip.opened && (dom7_default(e.target).closest($targetEl).length || dom7_default(e.target).closest(tooltip.$el).length))
        return;
      tooltip.hide();
    }
    function handleTouchStart(e) {
      if (isTouched)
        return;
      isTouched = true;
      touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      tooltip.show(this);
    }
    function handleTouchMove(e) {
      if (!isTouched)
        return;
      const x = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      const y = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      const distance = ((x - touchesStart.x) ** 2 + (y - touchesStart.y) ** 2) ** 0.5;
      if (distance > 50) {
        isTouched = false;
        tooltip.hide();
      }
    }
    function handleTouchEnd() {
      if (!isTouched)
        return;
      isTouched = false;
      tooltip.hide();
    }
    function handleMouseEnter() {
      tooltip.show(this);
    }
    function handleMouseLeave() {
      tooltip.hide();
    }
    function handleTransitionEnd() {
      if (!$el.hasClass("tooltip-in")) {
        $el.removeClass("tooltip-out").remove();
      }
    }
    tooltip.attachEvents = function attachEvents2() {
      $el.on("transitionend", handleTransitionEnd);
      if (tooltip.params.trigger === "click") {
        if (tooltip.params.delegated) {
          dom7_default(document).on("click", tooltip.params.targetEl, handleClick);
        } else {
          tooltip.$targetEl.on("click", handleClick);
        }
        dom7_default("html").on("click", handleClickOut);
        return;
      }
      if (tooltip.params.trigger === "manual")
        return;
      if (support2.touch) {
        const passive = support2.passiveListener ? {
          passive: true
        } : false;
        if (tooltip.params.delegated) {
          dom7_default(document).on(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
        } else {
          tooltip.$targetEl.on(app.touchEvents.start, handleTouchStart, passive);
        }
        app.on("touchmove", handleTouchMove);
        app.on("touchend:passive", handleTouchEnd);
      } else {
        if (tooltip.params.delegated) {
          dom7_default(document).on(support2.pointerEvents ? "pointerenter" : "mouseenter", tooltip.params.targetEl, handleMouseEnter, true);
          dom7_default(document).on(support2.pointerEvents ? "pointerleave" : "mouseleave", tooltip.params.targetEl, handleMouseLeave, true);
        } else {
          tooltip.$targetEl.on(support2.pointerEvents ? "pointerenter" : "mouseenter", handleMouseEnter);
          tooltip.$targetEl.on(support2.pointerEvents ? "pointerleave" : "mouseleave", handleMouseLeave);
        }
      }
    };
    tooltip.detachEvents = function detachEvents2() {
      $el.off("transitionend", handleTransitionEnd);
      if (tooltip.params.trigger === "click") {
        if (tooltip.params.delegated) {
          dom7_default(document).on("click", tooltip.params.targetEl, handleClick);
        } else {
          tooltip.$targetEl.off("click", handleClick);
        }
        dom7_default("html").off("click", handleClickOut);
        return;
      }
      if (tooltip.params.trigger === "manual")
        return;
      if (support2.touch) {
        const passive = support2.passiveListener ? {
          passive: true
        } : false;
        if (tooltip.params.delegated) {
          dom7_default(document).off(app.touchEvents.start, tooltip.params.targetEl, handleTouchStart, passive);
        } else {
          tooltip.$targetEl.off(app.touchEvents.start, handleTouchStart, passive);
        }
        app.off("touchmove", handleTouchMove);
        app.off("touchend:passive", handleTouchEnd);
      } else {
        if (tooltip.params.delegated) {
          dom7_default(document).off(support2.pointerEvents ? "pointerenter" : "mouseenter", tooltip.params.targetEl, handleMouseEnter, true);
          dom7_default(document).off(support2.pointerEvents ? "pointerleave" : "mouseleave", tooltip.params.targetEl, handleMouseLeave, true);
        } else {
          tooltip.$targetEl.off(support2.pointerEvents ? "pointerenter" : "mouseenter", handleMouseEnter);
          tooltip.$targetEl.off(support2.pointerEvents ? "pointerleave" : "mouseleave", handleMouseLeave);
        }
      }
    };
    tooltip.useModules();
    tooltip.init();
    return tooltip;
  }
  setTargetEl(targetEl) {
    const tooltip = this;
    tooltip.detachEvents();
    tooltip.$targetEl = dom7_default(targetEl);
    tooltip.targetEl = tooltip.$targetEl[0];
    tooltip.attachEvents();
    return tooltip;
  }
  position(targetEl) {
    const tooltip = this;
    const {
      $el,
      app,
      $containerEl
    } = tooltip;
    const hasContainerEl = !!tooltip.params.containerEl;
    const tooltipOffset = tooltip.params.offset || 0;
    $el.css({
      left: "",
      top: ""
    });
    const $targetEl = dom7_default(targetEl || tooltip.targetEl);
    const [width, height] = [$el.width(), $el.height()];
    $el.css({
      left: "",
      top: ""
    });
    let targetWidth;
    let targetHeight;
    let targetOffsetLeft;
    let targetOffsetTop;
    const boundaries = hasContainerEl && $containerEl.length ? $containerEl[0].getBoundingClientRect() : app;
    if ($targetEl && $targetEl.length > 0) {
      targetWidth = $targetEl.outerWidth();
      targetHeight = $targetEl.outerHeight();
      if (typeof targetWidth === "undefined" && typeof targetHeight === "undefined") {
        const clientRect = $targetEl[0].getBoundingClientRect();
        targetWidth = clientRect.width;
        targetHeight = clientRect.height;
      }
      const targetOffset = $targetEl.offset();
      targetOffsetLeft = targetOffset.left - boundaries.left;
      targetOffsetTop = targetOffset.top - boundaries.top;
      const targetParentPage = $targetEl.parents(".page");
      if (targetParentPage.length > 0) {
        targetOffsetTop -= targetParentPage[0].scrollTop;
      }
    }
    let [left, top] = [0, 0, 0];
    let position = "top";
    if (height + tooltipOffset < targetOffsetTop) {
      top = targetOffsetTop - height - tooltipOffset;
    } else if (height < boundaries.height - targetOffsetTop - targetHeight) {
      position = "bottom";
      top = targetOffsetTop + targetHeight + tooltipOffset;
    } else {
      position = "middle";
      top = targetHeight / 2 + targetOffsetTop - height / 2;
      if (top <= 0) {
        top = 8;
      } else if (top + height >= boundaries.height) {
        top = boundaries.height - height - 8;
      }
    }
    if (position === "top" || position === "bottom") {
      left = targetWidth / 2 + targetOffsetLeft - width / 2;
      if (left < 8)
        left = 8;
      if (left + width > boundaries.width)
        left = boundaries.width - width - 8;
      if (left < 0)
        left = 0;
    } else if (position === "middle") {
      left = targetOffsetLeft - width;
      if (left < 8 || left + width > boundaries.width) {
        if (left < 8)
          left = targetOffsetLeft + targetWidth;
        if (left + width > boundaries.width)
          left = boundaries.width - width - 8;
      }
    }
    $el.css({
      top: `${top}px`,
      left: `${left}px`
    });
  }
  show(aroundEl) {
    const tooltip = this;
    const {
      $el,
      $targetEl,
      $containerEl
    } = tooltip;
    if ($containerEl[0] && $el[0] && !$containerEl[0].contains($el[0])) {
      $containerEl.append($el);
    }
    tooltip.position(aroundEl);
    const $aroundEl = dom7_default(aroundEl);
    tooltip.visible = true;
    tooltip.opened = true;
    $targetEl.trigger("tooltip:show");
    $el.trigger("tooltip:show");
    if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
      $aroundEl.trigger("tooltip:show");
    }
    tooltip.emit("local::show tooltipShow", tooltip);
    $el.removeClass("tooltip-out").addClass("tooltip-in");
    return tooltip;
  }
  hide() {
    const tooltip = this;
    const {
      $el,
      $targetEl
    } = tooltip;
    tooltip.visible = false;
    tooltip.opened = false;
    $targetEl.trigger("tooltip:hide");
    $el.trigger("tooltip:hide");
    tooltip.emit("local::hide tooltipHide", tooltip);
    $el.addClass("tooltip-out").removeClass("tooltip-in");
    return tooltip;
  }
  render() {
    const tooltip = this;
    if (tooltip.params.render)
      return tooltip.params.render.call(tooltip, tooltip);
    const {
      cssClass,
      text: text2
    } = tooltip.params;
    return `
      <div class="tooltip ${cssClass || ""}">
        <div class="tooltip-content">${text2 || ""}</div>
      </div>
    `.trim();
  }
  setText(newText) {
    const tooltip = this;
    if (typeof newText === "undefined") {
      return tooltip;
    }
    tooltip.params.text = newText;
    tooltip.text = newText;
    if (tooltip.$el) {
      tooltip.$el.children(".tooltip-content").html(newText);
    }
    if (tooltip.opened) {
      tooltip.position();
    }
    return tooltip;
  }
  init() {
    const tooltip = this;
    tooltip.attachEvents();
  }
  destroy() {
    const tooltip = this;
    if (!tooltip.$targetEl || tooltip.destroyed)
      return;
    tooltip.$targetEl.trigger("tooltip:beforedestroy");
    tooltip.emit("local::beforeDestroy tooltipBeforeDestroy", tooltip);
    tooltip.$el.remove();
    if (tooltip.$targetEl[0])
      delete tooltip.$targetEl[0].f7Tooltip;
    tooltip.detachEvents();
    deleteProps(tooltip);
    tooltip.destroyed = true;
  }
};
var tooltip_class_default = Tooltip;

// node_modules/framework7/components/tooltip/tooltip.js
var tooltip_default = {
  name: "tooltip",
  static: {
    Tooltip: tooltip_class_default
  },
  create() {
    const app = this;
    app.tooltip = ConstructorMethods({
      defaultSelector: ".tooltip",
      constructor: tooltip_class_default,
      app,
      domProp: "f7Tooltip"
    });
    app.tooltip.show = function show(el) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip)
        return void 0;
      tooltip.show($el[0]);
      return tooltip;
    };
    app.tooltip.hide = function hide(el) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip)
        return void 0;
      tooltip.hide();
      return tooltip;
    };
    app.tooltip.setText = function text2(el, newText) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const tooltip = $el[0].f7Tooltip;
      if (!tooltip)
        return void 0;
      tooltip.setText(newText);
      return tooltip;
    };
  },
  params: {
    tooltip: {
      targetEl: null,
      delegated: false,
      text: null,
      cssClass: null,
      render: null,
      offset: 0,
      trigger: "hover",
      containerEl: void 0
    }
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".tooltip-init").each((el) => {
        const text2 = dom7_default(el).attr("data-tooltip");
        if (!text2)
          return;
        app.tooltip.create({
          targetEl: el,
          text: text2
        });
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".tooltip-init").each((el) => {
        if (el.f7Tooltip)
          el.f7Tooltip.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".tooltip-init").each((el) => {
        const text2 = dom7_default(el).attr("data-tooltip");
        if (!text2)
          return;
        app.tooltip.create({
          targetEl: el,
          text: text2
        });
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".tooltip-init").each((el) => {
          const text2 = dom7_default(el).attr("data-tooltip");
          if (!text2)
            return;
          app.tooltip.create({
            targetEl: el,
            text: text2
          });
        });
      }
    },
    pageBeforeRemove(page) {
      const app = this;
      page.$el.find(".tooltip-init").each((el) => {
        if (el.f7Tooltip)
          el.f7Tooltip.destroy();
      });
      if (app.theme === "ios" && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
        page.$navbarEl.find(".tooltip-init").each((el) => {
          if (el.f7Tooltip)
            el.f7Tooltip.destroy();
        });
      }
    }
  },
  vnode: {
    "tooltip-init": {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        const text2 = dom7_default(el).attr("data-tooltip");
        if (!text2)
          return;
        app.tooltip.create({
          targetEl: el,
          text: text2
        });
      },
      update(vnode) {
        const el = vnode.elm;
        if (!el.f7Tooltip)
          return;
        if (vnode && vnode.data && vnode.data.attrs && vnode.data.attrs["data-tooltip"]) {
          el.f7Tooltip.setText(vnode.data.attrs["data-tooltip"]);
        }
      },
      destroy(vnode) {
        const el = vnode.elm;
        if (el.f7Tooltip)
          el.f7Tooltip.destroy();
      }
    }
  }
};

// node_modules/framework7/components/gauge/gauge-class.js
var Gauge = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const self = this;
    const defaults = extend({}, app.params.gauge);
    self.useModulesParams(defaults);
    self.params = extend(defaults, params);
    const {
      el
    } = self.params;
    if (!el)
      return self;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return self;
    if ($el[0].f7Gauge)
      return $el[0].f7Gauge;
    extend(self, {
      app,
      $el,
      el: $el && $el[0]
    });
    $el[0].f7Gauge = self;
    self.useModules();
    self.init();
    return self;
  }
  calcRadius() {
    const self = this;
    const {
      size,
      borderWidth
    } = self.params;
    return size / 2 - borderWidth / 2;
  }
  calcBorderLength() {
    const self = this;
    const radius = self.calcRadius();
    return 2 * Math.PI * radius;
  }
  render() {
    const self = this;
    if (self.params.render)
      return self.params.render.call(self, self);
    const {
      type,
      value,
      size,
      bgColor,
      borderBgColor,
      borderColor,
      borderWidth,
      valueText,
      valueTextColor,
      valueFontSize,
      valueFontWeight,
      labelText,
      labelTextColor,
      labelFontSize,
      labelFontWeight
    } = self.params;
    const semiCircle = type === "semicircle";
    const radius = self.calcRadius();
    const length = self.calcBorderLength();
    const progress = Math.max(Math.min(value, 1), 0);
    return jsx_default2("svg", {
      class: "gauge-svg",
      width: `${size}px`,
      height: `${semiCircle ? size / 2 : size}px`,
      viewBox: `0 0 ${size} ${semiCircle ? size / 2 : size}`
    }, semiCircle && jsx_default2("path", {
      class: "gauge-back-semi",
      d: `M${size - borderWidth / 2},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
      stroke: borderBgColor,
      "stroke-width": borderWidth,
      fill: bgColor || "none"
    }), semiCircle && jsx_default2("path", {
      class: "gauge-front-semi",
      d: `M${size - borderWidth / 2},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
      stroke: borderColor,
      "stroke-width": borderWidth,
      "stroke-dasharray": length / 2,
      "stroke-dashoffset": length / 2 * (1 + progress),
      fill: borderBgColor ? "none" : bgColor || "none"
    }), !semiCircle && borderBgColor && jsx_default2("circle", {
      class: "gauge-back-circle",
      stroke: borderBgColor,
      "stroke-width": borderWidth,
      fill: bgColor || "none",
      cx: size / 2,
      cy: size / 2,
      r: radius
    }), !semiCircle && jsx_default2("circle", {
      class: "gauge-front-circle",
      transform: `rotate(-90 ${size / 2} ${size / 2})`,
      stroke: borderColor,
      "stroke-width": borderWidth,
      "stroke-dasharray": length,
      "stroke-dashoffset": length * (1 - progress),
      fill: borderBgColor ? "none" : bgColor || "none",
      cx: size / 2,
      cy: size / 2,
      r: radius
    }), valueText && jsx_default2("text", {
      class: "gauge-value-text",
      x: "50%",
      y: semiCircle ? "100%" : "50%",
      "font-weight": valueFontWeight,
      "font-size": valueFontSize,
      fill: valueTextColor,
      dy: semiCircle ? labelText ? -labelFontSize - 15 : -5 : 0,
      "text-anchor": "middle",
      "dominant-baseline": !semiCircle && "middle"
    }, valueText), labelText && jsx_default2("text", {
      class: "gauge-label-text",
      x: "50%",
      y: semiCircle ? "100%" : "50%",
      "font-weight": labelFontWeight,
      "font-size": labelFontSize,
      fill: labelTextColor,
      dy: semiCircle ? -5 : valueText ? valueFontSize / 2 + 10 : 0,
      "text-anchor": "middle",
      "dominant-baseline": !semiCircle && "middle"
    }, labelText));
  }
  update(newParams) {
    if (newParams === void 0) {
      newParams = {};
    }
    const self = this;
    const document = getDocument();
    const {
      params,
      $svgEl
    } = self;
    Object.keys(newParams).forEach((param) => {
      if (typeof newParams[param] !== "undefined") {
        params[param] = newParams[param];
      }
    });
    if ($svgEl.length === 0)
      return self;
    const {
      value,
      size,
      bgColor,
      borderBgColor,
      borderColor,
      borderWidth,
      valueText,
      valueTextColor,
      valueFontSize,
      valueFontWeight,
      labelText,
      labelTextColor,
      labelFontSize,
      labelFontWeight
    } = params;
    const length = self.calcBorderLength();
    const progress = Math.max(Math.min(value, 1), 0);
    const radius = self.calcRadius();
    const semiCircle = params.type === "semicircle";
    const svgAttrs = {
      width: `${size}px`,
      height: `${semiCircle ? size / 2 : size}px`,
      viewBox: `0 0 ${size} ${semiCircle ? size / 2 : size}`
    };
    Object.keys(svgAttrs).forEach((attr2) => {
      $svgEl.attr(attr2, svgAttrs[attr2]);
    });
    if (semiCircle) {
      const backAttrs = {
        d: `M${size - borderWidth / 2},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
        stroke: borderBgColor,
        "stroke-width": borderWidth,
        fill: bgColor || "none"
      };
      const frontAttrs = {
        d: `M${size - borderWidth / 2},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
        stroke: borderColor,
        "stroke-width": borderWidth,
        "stroke-dasharray": length / 2,
        "stroke-dashoffset": length / 2 * (1 + progress),
        fill: borderBgColor ? "none" : bgColor || "none"
      };
      Object.keys(backAttrs).forEach((attr2) => {
        $svgEl.find(".gauge-back-semi").attr(attr2, backAttrs[attr2]);
      });
      Object.keys(frontAttrs).forEach((attr2) => {
        $svgEl.find(".gauge-front-semi").attr(attr2, frontAttrs[attr2]);
      });
    } else {
      const backAttrs = {
        stroke: borderBgColor,
        "stroke-width": borderWidth,
        fill: bgColor || "none",
        cx: size / 2,
        cy: size / 2,
        r: radius
      };
      const frontAttrs = {
        transform: `rotate(-90 ${size / 2} ${size / 2})`,
        stroke: borderColor,
        "stroke-width": borderWidth,
        "stroke-dasharray": length,
        "stroke-dashoffset": length * (1 - progress),
        fill: borderBgColor ? "none" : bgColor || "none",
        cx: size / 2,
        cy: size / 2,
        r: radius
      };
      Object.keys(backAttrs).forEach((attr2) => {
        $svgEl.find(".gauge-back-circle").attr(attr2, backAttrs[attr2]);
      });
      Object.keys(frontAttrs).forEach((attr2) => {
        $svgEl.find(".gauge-front-circle").attr(attr2, frontAttrs[attr2]);
      });
    }
    if (valueText) {
      if (!$svgEl.find(".gauge-value-text").length) {
        const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textEl.classList.add("gauge-value-text");
        $svgEl.append(textEl);
      }
      const textAttrs = {
        x: "50%",
        y: semiCircle ? "100%" : "50%",
        "font-weight": valueFontWeight,
        "font-size": valueFontSize,
        fill: valueTextColor,
        dy: semiCircle ? labelText ? -labelFontSize - 15 : -5 : 0,
        "text-anchor": "middle",
        "dominant-baseline": !semiCircle && "middle"
      };
      Object.keys(textAttrs).forEach((attr2) => {
        $svgEl.find(".gauge-value-text").attr(attr2, textAttrs[attr2]);
      });
      $svgEl.find(".gauge-value-text").text(valueText);
    } else {
      $svgEl.find(".gauge-value-text").remove();
    }
    if (labelText) {
      if (!$svgEl.find(".gauge-label-text").length) {
        const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
        textEl.classList.add("gauge-label-text");
        $svgEl.append(textEl);
      }
      const labelAttrs = {
        x: "50%",
        y: semiCircle ? "100%" : "50%",
        "font-weight": labelFontWeight,
        "font-size": labelFontSize,
        fill: labelTextColor,
        dy: semiCircle ? -5 : valueText ? valueFontSize / 2 + 10 : 0,
        "text-anchor": "middle",
        "dominant-baseline": !semiCircle && "middle"
      };
      Object.keys(labelAttrs).forEach((attr2) => {
        $svgEl.find(".gauge-label-text").attr(attr2, labelAttrs[attr2]);
      });
      $svgEl.find(".gauge-label-text").text(labelText);
    } else {
      $svgEl.find(".gauge-label-text").remove();
    }
    return self;
  }
  init() {
    const self = this;
    const $svgEl = dom7_default(self.render()).eq(0);
    $svgEl.f7Gauge = self;
    extend(self, {
      $svgEl,
      svgEl: $svgEl && $svgEl[0]
    });
    self.$el.append($svgEl);
    return self;
  }
  destroy() {
    const self = this;
    if (!self.$el || self.destroyed)
      return;
    self.$el.trigger("gauge:beforedestroy");
    self.emit("local::beforeDestroy gaugeBeforeDestroy", self);
    self.$svgEl.remove();
    delete self.$el[0].f7Gauge;
    deleteProps(self);
    self.destroyed = true;
  }
};
var gauge_class_default = Gauge;

// node_modules/framework7/components/gauge/gauge.js
var gauge_default = {
  name: "gauge",
  static: {
    Gauge: gauge_class_default
  },
  create() {
    const app = this;
    app.gauge = ConstructorMethods({
      defaultSelector: ".gauge",
      constructor: gauge_class_default,
      app,
      domProp: "f7Gauge"
    });
    app.gauge.update = function update(el, newParams) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const gauge = app.gauge.get(el);
      if (!gauge)
        return void 0;
      gauge.update(newParams);
      return gauge;
    };
  },
  params: {
    gauge: {
      el: null,
      type: "circle",
      value: 0,
      size: 200,
      bgColor: "transparent",
      borderBgColor: "#eeeeee",
      borderColor: "#000000",
      borderWidth: 10,
      valueText: null,
      valueTextColor: "#000000",
      valueFontSize: 31,
      valueFontWeight: 500,
      labelText: null,
      labelTextColor: "#888888",
      labelFontSize: 14,
      labelFontWeight: 400
    }
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".gauge-init").each((el) => {
        app.gauge.create(extend({
          el
        }, dom7_default(el).dataset() || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".gauge-init").each((el) => {
        if (el.f7Gauge)
          el.f7Gauge.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".gauge-init").each((el) => {
        app.gauge.create(extend({
          el
        }, dom7_default(el).dataset() || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".gauge-init").each((el) => {
        if (el.f7Gauge)
          el.f7Gauge.destroy();
      });
    }
  },
  vnode: {
    "gauge-init": {
      insert(vnode) {
        const app = this;
        const el = vnode.elm;
        app.gauge.create(extend({
          el
        }, dom7_default(el).dataset() || {}));
      },
      destroy(vnode) {
        const el = vnode.elm;
        if (el.f7Gauge)
          el.f7Gauge.destroy();
      }
    }
  }
};

// node_modules/framework7/components/skeleton/skeleton.js
var skeleton_default = {
  name: "skeleton"
};

// node_modules/framework7/components/menu/menu.js
var Menu = {
  open(el) {
    if (el === void 0) {
      el = ".menu-item-dropdown";
    }
    const app = this;
    if (!el)
      return;
    const $el = dom7_default(el).closest(".menu-item-dropdown");
    if (!$el.length)
      return;
    const $menuEl = $el.closest(".menu").eq(0);
    if ($menuEl.length) {
      const zIndex = $menuEl.css("z-index");
      const originalZIndex = $menuEl[0].style.zIndex;
      $menuEl.css("z-index", parseInt(zIndex || 0, 10) + 1);
      $menuEl[0].f7MenuZIndex = originalZIndex;
    }
    $el.eq(0).addClass("menu-item-dropdown-opened").trigger("menu:opened");
    app.emit("menuOpened", $el.eq(0)[0]);
  },
  close(el) {
    if (el === void 0) {
      el = ".menu-item-dropdown-opened";
    }
    const app = this;
    if (!el)
      return;
    const $el = dom7_default(el).closest(".menu-item-dropdown-opened");
    if (!$el.length)
      return;
    const $menuEl = $el.closest(".menu").eq(0);
    if ($menuEl.length) {
      const zIndex = $menuEl[0].f7MenuZIndex;
      $menuEl.css("z-index", zIndex);
      delete $menuEl[0].f7MenuZIndex;
    }
    $el.eq(0).removeClass("menu-item-dropdown-opened").trigger("menu:closed");
    app.emit("menuClosed", $el.eq(0)[0]);
  }
};
var menu_default = {
  name: "menu",
  create() {
    const app = this;
    bindMethods(app, {
      menu: Menu
    });
  },
  on: {
    click(e) {
      const app = this;
      const openedMenus = dom7_default(".menu-item-dropdown-opened");
      if (!openedMenus.length)
        return;
      openedMenus.each((el) => {
        if (!dom7_default(e.target).closest(".menu-item-dropdown-opened").length) {
          app.menu.close(el);
        }
      });
    }
  },
  clicks: {
    ".menu-item-dropdown": function onClick2($clickedEl, dataset, e) {
      const app = this;
      if ($clickedEl.hasClass("menu-item-dropdown-opened")) {
        if (dom7_default(e.target).closest(".menu-dropdown").length)
          return;
        app.menu.close($clickedEl);
      } else {
        app.menu.open($clickedEl);
      }
    },
    ".menu-close": function onClick3() {
      const app = this;
      app.menu.close();
    }
  }
};

// node_modules/framework7/components/color-picker/modules/alpha-slider.js
var alpha_slider_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      alphaLabelText
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-alpha-slider"
    }, jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, alphaLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-alpha"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "0.01",
      min: "0",
      max: "1",
      class: "color-picker-value-alpha"
    }) : jsx_default2("span", {
      class: "color-picker-value-alpha"
    }))));
  },
  init(self) {
    self.alphaRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-alpha"),
      min: 0,
      max: 1,
      step: 0.01,
      value: 1,
      on: {
        change(range, value) {
          const alpha = Math.floor(value * 100) / 100;
          self.setValue({
            alpha
          });
        }
      }
    });
    function handleInputChange(e) {
      const alpha = self.value.alpha;
      let value = parseFloat(e.target.value);
      if (Number.isNaN(value)) {
        e.target.value = alpha;
        return;
      }
      value = Math.max(0, Math.min(1, value));
      self.setValue({
        alpha: value
      });
    }
    self.$el.on("change", ".color-picker-module-alpha-slider input", handleInputChange);
    self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
      self.$el.off("change", ".color-picker-module-alpha-slider input", handleInputChange);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      alpha
    } = value;
    self.alphaRangeSlider.value = alpha;
    self.alphaRangeSlider.layout();
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-alpha").val(alpha);
    } else {
      self.$el.find("span.color-picker-value-alpha").text(alpha);
    }
  },
  destroy(self) {
    if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
      self.alphaRangeSlider.destroy();
    }
    delete self.alphaRangeSlider;
    if (self.destroyAlphaSliderEvents)
      self.destroyAlphaSliderEvents();
    delete self.destroyAlphaSliderEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/current-color.js
var current_color_default = {
  render() {
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-current-color"
    }, jsx_default2("div", {
      class: "color-picker-current-color"
    }));
  },
  update(self) {
    self.$el.find(".color-picker-module-current-color .color-picker-current-color").css("background-color", self.value.hex);
  }
};

// node_modules/framework7/components/color-picker/modules/hex.js
var hex_default = {
  render(self) {
    const {
      hexLabel,
      hexLabelText,
      hexValueEditable
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-hex"
    }, jsx_default2("div", {
      class: "color-picker-hex-wrap"
    }, hexLabel && jsx_default2("div", {
      class: "color-picker-hex-label"
    }, hexLabelText), jsx_default2("div", {
      class: "color-picker-hex-value"
    }, hexValueEditable ? jsx_default2("input", {
      type: "text",
      class: "color-picker-value-hex"
    }) : jsx_default2("span", {
      class: "color-picker-value-hex"
    }))));
  },
  init(self) {
    function handleInputChange(e) {
      const hex = self.value.hex;
      let value = e.target.value.replace(/#/g, "");
      if (Number.isNaN(value) || !value || value.length !== 3 && value.length !== 6) {
        e.target.value = hex;
        return;
      }
      const min = 0;
      const current = parseInt(value, 16);
      const max = parseInt("ffffff", 16);
      if (current > max) {
        value = "fff";
      }
      if (current < min) {
        value = "000";
      }
      self.setValue({
        hex: value
      });
    }
    self.$el.on("change", ".color-picker-module-hex input", handleInputChange);
    self.destroyHexEvents = function destroyHexEvents() {
      self.$el.off("change", ".color-picker-module-hex input", handleInputChange);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hexValueEditable
    } = self.params;
    const {
      hex
    } = value;
    if (hexValueEditable) {
      self.$el.find("input.color-picker-value-hex").val(hex);
    } else {
      self.$el.find("span.color-picker-value-hex").text(hex);
    }
  },
  destroy(self) {
    if (self.destroyHexEvents)
      self.destroyHexEvents();
    delete self.destroyHexEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/hsb-sliders.js
var hsb_sliders_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      hueLabelText,
      saturationLabelText,
      brightnessLabelText
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-hsb-sliders"
    }, jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, hueLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-hue"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "360",
      class: "color-picker-value-hue",
      "data-color-index": "0"
    }) : jsx_default2("span", {
      class: "color-picker-value-hue"
    }))), jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, saturationLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-saturation"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-saturation",
      "data-color-index": "1"
    }) : jsx_default2("span", {
      class: "color-picker-value-saturation"
    }))), jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, brightnessLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-brightness"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-brightness",
      "data-color-index": "2"
    }) : jsx_default2("span", {
      class: "color-picker-value-brightness"
    }))));
  },
  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-hue"),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            hue: value
          });
        }
      }
    });
    self.saturationRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-saturation"),
      min: 0,
      max: 1,
      step: 1e-3,
      value: 0,
      on: {
        change(range, value) {
          const s = Math.floor(value * 1e3) / 1e3;
          self.setValue({
            hsb: [self.value.hsb[0], s, self.value.hsb[2]]
          });
        }
      }
    });
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-brightness"),
      min: 0,
      max: 1,
      step: 1e-3,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1e3) / 1e3;
          self.setValue({
            hsb: [self.value.hsb[0], self.value.hsb[1], b]
          });
        }
      }
    });
    function handleInputChange(e) {
      const hsb = [...self.value.hsb];
      const index2 = parseInt(dom7_default(e.target).attr("data-color-index"), 10);
      let value = parseFloat(e.target.value);
      if (Number.isNaN(value)) {
        e.target.value = hsb[index2];
        return;
      }
      if (index2 === 0) {
        value = Math.max(0, Math.min(360, value));
      } else {
        value = Math.max(0, Math.min(100, value)) / 100;
      }
      hsb[index2] = value;
      self.setValue({
        hsb
      });
    }
    self.$el.on("change", ".color-picker-module-hsb-sliders input", handleInputChange);
    self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
      self.$el.off("change", ".color-picker-module-hsb-sliders input", handleInputChange);
    };
  },
  update(self) {
    const {
      app,
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hsb,
      hue
    } = value;
    self.hueRangeSlider.value = hue;
    self.saturationRangeSlider.value = hsb[1];
    self.brightnessRangeSlider.value = hsb[2];
    self.hueRangeSlider.layout();
    self.saturationRangeSlider.layout();
    self.brightnessRangeSlider.layout();
    const hslCurrent = colorHsbToHsl(hsb[0], hsb[1], 1);
    const hslLeft = colorHsbToHsl(hsb[0], 0, 1);
    const hslRight = colorHsbToHsl(hsb[0], 1, 1);
    const brightness = hsb[2];
    self.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hue}, 100%, 50%)`);
    self.saturationRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`);
    self.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${brightness * 255}, ${brightness * 255}, ${brightness * 255})`);
    self.saturationRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${app.rtl ? "to left" : "to right"}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-hue").val(`${hue}`);
      self.$el.find("input.color-picker-value-saturation").val(`${hsb[1] * 1e3 / 10}`);
      self.$el.find("input.color-picker-value-brightness").val(`${hsb[2] * 1e3 / 10}`);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-hue").text(`${hue}`);
      self.$el.find("span.color-picker-value-saturation").text(`${hsb[1] * 1e3 / 10}`);
      self.$el.find("span.color-picker-value-brightness").text(`${hsb[2] * 1e3 / 10}`);
    }
  },
  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }
    if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
      self.saturationRangeSlider.destroy();
    }
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }
    delete self.hueRangeSlider;
    delete self.saturationRangeSlider;
    delete self.brightnessRangeSlider;
    if (self.destroyHsbSlidersEvents)
      self.destroyHsbSlidersEvents();
    delete self.destroyHsbSlidersEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/hue-slider.js
var hue_slider_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      hueLabelText
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-hue-slider"
    }, jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, hueLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-hue"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "360",
      class: "color-picker-value-hue"
    }) : jsx_default2("span", {
      class: "color-picker-value-hue"
    }))));
  },
  init(self) {
    self.hueRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-hue"),
      min: 0,
      max: 360,
      step: 0.1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            hue: value
          });
        }
      }
    });
  },
  update(self) {
    const {
      value
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hue
    } = value;
    self.hueRangeSlider.value = hue;
    self.hueRangeSlider.layout();
    self.hueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hue}, 100%, 50%)`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-hue").val(`${hue}`);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-hue").text(`${hue}`);
    }
  },
  destroy(self) {
    if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
      self.hueRangeSlider.destroy();
    }
    delete self.hueRangeSlider;
  }
};

// node_modules/framework7/components/color-picker/modules/brightness-slider.js
var brightness_slider_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      brightnessLabelText
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-brightness-slider"
    }, jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, brightnessLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-brightness"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "0.1",
      min: "0",
      max: "100",
      class: "color-picker-value-brightness"
    }) : jsx_default2("span", {
      class: "color-picker-value-brightness"
    }))));
  },
  init(self) {
    self.brightnessRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-brightness"),
      min: 0,
      max: 1,
      step: 1e-3,
      value: 0,
      on: {
        change(range, value) {
          const b = Math.floor(value * 1e3) / 1e3;
          self.setValue({
            hsb: [self.value.hsb[0], self.value.hsb[1], b]
          });
        }
      }
    });
  },
  update(self) {
    const {
      value,
      app
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      hsb
    } = value;
    self.brightnessRangeSlider.value = hsb[2];
    self.brightnessRangeSlider.layout();
    const hslCurrent = colorHsbToHsl(hsb[0], hsb[1], hsb[2]);
    const hslLeft = colorHsbToHsl(hsb[0], hsb[1], 0);
    const hslRight = colorHsbToHsl(hsb[0], hsb[1], 1);
    self.brightnessRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`);
    self.brightnessRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${app.rtl ? "to left" : "to right"}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-brightness").val(`${hsb[2] * 1e3 / 10}`);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-brightness").text(`${hsb[2] * 1e3 / 10}`);
    }
  },
  destroy(self) {
    if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
      self.brightnessRangeSlider.destroy();
    }
    delete self.brightnessRangeSlider;
  }
};

// node_modules/framework7/components/color-picker/modules/palette.js
var palette_default = {
  render(self) {
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-palette"
    }, jsx_default2("div", {
      class: "color-picker-palette"
    }, self.params.palette.map((p) => {
      if (Array.isArray(p)) {
        let row = '<div class="color-picker-palette-row">';
        row += p.map((c) => `
                <div class="color-picker-palette-value" data-palette-color="${c}" style="background-color: ${c}"></div>
              `).join("");
        row += "</div>";
        return row;
      }
      return jsx_default2("div", {
        class: "color-picker-palette-value",
        "data-palette-color": p,
        style: `background-color: ${p}`
      });
    })));
  },
  init(self) {
    function handlePaletteClick(e) {
      const hex = dom7_default(e.target).attr("data-palette-color");
      self.setValue({
        hex
      });
    }
    self.$el.on("click", ".color-picker-module-palette .color-picker-palette-value", handlePaletteClick);
    self.destroyPaletteEvents = function destroyPaletteEvents() {
      self.$el.off("click", ".color-picker-module-hex input", handlePaletteClick);
    };
  },
  destroy(self) {
    if (self.destroyPaletteEvents) {
      self.destroyPaletteEvents();
    }
    delete self.destroyPaletteEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/initial-current-colors.js
var initial_current_colors_default = {
  render() {
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-initial-current-colors"
    }, jsx_default2("div", {
      class: "color-picker-initial-current-colors"
    }, jsx_default2("div", {
      class: "color-picker-initial-color"
    }), jsx_default2("div", {
      class: "color-picker-current-color"
    })));
  },
  init(self) {
    function handleInitialColorClick() {
      if (self.initialValue) {
        const {
          hex,
          alpha
        } = self.initialValue;
        self.setValue({
          hex,
          alpha
        });
      }
    }
    self.$el.on("click", ".color-picker-initial-color", handleInitialColorClick);
    self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
      self.$el.off("click", ".color-picker-initial-color", handleInitialColorClick);
    };
  },
  update(self) {
    self.$el.find(".color-picker-module-initial-current-colors .color-picker-initial-color").css("background-color", self.initialValue.hex);
    self.$el.find(".color-picker-module-initial-current-colors .color-picker-current-color").css("background-color", self.value.hex);
  },
  destroy(self) {
    if (self.destroyInitialCurrentEvents) {
      self.destroyInitialCurrentEvents();
    }
    delete self.destroyInitialCurrentEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/rgb-bars.js
var rgb_bars_default = {
  render(self) {
    const {
      barLabel,
      barValue,
      barValueEditable,
      redLabelText,
      greenLabelText,
      blueLabelText
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-rgb-bars"
    }, jsx_default2("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && jsx_default2("div", {
      class: "color-picker-bar-label"
    }, redLabelText), jsx_default2("div", {
      class: "range-slider color-picker-bar color-picker-bar-red"
    }), barValue && jsx_default2("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? jsx_default2("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-red",
      "data-color-index": "0"
    }) : jsx_default2("span", {
      class: "color-picker-value-bar-red"
    }))), jsx_default2("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && jsx_default2("div", {
      class: "color-picker-bar-label"
    }, greenLabelText), jsx_default2("div", {
      class: "range-slider color-picker-bar color-picker-bar-green"
    }), barValue && jsx_default2("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? jsx_default2("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-green",
      "data-color-index": "1"
    }) : jsx_default2("span", {
      class: "color-picker-value-bar-green"
    }))), jsx_default2("div", {
      class: "color-picker-bar-wrap"
    }, barLabel && jsx_default2("div", {
      class: "color-picker-bar-label"
    }, blueLabelText), jsx_default2("div", {
      class: "range-slider color-picker-bar color-picker-bar-blue"
    }), barValue && jsx_default2("div", {
      class: "color-picker-bar-value"
    }, barValueEditable ? jsx_default2("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-bar-blue",
      "data-color-index": "2"
    }) : jsx_default2("span", {
      class: "color-picker-value-bar-blue"
    }))));
  },
  init(self) {
    self.redBar = self.app.range.create({
      el: self.$el.find(".color-picker-bar-red"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [value, self.value.rgb[1], self.value.rgb[2]]
          });
        }
      }
    });
    self.greenBar = self.app.range.create({
      el: self.$el.find(".color-picker-bar-green"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], value, self.value.rgb[2]]
          });
        }
      }
    });
    self.blueBar = self.app.range.create({
      el: self.$el.find(".color-picker-bar-blue"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      vertical: true,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], self.value.rgb[1], value]
          });
        }
      }
    });
    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index2 = parseInt(dom7_default(e.target).attr("data-color-index"), 10);
      let value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) {
        e.target.value = rgb[index2];
        return;
      }
      value = Math.max(0, Math.min(255, value));
      rgb[index2] = value;
      self.setValue({
        rgb
      });
    }
    self.$el.on("change", ".color-picker-module-rgb-bars input", handleInputChange);
    self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
      self.$el.off("change", ".color-picker-module-rgb-bars input", handleInputChange);
    };
  },
  update(self) {
    const {
      value,
      redBar,
      greenBar,
      blueBar
    } = self;
    const {
      barValue,
      barValueEditable
    } = self.params;
    const {
      rgb
    } = value;
    redBar.value = rgb[0];
    greenBar.value = rgb[1];
    blueBar.value = rgb[2];
    redBar.layout();
    greenBar.layout();
    blueBar.layout();
    redBar.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenBar.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueBar.$el.find(".range-bar").css("background-image", `linear-gradient(to top, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);
    if (barValue && barValueEditable) {
      self.$el.find("input.color-picker-value-bar-red").val(rgb[0]);
      self.$el.find("input.color-picker-value-bar-green").val(rgb[1]);
      self.$el.find("input.color-picker-value-bar-blue").val(rgb[2]);
    } else if (barValue) {
      self.$el.find("span.color-picker-value-bar-red").text(rgb[0]);
      self.$el.find("span.color-picker-value-bar-green").text(rgb[1]);
      self.$el.find("span.color-picker-value-bar-blue").text(rgb[2]);
    }
  },
  destroy(self) {
    if (self.redBar && self.redBar.destroy) {
      self.redBar.destroy();
    }
    if (self.greenBar && self.greenBar.destroy) {
      self.greenBar.destroy();
    }
    if (self.blueBar && self.blueBar.destroy) {
      self.blueBar.destroy();
    }
    delete self.redBar;
    delete self.greenBar;
    delete self.blueBar;
    if (self.destroyRgbBarsEvents)
      self.destroyRgbBarsEvents();
    delete self.destroyRgbBarsEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/rgb-sliders.js
var rgb_sliders_default = {
  render(self) {
    const {
      sliderLabel,
      sliderValue,
      sliderValueEditable,
      redLabelText,
      greenLabelText,
      blueLabelText
    } = self.params;
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-rgb-sliders"
    }, jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, redLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-red"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-red",
      "data-color-index": "0"
    }) : jsx_default2("span", {
      class: "color-picker-value-red"
    }))), jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, greenLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-green"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-green",
      "data-color-index": "1"
    }) : jsx_default2("span", {
      class: "color-picker-value-green"
    }))), jsx_default2("div", {
      class: "color-picker-slider-wrap"
    }, sliderLabel && jsx_default2("div", {
      class: "color-picker-slider-label"
    }, blueLabelText), jsx_default2("div", {
      class: "range-slider color-picker-slider color-picker-slider-blue"
    }), sliderValue && jsx_default2("div", {
      class: "color-picker-slider-value"
    }, sliderValueEditable ? jsx_default2("input", {
      type: "number",
      step: "1",
      min: "0",
      max: "255",
      class: "color-picker-value-blue",
      "data-color-index": "2"
    }) : jsx_default2("span", {
      class: "color-picker-value-blue"
    }))));
  },
  init(self) {
    self.redRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-red"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [value, self.value.rgb[1], self.value.rgb[2]]
          });
        }
      }
    });
    self.greenRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-green"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], value, self.value.rgb[2]]
          });
        }
      }
    });
    self.blueRangeSlider = self.app.range.create({
      el: self.$el.find(".color-picker-slider-blue"),
      min: 0,
      max: 255,
      step: 1,
      value: 0,
      on: {
        change(range, value) {
          self.setValue({
            rgb: [self.value.rgb[0], self.value.rgb[1], value]
          });
        }
      }
    });
    function handleInputChange(e) {
      const rgb = [...self.value.rgb];
      const index2 = parseInt(dom7_default(e.target).attr("data-color-index"), 10);
      let value = parseInt(e.target.value, 10);
      if (Number.isNaN(value)) {
        e.target.value = rgb[index2];
        return;
      }
      value = Math.max(0, Math.min(255, value));
      rgb[index2] = value;
      self.setValue({
        rgb
      });
    }
    self.$el.on("change", ".color-picker-module-rgb-sliders input", handleInputChange);
    self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
      self.$el.off("change", ".color-picker-module-rgb-sliders input", handleInputChange);
    };
  },
  update(self) {
    const {
      app,
      value,
      redRangeSlider,
      greenRangeSlider,
      blueRangeSlider
    } = self;
    const {
      sliderValue,
      sliderValueEditable
    } = self.params;
    const {
      rgb
    } = value;
    redRangeSlider.value = rgb[0];
    greenRangeSlider.value = rgb[1];
    blueRangeSlider.value = rgb[2];
    redRangeSlider.layout();
    greenRangeSlider.layout();
    blueRangeSlider.layout();
    redRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    greenRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    blueRangeSlider.$el[0].style.setProperty("--f7-range-knob-color", `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
    const direction = app.rtl ? "to left" : "to right";
    redRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${direction}, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
    greenRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${direction}, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
    blueRangeSlider.$el.find(".range-bar").css("background-image", `linear-gradient(${direction}, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);
    if (sliderValue && sliderValueEditable) {
      self.$el.find("input.color-picker-value-red").val(rgb[0]);
      self.$el.find("input.color-picker-value-green").val(rgb[1]);
      self.$el.find("input.color-picker-value-blue").val(rgb[2]);
    } else if (sliderValue) {
      self.$el.find("span.color-picker-value-red").text(rgb[0]);
      self.$el.find("span.color-picker-value-green").text(rgb[1]);
      self.$el.find("span.color-picker-value-blue").text(rgb[2]);
    }
  },
  destroy(self) {
    if (self.redRangeSlider && self.redRangeSlider.destroy) {
      self.redRangeSlider.destroy();
    }
    if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
      self.greenRangeSlider.destroy();
    }
    if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
      self.blueRangeSlider.destroy();
    }
    delete self.redRangeSlider;
    delete self.greenRangeSlider;
    delete self.blueRangeSlider;
    if (self.destroyRgbSlidersEvents)
      self.destroyRgbSlidersEvents();
    delete self.destroyRgbSlidersEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/sb-spectrum.js
var sb_spectrum_default = {
  render() {
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-sb-spectrum"
    }, jsx_default2("div", {
      class: "color-picker-sb-spectrum",
      style: "background-color: hsl(0, 100%, 50%)"
    }, jsx_default2("div", {
      class: "color-picker-sb-spectrum-handle"
    })));
  },
  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;
    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));
      self.setValue({
        hsb: [self.value.hue, s, b]
      });
    }
    function handleTouchStart(e) {
      if (isMoved || isTouched)
        return;
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = dom7_default(e.target);
      specterHandleIsTouched = $targetEl.closest(".color-picker-sb-spectrum-handle").length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest(".color-picker-sb-spectrum").length > 0;
      }
      if (specterIsTouched) {
        specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed");
      }
    }
    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched))
        return;
      touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        isMoved = true;
        if (specterHandleIsTouched) {
          specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        }
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed");
      }
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }
    function handleResize() {
      self.modules["sb-spectrum"].update(self);
    }
    const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    app.on("resize", handleResize);
    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("resize", handleResize);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hsl,
      hsb
    } = value;
    const specterWidth = self.$el.find(".color-picker-sb-spectrum")[0].offsetWidth;
    const specterHeight = self.$el.find(".color-picker-sb-spectrum")[0].offsetHeight;
    self.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${hsl[0]}, 100%, 50%)`);
    self.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`).transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },
  destroy(self) {
    if (self.destroySpectrumEvents)
      self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/hs-spectrum.js
var hs_spectrum_default = {
  render() {
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-hs-spectrum"
    }, jsx_default2("div", {
      class: "color-picker-hs-spectrum"
    }, jsx_default2("div", {
      class: "color-picker-hs-spectrum-handle"
    })));
  },
  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;
    function setHSFromSpecterCoords(x, y) {
      let h = (x - specterRect.left) / specterRect.width * 360;
      let s = (y - specterRect.top) / specterRect.height;
      h = Math.max(0, Math.min(360, h));
      s = 1 - Math.max(0, Math.min(1, s));
      self.setValue({
        hsb: [h, s, self.value.hsb[2]]
      });
    }
    function handleTouchStart(e) {
      if (isMoved || isTouched)
        return;
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = dom7_default(e.target);
      specterHandleIsTouched = $targetEl.closest(".color-picker-hs-spectrum-handle").length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest(".color-picker-hs-spectrum").length > 0;
      }
      if (specterIsTouched) {
        specterRect = $el.find(".color-picker-hs-spectrum")[0].getBoundingClientRect();
        setHSFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find(".color-picker-hs-spectrum-handle").addClass("color-picker-hs-spectrum-handle-pressed");
      }
    }
    function handleTouchMove(e) {
      if (!(specterIsTouched || specterHandleIsTouched))
        return;
      touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        isMoved = true;
        if (specterHandleIsTouched) {
          specterRect = $el.find(".color-picker-hs-spectrum")[0].getBoundingClientRect();
        }
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find(".color-picker-hs-spectrum-handle").removeClass("color-picker-hs-spectrum-handle-pressed");
      }
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }
    function handleResize() {
      self.modules["hs-spectrum"].update(self);
    }
    const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    app.on("resize", handleResize);
    self.destroySpectrumEvents = function destroySpectrumEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("resize", handleResize);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hsb
    } = value;
    const specterWidth = self.$el.find(".color-picker-hs-spectrum")[0].offsetWidth;
    const specterHeight = self.$el.find(".color-picker-hs-spectrum")[0].offsetHeight;
    const hslBright = colorHsbToHsl(hsb[0], hsb[1], 1);
    self.$el.find(".color-picker-hs-spectrum-handle").css("background-color", `hsl(${hslBright[0]}, ${hslBright[1] * 100}%, ${hslBright[2] * 100}%)`).transform(`translate(${specterWidth * (hsb[0] / 360)}px, ${specterHeight * (1 - hsb[1])}px)`);
  },
  destroy(self) {
    if (self.destroySpectrumEvents)
      self.destroySpectrumEvents();
    delete self.destroySpectrumEvents;
  }
};

// node_modules/framework7/components/color-picker/modules/wheel.js
function svgWheelCircles() {
  const total = 256;
  let circles = "";
  for (let i = total; i > 0; i -= 1) {
    const angle = i * Math.PI / (total / 2);
    const hue = 360 / total * i;
    circles += `<circle cx="${150 - Math.sin(angle) * 125}" cy="${150 - Math.cos(angle) * 125}" r="25" fill="hsl(${hue}, 100%, 50%)"></circle>`;
  }
  return circles;
}
var wheel_default = {
  render() {
    return jsx_default2("div", {
      class: "color-picker-module color-picker-module-wheel"
    }, jsx_default2("div", {
      class: "color-picker-wheel"
    }, jsx_default2("svg", {
      viewBox: "0 0 300 300",
      width: "300",
      height: "300"
    }, svgWheelCircles()), jsx_default2("div", {
      class: "color-picker-wheel-handle"
    }), jsx_default2("div", {
      class: "color-picker-sb-spectrum",
      style: "background-color: hsl(0, 100%, 50%)"
    }, jsx_default2("div", {
      class: "color-picker-sb-spectrum-handle"
    }))));
  },
  init(self) {
    const {
      app
    } = self;
    let isTouched;
    let isMoved;
    let touchStartX;
    let touchStartY;
    let touchCurrentX;
    let touchCurrentY;
    let wheelRect;
    let wheelIsTouched;
    let wheelHandleIsTouched;
    let specterRect;
    let specterIsTouched;
    let specterHandleIsTouched;
    const {
      $el
    } = self;
    function setHueFromWheelCoords(x, y) {
      const wheelCenterX = wheelRect.left + wheelRect.width / 2;
      const wheelCenterY = wheelRect.top + wheelRect.height / 2;
      const angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
      let angleDeg = angleRad * 180 / Math.PI + 90;
      if (angleDeg < 0)
        angleDeg += 360;
      angleDeg = 360 - angleDeg;
      self.setValue({
        hue: angleDeg
      });
    }
    function setSBFromSpecterCoords(x, y) {
      let s = (x - specterRect.left) / specterRect.width;
      let b = (y - specterRect.top) / specterRect.height;
      s = Math.max(0, Math.min(1, s));
      b = 1 - Math.max(0, Math.min(1, b));
      self.setValue({
        hsb: [self.value.hue, s, b]
      });
    }
    function handleTouchStart(e) {
      if (isMoved || isTouched)
        return;
      touchStartX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentX = touchStartX;
      touchStartY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      const $targetEl = dom7_default(e.target);
      wheelHandleIsTouched = $targetEl.closest(".color-picker-wheel-handle").length > 0;
      wheelIsTouched = $targetEl.closest("circle").length > 0;
      specterHandleIsTouched = $targetEl.closest(".color-picker-sb-spectrum-handle").length > 0;
      if (!specterHandleIsTouched) {
        specterIsTouched = $targetEl.closest(".color-picker-sb-spectrum").length > 0;
      }
      if (wheelIsTouched) {
        wheelRect = $el.find(".color-picker-wheel")[0].getBoundingClientRect();
        setHueFromWheelCoords(touchStartX, touchStartY);
      }
      if (specterIsTouched) {
        specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        setSBFromSpecterCoords(touchStartX, touchStartY);
      }
      if (specterHandleIsTouched || specterIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").addClass("color-picker-sb-spectrum-handle-pressed");
      }
    }
    function handleTouchMove(e) {
      if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched))
        return;
      touchCurrentX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
      touchCurrentY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
      e.preventDefault();
      if (!isMoved) {
        isMoved = true;
        if (wheelHandleIsTouched) {
          wheelRect = $el.find(".color-picker-wheel")[0].getBoundingClientRect();
        }
        if (specterHandleIsTouched) {
          specterRect = $el.find(".color-picker-sb-spectrum")[0].getBoundingClientRect();
        }
      }
      if (wheelIsTouched || wheelHandleIsTouched) {
        setHueFromWheelCoords(touchCurrentX, touchCurrentY);
      }
      if (specterIsTouched || specterHandleIsTouched) {
        setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
      }
    }
    function handleTouchEnd() {
      isMoved = false;
      if (specterIsTouched || specterHandleIsTouched) {
        $el.find(".color-picker-sb-spectrum-handle").removeClass("color-picker-sb-spectrum-handle-pressed");
      }
      wheelIsTouched = false;
      wheelHandleIsTouched = false;
      specterIsTouched = false;
      specterHandleIsTouched = false;
    }
    function handleResize() {
      self.modules.wheel.update(self);
    }
    const passiveListener = app.touchEvents.start === "touchstart" && getSupport().passiveListener ? {
      passive: true,
      capture: false
    } : false;
    self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
    app.on("resize", handleResize);
    self.destroyWheelEvents = function destroyWheelEvents() {
      self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off("touchmove:active", handleTouchMove);
      app.off("touchend:passive", handleTouchEnd);
      app.off("resize", handleResize);
    };
  },
  update(self) {
    const {
      value
    } = self;
    const {
      hsl,
      hsb
    } = value;
    const specterWidth = self.$el.find(".color-picker-sb-spectrum")[0].offsetWidth;
    const specterHeight = self.$el.find(".color-picker-sb-spectrum")[0].offsetHeight;
    const wheelSize = self.$el.find(".color-picker-wheel")[0].offsetWidth;
    const wheelHalfSize = wheelSize / 2;
    const angleRad = value.hue * Math.PI / 180;
    const handleSize = wheelSize / 6;
    const handleHalfSize = handleSize / 2;
    const tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    const tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
    self.$el.find(".color-picker-wheel-handle").css("background-color", `hsl(${hsl[0]}, 100%, 50%)`).transform(`translate(${tX}px, ${tY}px)`);
    self.$el.find(".color-picker-sb-spectrum").css("background-color", `hsl(${hsl[0]}, 100%, 50%)`);
    self.$el.find(".color-picker-sb-spectrum-handle").css("background-color", `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`).transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
  },
  destroy(self) {
    if (self.destroyWheelEvents)
      self.destroyWheelEvents();
    delete self.destroyWheelEvents;
  }
};

// node_modules/framework7/components/color-picker/color-picker-class.js
var ColorPicker = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const self = this;
    self.params = extend({}, app.params.colorPicker, params);
    let $containerEl;
    if (self.params.containerEl) {
      $containerEl = dom7_default(self.params.containerEl);
      if ($containerEl.length === 0)
        return self;
    }
    let $inputEl;
    if (self.params.inputEl) {
      $inputEl = dom7_default(self.params.inputEl);
    }
    let $targetEl;
    if (self.params.targetEl) {
      $targetEl = dom7_default(self.params.targetEl);
    }
    extend(self, {
      app,
      $containerEl,
      containerEl: $containerEl && $containerEl[0],
      inline: $containerEl && $containerEl.length > 0,
      $inputEl,
      inputEl: $inputEl && $inputEl[0],
      $targetEl,
      targetEl: $targetEl && $targetEl[0],
      initialized: false,
      opened: false,
      url: self.params.url,
      modules: {
        "alpha-slider": alpha_slider_default,
        "current-color": current_color_default,
        hex: hex_default,
        "hsb-sliders": hsb_sliders_default,
        "hue-slider": hue_slider_default,
        "brightness-slider": brightness_slider_default,
        palette: palette_default,
        "initial-current-colors": initial_current_colors_default,
        "rgb-bars": rgb_bars_default,
        "rgb-sliders": rgb_sliders_default,
        "sb-spectrum": sb_spectrum_default,
        "hs-spectrum": hs_spectrum_default,
        wheel: wheel_default
      }
    });
    function onInputClick() {
      self.open();
    }
    function onInputFocus(e) {
      e.preventDefault();
    }
    function onTargetClick() {
      self.open();
    }
    function onHtmlClick(e) {
      if (self.destroyed || !self.params)
        return;
      if (self.params.openIn === "page")
        return;
      const $clickTargetEl = dom7_default(e.target);
      if (!self.opened || self.closing)
        return;
      if ($clickTargetEl.closest('[class*="backdrop"]').length)
        return;
      if ($clickTargetEl.closest(".color-picker-popup, .color-picker-popover").length)
        return;
      if ($inputEl && $inputEl.length > 0) {
        if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest(".sheet-modal").length === 0) {
          self.close();
        }
      } else if (dom7_default(e.target).closest(".sheet-modal").length === 0) {
        self.close();
      }
    }
    extend(self, {
      attachInputEvents() {
        self.$inputEl.on("click", onInputClick);
        if (self.params.inputReadOnly) {
          self.$inputEl.on("focus mousedown", onInputFocus);
          if (self.$inputEl[0]) {
            self.$inputEl[0].f7ValidateReadonly = true;
          }
        }
      },
      detachInputEvents() {
        self.$inputEl.off("click", onInputClick);
        if (self.params.inputReadOnly) {
          self.$inputEl.off("focus mousedown", onInputFocus);
          if (self.$inputEl[0]) {
            delete self.$inputEl[0].f7ValidateReadonly;
          }
        }
      },
      attachTargetEvents() {
        self.$targetEl.on("click", onTargetClick);
      },
      detachTargetEvents() {
        self.$targetEl.off("click", onTargetClick);
      },
      attachHtmlEvents() {
        app.on("click", onHtmlClick);
      },
      detachHtmlEvents() {
        app.off("click", onHtmlClick);
      }
    });
    self.init();
    return self;
  }
  get view() {
    const {
      $inputEl,
      $targetEl,
      app,
      params
    } = this;
    let view;
    if (params.view) {
      view = params.view;
    } else {
      if ($inputEl) {
        view = $inputEl.parents(".view").length && $inputEl.parents(".view")[0].f7View;
      }
      if (!view && $targetEl) {
        view = $targetEl.parents(".view").length && $targetEl.parents(".view")[0].f7View;
      }
    }
    if (!view)
      view = app.views.main;
    return view;
  }
  attachEvents() {
    const self = this;
    self.centerModules = self.centerModules.bind(self);
    if (self.params.centerModules) {
      self.app.on("resize", self.centerModules);
    }
  }
  detachEvents() {
    const self = this;
    if (self.params.centerModules) {
      self.app.off("resize", self.centerModules);
    }
  }
  centerModules() {
    const self = this;
    if (!self.opened || !self.$el || self.inline)
      return;
    const $pageContentEl = self.$el.find(".page-content");
    if (!$pageContentEl.length)
      return;
    const {
      scrollHeight,
      offsetHeight
    } = $pageContentEl[0];
    if (scrollHeight <= offsetHeight) {
      $pageContentEl.addClass("justify-content-center");
    } else {
      $pageContentEl.removeClass("justify-content-center");
    }
  }
  initInput() {
    const self = this;
    if (!self.$inputEl)
      return;
    if (self.params.inputReadOnly)
      self.$inputEl.prop("readOnly", true);
  }
  getModalType() {
    const self = this;
    const {
      app,
      modal,
      params
    } = self;
    const {
      openIn,
      openInPhone
    } = params;
    const device = getDevice();
    if (modal && modal.type)
      return modal.type;
    if (openIn !== "auto")
      return openIn;
    if (self.inline)
      return null;
    if (device.ios) {
      return device.ipad ? "popover" : openInPhone;
    }
    if (app.width >= 768 || device.desktop && app.theme === "aurora") {
      return "popover";
    }
    return openInPhone;
  }
  formatValue() {
    const self = this;
    const {
      value
    } = self;
    if (self.params.formatValue) {
      return self.params.formatValue.call(self, value);
    }
    return value.hex;
  }
  normalizeHsValues(arr) {
    return [Math.floor(arr[0] * 10) / 10, Math.floor(arr[1] * 1e3) / 1e3, Math.floor(arr[2] * 1e3) / 1e3];
  }
  setValue(value, updateModules) {
    if (value === void 0) {
      value = {};
    }
    if (updateModules === void 0) {
      updateModules = true;
    }
    const self = this;
    if (typeof value === "undefined")
      return;
    let {
      hex,
      rgb,
      hsl,
      hsb,
      alpha = 1,
      hue,
      rgba,
      hsla
    } = self.value || {};
    const needChangeEvent = self.value || !self.value && !self.params.value;
    let valueChanged;
    Object.keys(value).forEach((k) => {
      if (!self.value || typeof self.value[k] === "undefined") {
        valueChanged = true;
        return;
      }
      const v = value[k];
      if (Array.isArray(v)) {
        v.forEach((subV, subIndex) => {
          if (subV !== self.value[k][subIndex]) {
            valueChanged = true;
          }
        });
      } else if (v !== self.value[k]) {
        valueChanged = true;
      }
    });
    if (!valueChanged)
      return;
    if (value.rgb || value.rgba) {
      const [r, g, b, a = alpha] = value.rgb || value.rgba;
      rgb = [r, g, b];
      hex = colorRgbToHex(...rgb);
      hsl = colorRgbToHsl(...rgb);
      hsb = colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }
    if (value.hsl || value.hsla) {
      const [h, s, l, a = alpha] = value.hsl || value.hsla;
      hsl = [h, s, l];
      rgb = colorHslToRgb(...hsl);
      hex = colorRgbToHex(...rgb);
      hsb = colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }
    if (value.hsb) {
      const [h, s, b, a = alpha] = value.hsb;
      hsb = [h, s, b];
      hsl = colorHsbToHsl(...hsb);
      rgb = colorHslToRgb(...hsl);
      hex = colorRgbToHex(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      alpha = a;
      rgba = [rgb[0], rgb[1], rgb[2], a];
      hsla = [hsl[0], hsl[1], hsl[2], a];
    }
    if (value.hex) {
      rgb = colorHexToRgb(value.hex);
      hex = colorRgbToHex(...rgb);
      hsl = colorRgbToHsl(...rgb);
      hsb = colorHslToHsb(...hsl);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }
    if (typeof value.alpha !== "undefined") {
      alpha = value.alpha;
      if (typeof rgb !== "undefined") {
        rgba = [rgb[0], rgb[1], rgb[2], alpha];
      }
      if (typeof hsl !== "undefined") {
        hsla = [hsl[0], hsl[1], hsl[2], alpha];
      }
    }
    if (typeof value.hue !== "undefined") {
      const [h, s, l] = hsl;
      hsl = [value.hue, s, l];
      hsb = colorHslToHsb(...hsl);
      rgb = colorHslToRgb(...hsl);
      hex = colorRgbToHex(...rgb);
      hsl = self.normalizeHsValues(hsl);
      hsb = self.normalizeHsValues(hsb);
      hue = hsb[0];
      rgba = [rgb[0], rgb[1], rgb[2], alpha];
      hsla = [hsl[0], hsl[1], hsl[2], alpha];
    }
    self.value = {
      hex,
      alpha,
      hue,
      rgb,
      hsl,
      hsb,
      rgba,
      hsla
    };
    if (!self.initialValue)
      self.initialValue = extend({}, self.value);
    self.updateValue(needChangeEvent);
    if (self.opened && updateModules) {
      self.updateModules();
    }
  }
  getValue() {
    const self = this;
    return self.value;
  }
  updateValue(fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }
    const self = this;
    const {
      $inputEl,
      value,
      $targetEl
    } = self;
    if ($targetEl && self.params.targetElSetBackgroundColor) {
      const {
        rgba
      } = value;
      $targetEl.css("background-color", `rgba(${rgba.join(", ")})`);
    }
    if (fireEvents) {
      self.emit("local::change colorPickerChange", self, value);
    }
    if ($inputEl && $inputEl.length) {
      const inputValue = self.formatValue(value);
      if ($inputEl && $inputEl.length) {
        $inputEl.val(inputValue);
        if (fireEvents) {
          $inputEl.trigger("change");
        }
      }
    }
  }
  updateModules() {
    const self = this;
    const {
      modules: modules2
    } = self;
    self.params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].update) {
        modules2[m].update(self);
      } else if (m && m.update) {
        m.update(self);
      }
    });
  }
  update() {
    const self = this;
    self.updateModules();
  }
  renderPicker() {
    const self = this;
    const {
      params,
      modules: modules2
    } = self;
    let html2 = "";
    params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].render) {
        html2 += modules2[m].render(self);
      } else if (m && m.render) {
        html2 += m.render(self);
      }
    });
    return html2;
  }
  renderNavbar() {
    const self = this;
    if (self.params.renderNavbar) {
      return self.params.renderNavbar.call(self, self);
    }
    const {
      openIn,
      navbarTitleText,
      navbarBackLinkText,
      navbarCloseText
    } = self.params;
    return jsx_default2("div", {
      class: "navbar"
    }, jsx_default2("div", {
      class: "navbar-bg"
    }), jsx_default2("div", {
      class: "navbar-inner sliding"
    }, openIn === "page" && jsx_default2("div", {
      class: "left"
    }, jsx_default2("a", {
      class: "link back"
    }, jsx_default2("i", {
      class: "icon icon-back"
    }), jsx_default2("span", {
      class: "if-not-md"
    }, navbarBackLinkText))), jsx_default2("div", {
      class: "title"
    }, navbarTitleText), openIn !== "page" && jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link popup-close",
      "data-popup": ".color-picker-popup"
    }, navbarCloseText))));
  }
  renderToolbar() {
    const self = this;
    if (self.params.renderToolbar) {
      return self.params.renderToolbar.call(self, self);
    }
    return jsx_default2("div", {
      class: "toolbar toolbar-top no-shadow"
    }, jsx_default2("div", {
      class: "toolbar-inner"
    }, jsx_default2("div", {
      class: "left"
    }), jsx_default2("div", {
      class: "right"
    }, jsx_default2("a", {
      class: "link sheet-close popover-close",
      "data-sheet": ".color-picker-sheet-modal",
      "data-popover": ".color-picker-popover"
    }, self.params.toolbarCloseText))));
  }
  renderInline() {
    const self = this;
    const {
      cssClass,
      groupedModules
    } = self.params;
    return jsx_default2("div", {
      class: `color-picker color-picker-inline ${groupedModules ? "color-picker-grouped-modules" : ""} ${cssClass || ""}`
    }, self.renderPicker());
  }
  renderSheet() {
    const self = this;
    const {
      cssClass,
      toolbarSheet,
      groupedModules
    } = self.params;
    return jsx_default2("div", {
      class: `sheet-modal color-picker color-picker-sheet-modal ${groupedModules ? "color-picker-grouped-modules" : ""} ${cssClass || ""}`
    }, toolbarSheet && self.renderToolbar(), jsx_default2("div", {
      class: "sheet-modal-inner"
    }, jsx_default2("div", {
      class: "page-content"
    }, self.renderPicker())));
  }
  renderPopover() {
    const self = this;
    const {
      cssClass,
      toolbarPopover,
      groupedModules
    } = self.params;
    return jsx_default2("div", {
      class: `popover color-picker-popover ${cssClass || ""}`
    }, jsx_default2("div", {
      class: "popover-inner"
    }, jsx_default2("div", {
      class: `color-picker ${groupedModules ? "color-picker-grouped-modules" : ""}`
    }, toolbarPopover && self.renderToolbar(), jsx_default2("div", {
      class: "page-content"
    }, self.renderPicker()))));
  }
  renderPopup() {
    const self = this;
    const {
      cssClass,
      navbarPopup,
      groupedModules
    } = self.params;
    return jsx_default2("div", {
      class: `popup color-picker-popup ${cssClass || ""}`
    }, jsx_default2("div", {
      class: "page"
    }, navbarPopup && self.renderNavbar(), jsx_default2("div", {
      class: `color-picker ${groupedModules ? "color-picker-grouped-modules" : ""}`
    }, jsx_default2("div", {
      class: "page-content"
    }, self.renderPicker()))));
  }
  renderPage() {
    const self = this;
    const {
      cssClass,
      groupedModules
    } = self.params;
    return jsx_default2("div", {
      class: `page color-picker-page ${cssClass || ""}`,
      "data-name": "color-picker-page"
    }, self.renderNavbar(), jsx_default2("div", {
      class: `color-picker ${groupedModules ? "color-picker-grouped-modules" : ""}`
    }, jsx_default2("div", {
      class: "page-content"
    }, self.renderPicker())));
  }
  render() {
    const self = this;
    const {
      params
    } = self;
    if (params.render)
      return params.render.call(self);
    if (self.inline)
      return self.renderInline();
    if (params.openIn === "page") {
      return self.renderPage();
    }
    const modalType = self.getModalType();
    if (modalType === "popover")
      return self.renderPopover();
    if (modalType === "sheet")
      return self.renderSheet();
    if (modalType === "popup")
      return self.renderPopup();
  }
  onOpen() {
    const self = this;
    const {
      initialized,
      $el,
      app,
      $inputEl,
      inline,
      value,
      params,
      modules: modules2
    } = self;
    self.closing = false;
    self.opened = true;
    self.opening = true;
    self.attachEvents();
    params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].init) {
        modules2[m].init(self);
      } else if (m && m.init) {
        m.init(self);
      }
    });
    const updateValue = !value && params.value;
    if (!initialized) {
      if (value)
        self.setValue(value);
      else if (params.value) {
        self.setValue(params.value, false);
      } else if (!params.value) {
        self.setValue({
          hex: "#ff0000"
        }, false);
      }
    } else if (value) {
      self.initialValue = extend({}, value);
      self.setValue(value, false);
    }
    if (updateValue)
      self.updateValue();
    self.updateModules();
    if (params.centerModules) {
      self.centerModules();
    }
    if (!inline && $inputEl && $inputEl.length && app.theme === "md") {
      $inputEl.trigger("focus");
    }
    self.initialized = true;
    if ($el) {
      $el.trigger("colorpicker:open");
    }
    if ($inputEl) {
      $inputEl.trigger("colorpicker:open");
    }
    self.emit("local::open colorPickerOpen", self);
  }
  onOpened() {
    const self = this;
    self.opening = false;
    if (self.$el) {
      self.$el.trigger("colorpicker:opened");
    }
    if (self.$inputEl) {
      self.$inputEl.trigger("colorpicker:opened");
    }
    self.emit("local::opened colorPickerOpened", self);
  }
  onClose() {
    const self = this;
    const {
      app,
      params,
      modules: modules2
    } = self;
    self.opening = false;
    self.closing = true;
    self.detachEvents();
    if (self.$inputEl) {
      if (app.theme === "md") {
        self.$inputEl.trigger("blur");
      } else {
        const validate = self.$inputEl.attr("validate");
        const required = self.$inputEl.attr("required");
        if (validate && required) {
          app.input.validate(self.$inputEl);
        }
      }
    }
    params.modules.forEach((m) => {
      if (typeof m === "string" && modules2[m] && modules2[m].destroy) {
        modules2[m].destroy(self);
      } else if (m && m.destroy) {
        m.destroy(self);
      }
    });
    if (self.$el) {
      self.$el.trigger("colorpicker:close");
    }
    if (self.$inputEl) {
      self.$inputEl.trigger("colorpicker:close");
    }
    self.emit("local::close colorPickerClose", self);
  }
  onClosed() {
    const self = this;
    self.opened = false;
    self.closing = false;
    if (!self.inline) {
      nextTick(() => {
        if (self.modal && self.modal.el && self.modal.destroy) {
          if (!self.params.routableModals) {
            self.modal.destroy();
          }
        }
        delete self.modal;
      });
    }
    if (self.$el) {
      self.$el.trigger("colorpicker:closed");
    }
    if (self.$inputEl) {
      self.$inputEl.trigger("colorpicker:closed");
    }
    self.emit("local::closed colorPickerClosed", self);
  }
  open() {
    const self = this;
    const {
      app,
      opened,
      inline,
      $inputEl,
      $targetEl,
      params
    } = self;
    if (opened)
      return;
    if (inline) {
      self.$el = dom7_default(self.render());
      self.$el[0].f7ColorPicker = self;
      self.$containerEl.append(self.$el);
      self.onOpen();
      self.onOpened();
      return;
    }
    const colorPickerContent = self.render();
    if (params.openIn === "page") {
      self.view.router.navigate({
        url: self.url,
        route: {
          content: colorPickerContent,
          path: self.url,
          on: {
            pageBeforeIn(e, page) {
              self.$el = page.$el.find(".color-picker");
              self.$el[0].f7ColorPicker = self;
              self.onOpen();
            },
            pageAfterIn() {
              self.onOpened();
            },
            pageBeforeOut() {
              self.onClose();
            },
            pageAfterOut() {
              self.onClosed();
              if (self.$el && self.$el[0]) {
                self.$el[0].f7ColorPicker = null;
                delete self.$el[0].f7ColorPicker;
              }
            }
          }
        }
      });
    } else {
      const modalType = self.getModalType();
      let backdrop = params.backdrop;
      if (backdrop === null || typeof backdrop === "undefined") {
        if (modalType === "popover" && app.params.popover.backdrop !== false)
          backdrop = true;
        if (modalType === "popup")
          backdrop = true;
      }
      const modalParams = {
        targetEl: $targetEl || $inputEl,
        scrollToEl: params.scrollToInput ? $targetEl || $inputEl : void 0,
        content: colorPickerContent,
        backdrop,
        closeByBackdropClick: params.closeByBackdropClick,
        on: {
          open() {
            const modal = this;
            self.modal = modal;
            self.$el = modalType === "popover" || modalType === "popup" ? modal.$el.find(".color-picker") : modal.$el;
            self.$el[0].f7ColorPicker = self;
            self.onOpen();
          },
          opened() {
            self.onOpened();
          },
          close() {
            self.onClose();
          },
          closed() {
            self.onClosed();
            if (self.$el && self.$el[0]) {
              self.$el[0].f7ColorPicker = null;
              delete self.$el[0].f7ColorPicker;
            }
          }
        }
      };
      if (modalType === "popup") {
        modalParams.push = params.popupPush;
        modalParams.swipeToClose = params.popupSwipeToClose;
      }
      if (modalType === "sheet") {
        modalParams.push = params.sheetPush;
        modalParams.swipeToClose = params.sheetSwipeToClose;
      }
      if (params.routableModals && self.view) {
        self.view.router.navigate({
          url: self.url,
          route: {
            path: self.url,
            [modalType]: modalParams
          }
        });
      } else {
        self.modal = app[modalType].create(modalParams);
        self.modal.open();
      }
    }
  }
  close() {
    const self = this;
    const {
      opened,
      inline
    } = self;
    if (!opened)
      return;
    if (inline) {
      self.onClose();
      self.onClosed();
      return;
    }
    if (self.params.routableModals && self.view || self.params.openIn === "page") {
      self.view.router.back();
    } else {
      self.modal.close();
    }
  }
  init() {
    const self = this;
    self.initInput();
    if (self.inline) {
      self.open();
      self.emit("local::init colorPickerInit", self);
      return;
    }
    if (!self.initialized && self.params.value) {
      self.setValue(self.params.value);
    }
    if (self.$inputEl) {
      self.attachInputEvents();
    }
    if (self.$targetEl) {
      self.attachTargetEvents();
    }
    if (self.params.closeByOutsideClick) {
      self.attachHtmlEvents();
    }
    self.emit("local::init colorPickerInit", self);
  }
  destroy() {
    const self = this;
    if (self.destroyed)
      return;
    const {
      $el
    } = self;
    self.emit("local::beforeDestroy colorPickerBeforeDestroy", self);
    if ($el)
      $el.trigger("colorpicker:beforedestroy");
    self.close();
    self.detachEvents();
    if (self.$inputEl) {
      self.detachInputEvents();
    }
    if (self.$targetEl) {
      self.detachTargetEvents();
    }
    if (self.params.closeByOutsideClick) {
      self.detachHtmlEvents();
    }
    if ($el && $el.length)
      delete self.$el[0].f7ColorPicker;
    deleteProps(self);
    self.destroyed = true;
  }
};
var color_picker_class_default = ColorPicker;

// node_modules/framework7/components/color-picker/color-picker.js
var color_picker_default = {
  name: "colorPicker",
  static: {
    ColorPicker: color_picker_class_default
  },
  create() {
    const app = this;
    app.colorPicker = ConstructorMethods({
      defaultSelector: ".color-picker",
      constructor: color_picker_class_default,
      app,
      domProp: "f7ColorPicker"
    });
    app.colorPicker.close = function close6(el) {
      if (el === void 0) {
        el = ".color-picker";
      }
      const $el = dom7_default(el);
      if ($el.length === 0)
        return;
      const colorPicker = $el[0].f7ColorPicker;
      if (!colorPicker || colorPicker && !colorPicker.opened)
        return;
      colorPicker.close();
    };
  },
  params: {
    colorPicker: {
      value: null,
      modules: ["wheel"],
      palette: [["#FFEBEE", "#FFCDD2", "#EF9A9A", "#E57373", "#EF5350", "#F44336", "#E53935", "#D32F2F", "#C62828", "#B71C1C"], ["#F3E5F5", "#E1BEE7", "#CE93D8", "#BA68C8", "#AB47BC", "#9C27B0", "#8E24AA", "#7B1FA2", "#6A1B9A", "#4A148C"], ["#E8EAF6", "#C5CAE9", "#9FA8DA", "#7986CB", "#5C6BC0", "#3F51B5", "#3949AB", "#303F9F", "#283593", "#1A237E"], ["#E1F5FE", "#B3E5FC", "#81D4FA", "#4FC3F7", "#29B6F6", "#03A9F4", "#039BE5", "#0288D1", "#0277BD", "#01579B"], ["#E0F2F1", "#B2DFDB", "#80CBC4", "#4DB6AC", "#26A69A", "#009688", "#00897B", "#00796B", "#00695C", "#004D40"], ["#F1F8E9", "#DCEDC8", "#C5E1A5", "#AED581", "#9CCC65", "#8BC34A", "#7CB342", "#689F38", "#558B2F", "#33691E"], ["#FFFDE7", "#FFF9C4", "#FFF59D", "#FFF176", "#FFEE58", "#FFEB3B", "#FDD835", "#FBC02D", "#F9A825", "#F57F17"], ["#FFF3E0", "#FFE0B2", "#FFCC80", "#FFB74D", "#FFA726", "#FF9800", "#FB8C00", "#F57C00", "#EF6C00", "#E65100"]],
      groupedModules: false,
      centerModules: true,
      sliderLabel: false,
      sliderValue: false,
      sliderValueEdiable: false,
      barLabel: false,
      barValue: false,
      barValueEdiable: false,
      hexLabel: false,
      hexValueEditable: false,
      redLabelText: "R",
      greenLabelText: "G",
      blueLabelText: "B",
      hueLabelText: "H",
      saturationLabelText: "S",
      brightnessLabelText: "B",
      hexLabelText: "HEX",
      alphaLabelText: "A",
      containerEl: null,
      openIn: "popover",
      openInPhone: "popup",
      popupPush: false,
      popupSwipeToClose: void 0,
      sheetPush: false,
      sheetSwipeToClose: void 0,
      formatValue: null,
      targetEl: null,
      targetElSetBackgroundColor: false,
      inputEl: null,
      inputReadOnly: true,
      closeByOutsideClick: true,
      scrollToInput: true,
      toolbarSheet: true,
      toolbarPopover: false,
      toolbarCloseText: "Done",
      navbarPopup: true,
      navbarCloseText: "Done",
      navbarTitleText: "Color",
      navbarBackLinkText: "Back",
      cssClass: null,
      routableModals: false,
      view: null,
      url: "color/",
      backdrop: null,
      closeByBackdropClick: true,
      renderToolbar: null,
      renderNavbar: null,
      renderInline: null,
      renderPopover: null,
      renderSheet: null,
      renderPopup: null,
      render: null
    }
  }
};

// node_modules/framework7/components/treeview/treeview.js
var Treeview = {
  open(itemEl) {
    const app = this;
    const $itemEl = dom7_default(itemEl).eq(0);
    if (!$itemEl.length)
      return;
    $itemEl.addClass("treeview-item-opened");
    $itemEl.trigger("treeview:open");
    app.emit("treeviewOpen", $itemEl[0]);
    function done(cancel) {
      if (cancel) {
        $itemEl.removeClass("treeview-item-opened");
        $itemEl.trigger("treeview:close");
        app.emit("treeviewClose", $itemEl[0]);
      } else {
        $itemEl[0].f7TreeviewChildrenLoaded = true;
      }
      $itemEl.find(".treeview-toggle").removeClass("treeview-toggle-hidden");
      $itemEl.find(".treeview-preloader").remove();
    }
    if ($itemEl.hasClass("treeview-load-children") && !$itemEl[0].f7TreeviewChildrenLoaded) {
      const preloaders = {
        iosPreloaderContent,
        mdPreloaderContent,
        auroraPreloaderContent
      };
      $itemEl.trigger("treeview:loadchildren", done);
      app.emit("treeviewLoadChildren", $itemEl[0], done);
      $itemEl.find(".treeview-toggle").addClass("treeview-toggle-hidden");
      $itemEl.find(".treeview-item-root").prepend(`<div class="preloader treeview-preloader">${preloaders[`${app.theme}PreloaderContent`]}</div>`);
    }
  },
  close(itemEl) {
    const app = this;
    const $itemEl = dom7_default(itemEl).eq(0);
    if (!$itemEl.length)
      return;
    $itemEl.removeClass("treeview-item-opened");
    $itemEl.trigger("treeview:close");
    app.emit("treeviewClose", $itemEl[0]);
  },
  toggle(itemEl) {
    const app = this;
    const $itemEl = dom7_default(itemEl).eq(0);
    if (!$itemEl.length)
      return;
    const wasOpened = $itemEl.hasClass("treeview-item-opened");
    app.treeview[wasOpened ? "close" : "open"]($itemEl);
  }
};
var treeview_default = {
  name: "treeview",
  create() {
    const app = this;
    bindMethods(app, {
      treeview: Treeview
    });
  },
  clicks: {
    ".treeview-toggle": function toggle3($clickedEl, clickedData, e) {
      const app = this;
      if ($clickedEl.parents(".treeview-item-toggle").length)
        return;
      const $treeviewItemEl = $clickedEl.parents(".treeview-item").eq(0);
      if (!$treeviewItemEl.length)
        return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    },
    ".treeview-item-toggle": function toggle4($clickedEl, clickedData, e) {
      const app = this;
      const $treeviewItemEl = $clickedEl.closest(".treeview-item").eq(0);
      if (!$treeviewItemEl.length)
        return;
      e.preventF7Router = true;
      app.treeview.toggle($treeviewItemEl[0]);
    }
  }
};

// node_modules/framework7/components/text-editor/text-editor-class.js
var textEditorButtonsMap = {
  bold: ["bold", "format_bold", "bold"],
  italic: ["italic", "format_italic", "italic"],
  underline: ["underline", "format_underlined", "underline"],
  strikeThrough: ["strikethrough", "strikethrough_s", "strikeThrough"],
  orderedList: ["list_number", "format_list_numbered", "insertOrderedList"],
  unorderedList: ["list_bullet", "format_list_bulleted", "insertUnorderedList"],
  link: ["link", "link", "createLink"],
  image: ["photo", "image", "insertImage"],
  paragraph: ["paragraph", '<i class="icon">\xB6</i>', "formatBlock.P"],
  h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', "formatBlock.H1"],
  h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', "formatBlock.H2"],
  h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', "formatBlock.H3"],
  alignLeft: ["text_alignleft", "format_align_left", "justifyLeft"],
  alignCenter: ["text_aligncenter", "format_align_center", "justifyCenter"],
  alignRight: ["text_alignright", "format_align_right", "justifyRight"],
  alignJustify: ["text_justify", "format_align_justify", "justifyFull"],
  subscript: ["textformat_subscript", '<i class="icon">A<sub>1</sub></i>', "subscript"],
  superscript: ["textformat_superscript", '<i class="icon">A<sup>1</sup></i>', "superscript"],
  indent: ["increase_indent", "format_indent_increase", "indent"],
  outdent: ["decrease_indent", "format_indent_decrease", "outdent"]
};
var TextEditor = class extends class_default {
  constructor(app, params) {
    super(params, [app]);
    const self = this;
    const document = getDocument();
    const device = getDevice();
    const defaults = extend({}, app.params.textEditor);
    self.useModulesParams(defaults);
    self.params = extend(defaults, params);
    const el = self.params.el;
    if (!el)
      return self;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return self;
    if ($el[0].f7TextEditor)
      return $el[0].f7TextEditor;
    let $contentEl = $el.children(".text-editor-content");
    if (!$contentEl.length) {
      $el.append('<div class="text-editor-content" contenteditable></div>');
      $contentEl = $el.children(".text-editor-content");
    }
    extend(self, {
      app,
      $el,
      el: $el[0],
      $contentEl,
      contentEl: $contentEl[0]
    });
    if ("value" in params) {
      self.value = self.params.value;
    }
    if (self.params.mode === "keyboard-toolbar") {
      if (!(device.cordova || device.capacitor) && !device.android) {
        self.params.mode = "popover";
      }
    }
    if (typeof self.params.buttons === "string") {
      try {
        self.params.buttons = JSON.parse(self.params.buttons);
      } catch (err) {
        throw new Error('Framework7: TextEditor: wrong "buttons" parameter format');
      }
    }
    $el[0].f7TextEditor = self;
    self.onButtonClick = self.onButtonClick.bind(self);
    self.onFocus = self.onFocus.bind(self);
    self.onBlur = self.onBlur.bind(self);
    self.onInput = self.onInput.bind(self);
    self.onPaste = self.onPaste.bind(self);
    self.onSelectionChange = self.onSelectionChange.bind(self);
    self.closeKeyboardToolbar = self.closeKeyboardToolbar.bind(self);
    self.attachEvents = function attachEvents2() {
      if (self.params.mode === "toolbar") {
        self.$el.find(".text-editor-toolbar").on("click", "button", self.onButtonClick);
      }
      if (self.params.mode === "keyboard-toolbar") {
        self.$keyboardToolbarEl.on("click", "button", self.onButtonClick);
        self.$el.parents(".page").on("page:beforeout", self.closeKeyboardToolbar);
      }
      if (self.params.mode === "popover" && self.popover) {
        self.popover.$el.on("click", "button", self.onButtonClick);
      }
      self.$contentEl.on("paste", self.onPaste);
      self.$contentEl.on("focus", self.onFocus);
      self.$contentEl.on("blur", self.onBlur);
      self.$contentEl.on("input", self.onInput, true);
      dom7_default(document).on("selectionchange", self.onSelectionChange);
    };
    self.detachEvents = function detachEvents2() {
      if (self.params.mode === "toolbar") {
        self.$el.find(".text-editor-toolbar").off("click", "button", self.onButtonClick);
      }
      if (self.params.mode === "keyboard-toolbar") {
        self.$keyboardToolbarEl.off("click", "button", self.onButtonClick);
        self.$el.parents(".page").off("page:beforeout", self.closeKeyboardToolbar);
      }
      if (self.params.mode === "popover" && self.popover) {
        self.popover.$el.off("click", "button", self.onButtonClick);
      }
      self.$contentEl.off("paste", self.onPaste);
      self.$contentEl.off("focus", self.onFocus);
      self.$contentEl.off("blur", self.onBlur);
      self.$contentEl.off("input", self.onInput, true);
      dom7_default(document).off("selectionchange", self.onSelectionChange);
    };
    self.useModules();
    self.init();
    return self;
  }
  setValue(newValue) {
    const self = this;
    const currentValue = self.value;
    if (currentValue === newValue)
      return self;
    self.value = newValue;
    self.$contentEl.html(newValue);
    self.$el.trigger("texteditor:change", self.value);
    self.emit("local::change textEditorChange", self, self.value);
    return self;
  }
  getValue() {
    const self = this;
    return self.value;
  }
  clearValue() {
    const self = this;
    self.setValue("");
    if (self.params.placeholder && !self.$contentEl.html()) {
      self.insertPlaceholder();
    }
    return self;
  }
  createLink() {
    const self = this;
    const window2 = getWindow();
    const document = getDocument();
    const currentSelection = window2.getSelection();
    const selectedNodes = [];
    let $selectedLinks;
    if (currentSelection && currentSelection.anchorNode && dom7_default(currentSelection.anchorNode).parents(self.$el).length) {
      let anchorNode = currentSelection.anchorNode;
      while (anchorNode) {
        selectedNodes.push(anchorNode);
        if (!anchorNode.nextSibling || anchorNode === currentSelection.focusNode) {
          anchorNode = null;
        }
        if (anchorNode) {
          anchorNode = anchorNode.nextSibling;
        }
      }
      const selectedNodesLinks = [];
      const $selectedNodes = dom7_default(selectedNodes);
      for (let i = 0; i < $selectedNodes.length; i += 1) {
        const childNodes = $selectedNodes[i].children;
        if (childNodes) {
          for (let j = 0; j < childNodes.length; j += 1) {
            if (dom7_default(childNodes[j]).is("a")) {
              selectedNodesLinks.push(childNodes[j]);
            }
          }
        }
      }
      $selectedLinks = $selectedNodes.closest("a").add(dom7_default(selectedNodesLinks));
    }
    if ($selectedLinks && $selectedLinks.length) {
      $selectedLinks.each((linkNode) => {
        const selection = window2.getSelection();
        const range = document.createRange();
        range.selectNodeContents(linkNode);
        selection.removeAllRanges();
        selection.addRange(range);
        document.execCommand("unlink", false);
        selection.removeAllRanges();
      });
      return self;
    }
    const currentRange = self.getSelectionRange();
    if (!currentRange)
      return self;
    const dialog = self.app.dialog.prompt(self.params.linkUrlText, "", (link) => {
      if (link && link.trim().length) {
        self.setSelectionRange(currentRange);
        document.execCommand("createLink", false, link.trim());
        self.$el.trigger("texteditor:insertlink", {
          url: link.trim()
        });
        self.emit("local:insertLink textEditorInsertLink", self, link.trim());
      }
    });
    dialog.$el.find("input").focus();
    return self;
  }
  insertImage() {
    const self = this;
    const document = getDocument();
    const currentRange = self.getSelectionRange();
    if (!currentRange)
      return self;
    const dialog = self.app.dialog.prompt(self.params.imageUrlText, "", (imageUrl) => {
      if (imageUrl && imageUrl.trim().length) {
        self.setSelectionRange(currentRange);
        document.execCommand("insertImage", false, imageUrl.trim());
        self.$el.trigger("texteditor:insertimage", {
          url: imageUrl.trim()
        });
        self.emit("local:insertImage textEditorInsertImage", self, imageUrl.trim());
      }
    });
    dialog.$el.find("input").focus();
    return self;
  }
  removePlaceholder() {
    const self = this;
    self.$contentEl.find(".text-editor-placeholder").remove();
  }
  insertPlaceholder() {
    const self = this;
    self.$contentEl.append(`<div class="text-editor-placeholder">${self.params.placeholder}</div>`);
  }
  onSelectionChange() {
    const self = this;
    const window2 = getWindow();
    const document = getDocument();
    if (self.params.mode === "toolbar")
      return;
    const selection = window2.getSelection();
    const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (self.params.mode === "keyboard-toolbar") {
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      } else {
        self.openKeyboardToolbar();
      }
      return;
    }
    if (self.params.mode === "popover") {
      const selectionIsInPopover = dom7_default(selection.anchorNode).parents(self.popover.el).length || selection.anchorNode === self.popover.el;
      if (!selectionIsInContent && !selectionIsInPopover) {
        self.closePopover();
        return;
      }
      if (!selection.isCollapsed && selection.rangeCount) {
        const range = selection.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        const rootEl = self.app.$el[0] || document.body;
        self.openPopover(rect.x + (window2.scrollX || 0) - rootEl.offsetLeft, rect.y + (window2.scrollY || 0) - rootEl.offsetTop, rect.width, rect.height);
      } else if (selection.isCollapsed) {
        self.closePopover();
      }
    }
  }
  onPaste(e) {
    const self = this;
    const document = getDocument();
    if (self.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) {
      const text2 = e.clipboardData.getData("text/plain");
      e.preventDefault();
      document.execCommand("insertText", false, text2);
    }
  }
  onInput() {
    const self = this;
    const value = self.$contentEl.html();
    self.value = value;
    self.$el.trigger("texteditor:input");
    self.emit("local:input textEditorInput", self, self.value);
    self.$el.trigger("texteditor:change", self.value);
    self.emit("local::change textEditorChange", self, self.value);
  }
  onFocus() {
    const self = this;
    self.removePlaceholder();
    self.$contentEl.focus();
    self.$el.trigger("texteditor:focus");
    self.emit("local::focus textEditorFocus", self);
  }
  onBlur() {
    const self = this;
    const window2 = getWindow();
    const document = getDocument();
    if (self.params.placeholder && self.$contentEl.html() === "") {
      self.insertPlaceholder();
    }
    if (self.params.mode === "popover") {
      const selection = window2.getSelection();
      const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      const inPopover = document.activeElement && self.popover && dom7_default(document.activeElement).closest(self.popover.$el).length;
      if (!inPopover && !selectionIsInContent) {
        self.closePopover();
      }
    }
    if (self.params.mode === "keyboard-toolbar") {
      const selection = window2.getSelection();
      const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      if (!selectionIsInContent) {
        self.closeKeyboardToolbar();
      }
    }
    self.$el.trigger("texteditor:blur");
    self.emit("local::blur textEditorBlur", self);
  }
  onButtonClick(e) {
    const self = this;
    const window2 = getWindow();
    const document = getDocument();
    const selection = window2.getSelection();
    const selectionIsInContent = dom7_default(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
    if (!selectionIsInContent)
      return;
    const $buttonEl = dom7_default(e.target).closest("button");
    if ($buttonEl.parents("form").length) {
      e.preventDefault();
    }
    const button = $buttonEl.attr("data-button");
    const buttonData = self.params.customButtons && self.params.customButtons[button];
    if (!button || !(textEditorButtonsMap[button] || buttonData))
      return;
    $buttonEl.trigger("texteditor:buttonclick", button);
    self.emit("local::buttonClick textEditorButtonClick", self, button);
    if (buttonData) {
      if (buttonData.onClick)
        buttonData.onClick(self, $buttonEl[0]);
      return;
    }
    const command = textEditorButtonsMap[button][2];
    if (command === "createLink") {
      self.createLink();
      return;
    }
    if (command === "insertImage") {
      self.insertImage();
      return;
    }
    if (command.indexOf("formatBlock") === 0) {
      const tagName = command.split(".")[1];
      const $anchorNode = dom7_default(selection.anchorNode);
      if ($anchorNode.parents(tagName.toLowerCase()).length || $anchorNode.is(tagName)) {
        document.execCommand("formatBlock", false, "div");
      } else {
        document.execCommand("formatBlock", false, tagName);
      }
      return;
    }
    document.execCommand(command, false);
  }
  getSelectionRange() {
    const window2 = getWindow();
    const document = getDocument();
    if (window2.getSelection) {
      const sel = window2.getSelection();
      if (sel.getRangeAt && sel.rangeCount) {
        return sel.getRangeAt(0);
      }
    } else if (document.selection && document.selection.createRange) {
      return document.selection.createRange();
    }
    return null;
  }
  setSelectionRange(range) {
    const window2 = getWindow();
    const document = getDocument();
    if (range) {
      if (window2.getSelection) {
        const sel = window2.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (document.selection && range.select) {
        range.select();
      }
    }
  }
  renderButtons() {
    const self = this;
    let html2 = "";
    function renderButton(button) {
      const iconClass = self.app.theme === "md" ? "material-icons" : "f7-icons";
      if (self.params.customButtons && self.params.customButtons[button]) {
        const buttonData = self.params.customButtons[button];
        return `<button type="button" class="text-editor-button" data-button="${button}">${buttonData.content || ""}</button>`;
      }
      if (!textEditorButtonsMap[button])
        return "";
      const iconContent = textEditorButtonsMap[button][self.app.theme === "md" ? 1 : 0];
      return `<button type="button" class="text-editor-button" data-button="${button}">${iconContent.indexOf("<") >= 0 ? iconContent : `<i class="${iconClass}">${iconContent}</i>`}</button>`.trim();
    }
    self.params.buttons.forEach((button, buttonIndex) => {
      if (Array.isArray(button)) {
        button.forEach((b) => {
          html2 += renderButton(b);
        });
        if (buttonIndex < self.params.buttons.length - 1 && self.params.dividers) {
          html2 += '<div class="text-editor-button-divider"></div>';
        }
      } else {
        html2 += renderButton(button);
      }
    });
    return html2;
  }
  createToolbar() {
    const self = this;
    self.$el.prepend(`<div class="text-editor-toolbar">${self.renderButtons()}</div>`);
  }
  createKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl = dom7_default(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar"><div class="toolbar-inner">${self.renderButtons()}</div></div>`);
  }
  createPopover() {
    const self = this;
    self.popover = self.app.popover.create({
      content: `
        <div class="popover dark text-editor-popover">
          <div class="popover-inner">${self.renderButtons()}</div>
        </div>
      `,
      closeByOutsideClick: false,
      backdrop: false
    });
  }
  openKeyboardToolbar() {
    const self = this;
    if (self.$keyboardToolbarEl.parent(self.app.$el).length)
      return;
    self.$el.trigger("texteditor:keyboardopen");
    self.emit("local::keyboardOpen textEditorKeyboardOpen", self);
    self.app.$el.append(self.$keyboardToolbarEl);
  }
  closeKeyboardToolbar() {
    const self = this;
    self.$keyboardToolbarEl.remove();
    self.$el.trigger("texteditor:keyboardclose");
    self.emit("local::keyboardClose textEditorKeyboardClose", self);
  }
  openPopover(targetX, targetY, targetWidth, targetHeight) {
    const self = this;
    if (!self.popover)
      return;
    Object.assign(self.popover.params, {
      targetX,
      targetY,
      targetWidth,
      targetHeight
    });
    clearTimeout(self.popoverTimeout);
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover)
        return;
      if (self.popover.opened) {
        self.popover.resize();
      } else {
        self.$el.trigger("texteditor:popoveropen");
        self.emit("local::popoverOpen textEditorPopoverOpen", self);
        self.popover.open();
      }
    }, 400);
  }
  closePopover() {
    const self = this;
    clearTimeout(self.popoverTimeout);
    if (!self.popover || !self.popover.opened)
      return;
    self.popoverTimeout = setTimeout(() => {
      if (!self.popover)
        return;
      self.$el.trigger("texteditor:popoverclose");
      self.emit("local::popoverClose textEditorPopoverClose", self);
      self.popover.close();
    }, 400);
  }
  init() {
    const self = this;
    if (self.value) {
      self.$contentEl.html(self.value);
    } else {
      self.value = self.$contentEl.html();
    }
    if (self.params.placeholder && self.value === "") {
      self.insertPlaceholder();
    }
    if (self.params.mode === "toolbar") {
      self.createToolbar();
    } else if (self.params.mode === "popover") {
      self.createPopover();
    } else if (self.params.mode === "keyboard-toolbar") {
      self.createKeyboardToolbar();
    }
    self.attachEvents();
    self.$el.trigger("texteditor:init");
    self.emit("local::init textEditorInit", self);
    return self;
  }
  destroy() {
    let self = this;
    self.$el.trigger("texteditor:beforedestroy");
    self.emit("local::beforeDestroy textEditorBeforeDestroy", self);
    self.detachEvents();
    if (self.params.mode === "keyboard-toolbar" && self.$keyboardToolbarEl) {
      self.$keyboardToolbarEl.remove();
    }
    if (self.popover) {
      self.popover.close(false);
      self.popover.destroy();
    }
    delete self.$el[0].f7TextEditor;
    deleteProps(self);
    self = null;
  }
};
var text_editor_class_default = TextEditor;

// node_modules/framework7/components/text-editor/text-editor.js
var text_editor_default = {
  name: "textEditor",
  params: {
    textEditor: {
      el: null,
      mode: "toolbar",
      value: void 0,
      customButtons: null,
      buttons: [["bold", "italic", "underline", "strikeThrough"], ["orderedList", "unorderedList"], ["link", "image"], ["paragraph", "h1", "h2", "h3"], ["alignLeft", "alignCenter", "alignRight", "alignJustify"], ["subscript", "superscript"], ["indent", "outdent"]],
      dividers: true,
      imageUrlText: "Insert image URL",
      linkUrlText: "Insert link URL",
      placeholder: null,
      clearFormattingOnPaste: true
    }
  },
  create() {
    const app = this;
    app.textEditor = extend(ConstructorMethods({
      defaultSelector: ".text-editor",
      constructor: text_editor_class_default,
      app,
      domProp: "f7TextEditor"
    }));
  },
  static: {
    TextEditor: text_editor_class_default
  },
  on: {
    tabMounted(tabEl) {
      const app = this;
      dom7_default(tabEl).find(".text-editor-init").each((editorEl) => {
        const dataset = dom7_default(editorEl).dataset();
        app.textEditor.create(extend({
          el: editorEl
        }, dataset || {}));
      });
    },
    tabBeforeRemove(tabEl) {
      dom7_default(tabEl).find(".text-editor-init").each((editorEl) => {
        if (editorEl.f7TextEditor)
          editorEl.f7TextEditor.destroy();
      });
    },
    pageInit(page) {
      const app = this;
      page.$el.find(".text-editor-init").each((editorEl) => {
        const dataset = dom7_default(editorEl).dataset();
        app.textEditor.create(extend({
          el: editorEl
        }, dataset || {}));
      });
    },
    pageBeforeRemove(page) {
      page.$el.find(".text-editor-init").each((editorEl) => {
        if (editorEl.f7TextEditor)
          editorEl.f7TextEditor.destroy();
      });
    }
  },
  vnode: {
    "text-editor-init": {
      insert(vnode) {
        const app = this;
        const editorEl = vnode.elm;
        const dataset = dom7_default(editorEl).dataset();
        app.textEditor.create(extend({
          el: editorEl
        }, dataset || {}));
      },
      destroy(vnode) {
        const editorEl = vnode.elm;
        if (editorEl.f7TextEditor)
          editorEl.f7TextEditor.destroy();
      }
    }
  }
};

// node_modules/framework7/components/pie-chart/pie-chart-class.js
var PieChart = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const self = this;
    const defaults = extend({}, app.params.pieChart);
    self.useModulesParams(defaults);
    self.params = extend(defaults, params);
    const {
      el
    } = self.params;
    if (!el)
      return self;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return self;
    if ($el[0].f7PieChart)
      return $el[0].f7PieChart;
    extend(self, {
      app,
      $el,
      el: $el && $el[0],
      currentIndex: null,
      f7Tooltip: null
    });
    $el[0].f7PieChart = self;
    self.useModules();
    self.showTooltip = self.showTooltip.bind(this);
    self.hideTooltip = self.hideTooltip.bind(this);
    self.init();
    return self;
  }
  getSummValue() {
    const {
      datasets
    } = this.params;
    let summ = 0;
    datasets.map((d) => d.value || 0).forEach((value) => {
      summ += value;
    });
    return summ;
  }
  getPaths() {
    const {
      datasets,
      size
    } = this.params;
    const paths = [];
    let cumulativePercentage = 0;
    function getCoordinatesForPercentage(percentage) {
      const x = Math.cos(2 * Math.PI * percentage) * (size / 3);
      const y = Math.sin(2 * Math.PI * percentage) * (size / 3);
      return [x, y];
    }
    datasets.forEach((_ref) => {
      let {
        value,
        label,
        color
      } = _ref;
      const percentage = value / this.getSummValue();
      const [startX, startY] = getCoordinatesForPercentage(cumulativePercentage);
      cumulativePercentage += percentage;
      const [endX, endY] = getCoordinatesForPercentage(cumulativePercentage);
      const largeArcFlag = percentage > 0.5 ? 1 : 0;
      const points = [
        `M ${startX} ${startY}`,
        `A ${size / 3} ${size / 3} 0 ${largeArcFlag} 1 ${endX} ${endY}`,
        "L 0 0"
      ].join(" ");
      paths.push({
        points,
        label,
        color
      });
    });
    return paths;
  }
  formatTooltipText() {
    const {
      datasets
    } = this.params;
    const {
      currentIndex
    } = this;
    if (currentIndex === null)
      return "";
    const {
      value,
      label,
      color
    } = datasets[currentIndex];
    const percentage = value / this.getSummValue() * 100;
    const round = (v) => {
      if (parseInt(v, 10) === v)
        return v;
      return Math.round(v * 100) / 100;
    };
    if (this.params.formatTooltip) {
      return this.params.formatTooltip.call(this, {
        index: currentIndex,
        value,
        label,
        color,
        percentage
      });
    }
    const tooltipText = `${label ? `${label}: ` : ""}${round(value)} (${round(percentage)}%)`;
    return `
      <div class="pie-chart-tooltip-label">
        <span class="pie-chart-tooltip-color" style="background-color: ${color};"></span> ${tooltipText}
      </div>
    `;
  }
  setTooltip() {
    const self = this;
    const {
      currentIndex,
      el,
      app,
      params
    } = self;
    const {
      tooltip
    } = params;
    if (currentIndex === null && !self.f7Tooltip)
      return;
    if (!tooltip || !el)
      return;
    if (currentIndex !== null && !self.f7Tooltip) {
      self.f7Tooltip = app.tooltip.create({
        trigger: "manual",
        containerEl: el,
        targetEl: el.querySelector(`path[data-index="${currentIndex}"]`),
        text: self.formatTooltipText(),
        cssClass: "pie-chart-tooltip"
      });
      self.f7Tooltip.show();
      return;
    }
    if (!self.f7Tooltip)
      return;
    if (currentIndex !== null) {
      self.f7Tooltip.setText(self.formatTooltipText());
      self.f7Tooltip.setTargetEl(el.querySelector(`path[data-index="${currentIndex}"]`));
      self.f7Tooltip.show();
    } else {
      self.f7Tooltip.hide();
    }
  }
  render() {
    const self = this;
    const size = self.params.size;
    const paths = self.getPaths();
    return jsx_default2("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width: size,
      viewBox: `-${size / 3} -${size / 3} ${size * 2 / 3} ${size * 2 / 3}`,
      style: "transform: rotate(-90deg)"
    }, paths.map((path, index2) => jsx_default2("path", {
      d: path.points,
      fill: path.color,
      "data-index": index2
    })));
  }
  update(newParams) {
    if (newParams === void 0) {
      newParams = {};
    }
    const self = this;
    const {
      params
    } = self;
    Object.keys(newParams).forEach((param) => {
      if (typeof newParams[param] !== "undefined") {
        params[param] = newParams[param];
      }
    });
    if (self.$svgEl.length === 0)
      return self;
    self.$svgEl.remove();
    delete self.$svgEl.f7PieChart;
    const $svgEl = dom7_default(self.render()).eq(0);
    $svgEl.f7PieChart = self;
    extend(self, {
      $svgEl,
      svgEl: $svgEl && $svgEl[0]
    });
    self.$el.append($svgEl);
    return self;
  }
  setCurrentIndex(index2) {
    const self = this;
    if (index2 === self.currentIndex)
      return;
    const {
      datasets
    } = self.params;
    self.currentIndex = index2;
    self.$el.trigger("piechart:select", {
      index: index2,
      dataset: datasets[index2]
    });
    self.emit("local::select pieChartSelect", self, index2, datasets[index2]);
  }
  showTooltip(e) {
    const newIndex = parseInt(e.target.getAttribute("data-index"), 10);
    this.setCurrentIndex(newIndex);
    this.$svgEl.find("path").removeClass("pie-chart-hidden").forEach((el, index2) => {
      if (index2 !== this.currentIndex)
        dom7_default(el).addClass("pie-chart-hidden");
    });
    this.setTooltip();
  }
  hideTooltip() {
    this.setCurrentIndex(null);
    this.$svgEl.find("path").removeClass("pie-chart-hidden");
    this.setTooltip();
  }
  init() {
    const self = this;
    const $svgEl = dom7_default(self.render()).eq(0);
    $svgEl.f7PieChart = self;
    extend(self, {
      $svgEl,
      svgEl: $svgEl && $svgEl[0]
    });
    self.$el.append($svgEl);
    self.$el.on("click mouseenter", "path", self.showTooltip, true);
    self.$el.on("mouseleave", "path", self.hideTooltip, true);
    return self;
  }
  destroy() {
    const self = this;
    if (!self.$el || self.destroyed)
      return;
    self.$el.trigger("piechart:beforedestroy");
    self.emit("local::beforeDestroy pieChartBeforeDestroy", self);
    self.$el.off("click mouseenter", "path", self.showTooltip, true);
    self.$el.off("mouseleave", "path", self.hideTooltip, true);
    self.$svgEl.remove();
    if (self.f7Tooltip && self.f7Tooltip.destroy) {
      self.f7Tooltip.destroy();
    }
    delete self.$el[0].f7PieChart;
    deleteProps(self);
    self.destroyed = true;
  }
};
var pie_chart_class_default = PieChart;

// node_modules/framework7/components/pie-chart/pie-chart.js
var pie_chart_default = {
  name: "pieChart",
  params: {
    pieChart: {
      el: null,
      datasets: [],
      size: 320,
      tooltip: false,
      formatTooltip: null
    }
  },
  create() {
    const app = this;
    app.pieChart = ConstructorMethods({
      defaultSelector: ".pie-chart",
      constructor: pie_chart_class_default,
      app,
      domProp: "f7PieChart"
    });
    app.pieChart.update = function update(el, newParams) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const pieChart = app.pieChart.get(el);
      if (!pieChart)
        return void 0;
      pieChart.update(newParams);
      return pieChart;
    };
  }
};

// node_modules/framework7/components/area-chart/area-chart-class.js
var AreaChart = class extends class_default {
  constructor(app, params) {
    if (params === void 0) {
      params = {};
    }
    super(params, [app]);
    const self = this;
    const defaults = extend({}, app.params.areaChart);
    self.useModulesParams(defaults);
    self.params = extend(defaults, params);
    const {
      el
    } = self.params;
    if (!el)
      return self;
    const $el = dom7_default(el);
    if ($el.length === 0)
      return self;
    if ($el[0].f7AreaChart)
      return $el[0].f7AreaChart;
    extend(self, {
      app,
      $el,
      el: $el && $el[0],
      currentIndex: null,
      hiddenDatasets: [],
      f7Tooltip: null,
      linesOffsets: null
    });
    $el[0].f7AreaChart = self;
    self.useModules();
    self.onMouseEnter = self.onMouseEnter.bind(self);
    self.onMouseMove = self.onMouseMove.bind(self);
    self.onMouseLeave = self.onMouseLeave.bind(self);
    self.onLegendClick = self.onLegendClick.bind(self);
    self.init();
    return self;
  }
  getVisibleLabels() {
    const {
      maxAxisLabels,
      axisLabels
    } = this.params;
    if (!maxAxisLabels || axisLabels.length <= maxAxisLabels)
      return axisLabels;
    const skipStep = Math.ceil(axisLabels.length / maxAxisLabels);
    const filtered = axisLabels.filter((label, index2) => index2 % skipStep === 0);
    return filtered;
  }
  getSummValues() {
    const {
      datasets
    } = this.params;
    const {
      hiddenDatasets
    } = this;
    const summValues = [];
    datasets.filter((dataset, index2) => !hiddenDatasets.includes(index2)).forEach((_ref) => {
      let {
        values
      } = _ref;
      values.forEach((value, valueIndex) => {
        if (!summValues[valueIndex])
          summValues[valueIndex] = 0;
        summValues[valueIndex] += value;
      });
    });
    return summValues;
  }
  getChartData() {
    const {
      datasets,
      lineChart,
      width,
      height
    } = this.params;
    const {
      hiddenDatasets
    } = this;
    const data = [];
    if (!datasets.length) {
      return data;
    }
    const lastValues = datasets[0].values.map(() => 0);
    let maxValue = 0;
    if (lineChart) {
      datasets.filter((dataset, index2) => !hiddenDatasets.includes(index2)).forEach((_ref2) => {
        let {
          values
        } = _ref2;
        const datasetMaxValue = Math.max(...values);
        if (datasetMaxValue > maxValue)
          maxValue = datasetMaxValue;
      });
    } else {
      maxValue = Math.max(...this.getSummValues());
    }
    datasets.filter((dataset, index2) => !hiddenDatasets.includes(index2)).forEach((_ref3) => {
      let {
        label,
        values,
        color
      } = _ref3;
      const points = values.map((originalValue, valueIndex) => {
        lastValues[valueIndex] += originalValue;
        const value = lineChart ? originalValue : lastValues[valueIndex];
        const x = valueIndex / (values.length - 1) * width;
        const y = height - value / maxValue * height;
        if (lineChart) {
          return `${valueIndex === 0 ? "M" : "L"}${x},${y}`;
        }
        return `${x} ${y}`;
      });
      if (!lineChart) {
        points.push(`${width} ${height} 0 ${height}`);
      }
      data.push({
        label,
        points: points.join(" "),
        color
      });
    });
    return data.reverse();
  }
  getVerticalLines() {
    const {
      datasets,
      width
    } = this.params;
    const lines = [];
    if (!datasets.length) {
      return lines;
    }
    const values = datasets[0].values;
    values.forEach((value, valueIndex) => {
      const x = valueIndex / (values.length - 1) * width;
      lines.push(x);
    });
    return lines;
  }
  toggleDataset(index2) {
    const {
      hiddenDatasets,
      params: {
        toggleDatasets
      }
    } = this;
    if (!toggleDatasets)
      return;
    if (hiddenDatasets.includes(index2)) {
      hiddenDatasets.splice(hiddenDatasets.indexOf(index2), 1);
    } else {
      hiddenDatasets.push(index2);
    }
    if (this.$legendEl) {
      this.$legendEl.find(".area-chart-legend-item").removeClass("area-chart-legend-item-hidden");
      hiddenDatasets.forEach((i) => {
        this.$legendEl.find(`.area-chart-legend-item[data-index="${i}"]`).addClass("area-chart-legend-item-hidden");
      });
    }
    this.update({}, true);
  }
  formatAxisLabel(label) {
    const {
      formatAxisLabel
    } = this.params;
    if (formatAxisLabel)
      return formatAxisLabel.call(this, label);
    return label;
  }
  formatLegendLabel(label) {
    const {
      formatLegendLabel
    } = this.params;
    if (formatLegendLabel)
      return formatLegendLabel.call(this, label);
    return label;
  }
  calcLinesOffsets() {
    const lines = this.svgEl.querySelectorAll("line");
    this.linesOffsets = [];
    for (let i = 0; i < lines.length; i += 1) {
      this.linesOffsets.push(lines[i].getBoundingClientRect().left);
    }
  }
  formatTooltip() {
    const self = this;
    const {
      currentIndex,
      hiddenDatasets,
      params: {
        datasets,
        axisLabels,
        formatTooltip,
        formatTooltipTotal,
        formatTooltipAxisLabel,
        formatTooltipDataset
      }
    } = self;
    if (currentIndex === null)
      return "";
    let total = 0;
    const currentValues = datasets.filter((dataset, index2) => !hiddenDatasets.includes(index2)).map((dataset) => ({
      color: dataset.color,
      label: dataset.label,
      value: dataset.values[currentIndex]
    }));
    currentValues.forEach((dataset) => {
      total += dataset.value;
    });
    if (formatTooltip) {
      return formatTooltip({
        index: currentIndex,
        total,
        datasets: currentValues
      });
    }
    let labelText = formatTooltipAxisLabel ? formatTooltipAxisLabel.call(self, axisLabels[currentIndex]) : this.formatAxisLabel(axisLabels[currentIndex]);
    if (!labelText)
      labelText = "";
    const totalText = formatTooltipTotal ? formatTooltipTotal.call(self, total) : total;
    const datasetsText = currentValues.length > 0 ? `
      <ul class="area-chart-tooltip-list">
        ${currentValues.map((_ref4) => {
      let {
        label,
        color,
        value
      } = _ref4;
      const valueText = formatTooltipDataset ? formatTooltipDataset.call(self, label, value, color) : `${label ? `${label}: ` : ""}${value}`;
      return `
              <li><span style="background-color: ${color};"></span>${valueText}</li>
            `;
    }).join("")}
      </ul>` : "";
    return `
      <div class="area-chart-tooltip-label">${labelText}</div>
      <div class="area-chart-tooltip-total">${totalText}</div>
      ${datasetsText}
    `;
  }
  setTooltip() {
    const self = this;
    const {
      app,
      el,
      svgEl,
      hiddenDatasets,
      currentIndex,
      params: {
        tooltip,
        datasets
      }
    } = self;
    if (!tooltip)
      return;
    const hasVisibleDataSets = datasets.filter((dataset, index2) => !hiddenDatasets.includes(index2)).length > 0;
    if (!hasVisibleDataSets) {
      if (self.f7Tooltip && self.f7Tooltip.hide)
        self.f7Tooltip.hide();
      return;
    }
    if (currentIndex !== null && !self.f7Tooltip) {
      self.f7Tooltip = app.tooltip.create({
        trigger: "manual",
        containerEl: el,
        targetEl: svgEl.querySelector(`line[data-index="${currentIndex}"]`),
        text: self.formatTooltip(),
        cssClass: "area-chart-tooltip"
      });
      if (self.f7Tooltip && self.f7Tooltip.show) {
        self.f7Tooltip.show();
      }
      return;
    }
    if (!self.f7Tooltip || !self.f7Tooltip.hide || !self.f7Tooltip.show) {
      return;
    }
    if (currentIndex !== null) {
      self.f7Tooltip.setText(self.formatTooltip());
      self.f7Tooltip.setTargetEl(svgEl.querySelector(`line[data-index="${currentIndex}"]`));
      self.f7Tooltip.show();
    } else {
      self.f7Tooltip.hide();
    }
  }
  setCurrentIndex(index2) {
    if (index2 === this.currentIndex)
      return;
    this.currentIndex = index2;
    this.$el.trigger("areachart:select", {
      index: index2
    });
    this.emit("local::select areaChartSelect", this, index2);
    this.$svgEl.find("line").removeClass("area-chart-current-line");
    this.$svgEl.find(`line[data-index="${index2}"]`).addClass("area-chart-current-line");
    this.setTooltip();
  }
  onLegendClick(e) {
    const index2 = parseInt(dom7_default(e.target).closest(".area-chart-legend-item").attr("data-index"), 10);
    this.toggleDataset(index2);
  }
  onMouseEnter() {
    this.calcLinesOffsets();
  }
  onMouseMove(e) {
    const self = this;
    if (!self.linesOffsets) {
      self.calcLinesOffsets();
    }
    let currentLeft = e.pageX;
    if (typeof currentLeft === "undefined")
      currentLeft = 0;
    const distances = self.linesOffsets.map((left) => Math.abs(currentLeft - left));
    const minDistance = Math.min(...distances);
    const closestIndex = distances.indexOf(minDistance);
    self.setCurrentIndex(closestIndex);
  }
  onMouseLeave() {
    this.setCurrentIndex(null);
  }
  attachEvents() {
    const {
      svgEl,
      $el
    } = this;
    if (!svgEl)
      return;
    svgEl.addEventListener("mouseenter", this.onMouseEnter);
    svgEl.addEventListener("mousemove", this.onMouseMove);
    svgEl.addEventListener("mouseleave", this.onMouseLeave);
    $el.on("click", ".area-chart-legend-item", this.onLegendClick);
  }
  detachEvents() {
    const {
      svgEl,
      $el
    } = this;
    if (!svgEl)
      return;
    svgEl.removeEventListener("mouseenter", this.onMouseEnter);
    svgEl.removeEventListener("mousemove", this.onMouseMove);
    svgEl.removeEventListener("mouseleave", this.onMouseLeave);
    $el.off("click", ".area-chart-legend-item", this.onLegendClick);
  }
  render() {
    const self = this;
    const {
      lineChart,
      toggleDatasets,
      width,
      height,
      axis,
      axisLabels,
      legend,
      datasets
    } = self.params;
    const chartData = self.getChartData();
    const verticalLines = self.getVerticalLines();
    const visibleLegends = self.getVisibleLabels();
    const LegendItemTag = toggleDatasets ? "button" : "span";
    return jsx_default2("div", null, jsx_default2("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      width,
      height,
      viewBox: `0 0 ${width} ${height}`,
      preserveAspectRatio: "none"
    }, chartData.map((data) => lineChart ? jsx_default2("path", {
      stroke: data.color,
      "fill-rule": "evenodd",
      d: data.points
    }) : jsx_default2("polygon", {
      fill: data.color,
      "fill-rule": "evenodd",
      points: data.points
    })), verticalLines.map((line, index2) => jsx_default2("line", {
      "data-index": index2,
      fill: "#000",
      x1: line,
      y1: 0,
      x2: line,
      y2: height
    }))), axis && jsx_default2("div", {
      class: "area-chart-axis"
    }, axisLabels.map((label) => jsx_default2("span", null, visibleLegends.includes(label) && jsx_default2("span", null, self.formatAxisLabel(label))))), legend && jsx_default2("div", {
      class: "area-chart-legend"
    }, datasets.map((dataset, index2) => jsx_default2(LegendItemTag, {
      "data-index": index2,
      class: `area-chart-legend-item ${toggleDatasets ? "area-chart-legend-button" : ""}`,
      _type: toggleDatasets ? "button" : void 0
    }, jsx_default2("span", {
      style: `background-color: ${dataset.color}`
    }), self.formatLegendLabel(dataset.label)))));
  }
  update(newParams, onlySvg) {
    if (newParams === void 0) {
      newParams = {};
    }
    if (onlySvg === void 0) {
      onlySvg = false;
    }
    const self = this;
    const {
      params
    } = self;
    Object.keys(newParams).forEach((param) => {
      if (typeof newParams[param] !== "undefined") {
        params[param] = newParams[param];
      }
    });
    if (self.$svgEl.length === 0)
      return self;
    self.detachEvents();
    self.$svgEl.remove();
    if (!onlySvg) {
      self.$axisEl.remove();
      self.$legendEl.remove();
    }
    const $rendered = dom7_default(self.render());
    const $svgEl = $rendered.find("svg");
    extend(self, {
      svgEl: $svgEl && $svgEl[0],
      $svgEl
    });
    if (!onlySvg) {
      const $axisEl = $rendered.find(".area-chart-axis");
      const $legendEl = $rendered.find(".area-chart-legend");
      extend(self, {
        $axisEl,
        $legendEl
      });
      self.$el.append($axisEl);
      self.$el.append($legendEl);
    }
    self.$el.prepend($svgEl);
    self.attachEvents();
    return self;
  }
  init() {
    const self = this;
    const $rendered = dom7_default(self.render());
    const $svgEl = $rendered.find("svg");
    const $axisEl = $rendered.find(".area-chart-axis");
    const $legendEl = $rendered.find(".area-chart-legend");
    extend(self, {
      svgEl: $svgEl && $svgEl[0],
      $svgEl,
      $axisEl,
      $legendEl
    });
    self.$el.append($svgEl);
    self.$el.append($axisEl);
    self.$el.append($legendEl);
    self.attachEvents();
    return self;
  }
  destroy() {
    const self = this;
    if (!self.$el || self.destroyed)
      return;
    self.$el.trigger("piechart:beforedestroy");
    self.emit("local::beforeDestroy areaChartBeforeDestroy", self);
    self.detachEvents();
    self.$svgEl.remove();
    self.$axisEl.remove();
    self.$legendEl.remove();
    if (self.f7Tooltip && self.f7Tooltip.destroy) {
      self.f7Tooltip.destroy();
    }
    delete self.$el[0].f7AreaChart;
    deleteProps(self);
    self.destroyed = true;
  }
};
var area_chart_class_default = AreaChart;

// node_modules/framework7/components/area-chart/area-chart.js
var area_chart_default = {
  name: "areaChart",
  params: {
    areaChart: {
      el: null,
      lineChart: false,
      datasets: [],
      axis: false,
      axisLabels: [],
      tooltip: false,
      legend: false,
      toggleDatasets: false,
      width: 640,
      height: 320,
      maxAxisLabels: 8,
      formatAxisLabel: null,
      formatLegendLabel: null,
      formatTooltip: null,
      formatTooltipAxisLabel: null,
      formatTooltipTotal: null,
      formatTooltipDataset: null
    }
  },
  create() {
    const app = this;
    app.areaChart = ConstructorMethods({
      defaultSelector: ".area-chart",
      constructor: area_chart_class_default,
      app,
      domProp: "f7AreaChart"
    });
    app.areaChart.update = function update(el, newParams) {
      const $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      const areaChart = app.areaChart.get(el);
      if (!areaChart)
        return void 0;
      areaChart.update(newParams);
      return areaChart;
    };
  }
};

// node_modules/framework7/components/breadcrumbs/breadcrumbs.js
var Breadcrumbs = {};
var breadcrumbs_default = {
  name: "breadrumbs",
  create() {
    const app = this;
    bindMethods(app, {
      breadrumbs: Breadcrumbs
    });
  }
};

// node_modules/framework7/components/elevation/elevation.js
var elevation_default = {
  name: "elevation"
};

// node_modules/framework7/components/typography/typography.js
var typography_default = {
  name: "typography"
};

// node_modules/framework7/framework7-bundle.esm.js
router_class_default.use([component_loader_default]);
app_class_default.use([device_default, support_default, utils_default, resize_default, request_default2, touch_default, clicks_default, router_default, history_default, component_default, service_worker_default, store_default, statusbar_default, view_default, navbar_default, toolbar_default, subnavbar_default, touch_ripple_default, modal_default, appbar_default, dialog_default, popup_default, login_screen_default, popover_default, actions_default, sheet_default, toast_default, preloader_default, progressbar_default, sortable_default, swipeout_default, accordion_default, contacts_list_default, virtual_list_default, list_index_default, timeline_default, tabs_default, panel_default, card_default, chip_default, form_default, input_default, checkbox_default, radio_default, toggle_default, range_default, stepper_default, smart_select_default, grid_default, calendar_default, picker_default, infinite_scroll_default, pull_to_refresh_default, lazy_default, data_table_default, fab_default, searchbar_default, messages_default, messagebar_default, swiper_default, photo_browser_default, notification_default, autocomplete_default, tooltip_default, gauge_default, skeleton_default, menu_default, color_picker_default, treeview_default, text_editor_default, pie_chart_default, area_chart_default, breadcrumbs_default, elevation_default, typography_default]);
var framework7_bundle_esm_default = app_class_default;

// dep:framework7_bundle
var framework7_bundle_default = framework7_bundle_esm_default;
export {
  jsx_default as $jsx,
  component_class_default as Component,
  dom7_default as Dom7,
  create_store_default as createStore,
  framework7_bundle_default as default,
  getDevice,
  getSupport,
  request_default as request,
  utils_exports as utils
};
//# sourceMappingURL=framework7_bundle.js.map
